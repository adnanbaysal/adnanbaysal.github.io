<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagonal Truchet-Smith Tiling</title>
    <style>
        :root { 
            /* UNIFIED BLUE THEME */
            --accent: #00d2ff; 
            --accent-dim: rgba(0, 210, 255, 0.1);
            --bg: #050505; 
            --panel: #111; 
            --code-bg: #0d0d0d;
            --record: #eb4d4b;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; 
            display: flex; flex-direction: column; 
            background: var(--bg); color: #fff; 
            margin: 0; height: 100vh; overflow: hidden; 
        }
        
        /* --- Header --- */
        header { 
            background: var(--panel); padding: 8px 16px; 
            border-bottom: 1px solid #333; 
            display: flex; flex-wrap: wrap; align-items: center; justify-content: center;
            gap: 12px; z-index: 10; height: 60px; flex-shrink: 0;
        }
        
        .control-group { 
            display: flex; flex-direction: column; gap: 2px; 
            min-width: 80px;
        }

        .label-row { 
            display: flex; justify-content: space-between; 
            color: #888; font-size: 9px; font-weight: bold; text-transform: uppercase; 
        }
        
        span.value { color: var(--accent); font-family: monospace; }
        input[type="range"] { width: 90px; accent-color: var(--accent); cursor: pointer; height: 10px; }

        /* UI Controls */
        .ui-row { display: flex; align-items: center; gap: 8px; }

        .check-group { 
            display: flex; align-items: center; gap: 6px; 
            font-size: 11px; font-weight: bold; text-transform: uppercase; 
            color: #ccc; cursor: pointer; border: 1px solid #333; 
            padding: 0 8px; border-radius: 4px; background: #1a1a1a; height: 30px;
        }
        .check-group:hover { border-color: #666; color: #fff; }
        .check-group input { width: 14px; height: 14px; accent-color: var(--accent); cursor: pointer; margin: 0; }

        select.mode-select {
            background: #1a1a1a; color: #fff; border: 1px solid #333;
            font-size: 11px; font-weight: bold; text-transform: uppercase;
            height: 30px; border-radius: 4px; padding: 0 8px; cursor: pointer;
        }
        select.mode-select:hover { border-color: #666; }

        /* --- Main Layout --- */
        main { 
            flex-grow: 1; display: flex; flex-direction: row; 
            padding: 15px; gap: 15px; min-height: 0;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }

        .left-col { display: flex; flex-direction: column; width: 350px; gap: 10px; flex-shrink: 0; }
        .right-col { flex-grow: 1; display: flex; flex-direction: column; border: 1px solid #222; border-radius: 6px; background: #000; position: relative; }

        .panel-header {
            font-size: 11px; letter-spacing: 1px; color: var(--accent);
            text-transform: uppercase; font-weight: bold; opacity: 0.8;
            margin-bottom: 5px; display: flex; justify-content: space-between;
        }

        .canvas-wrapper {
            background: transparent;
            display: flex; align-items: center; justify-content: center;
            overflow: visible; 
            position: relative;
        }

        #matrix-wrapper { height: 280px; flex-shrink: 0; width: 100%; }
        #tile-wrapper { height: 100%; width: 100%; }

        /* Canvas fills the wrapper, JS controls drawing scale */
        canvas { 
            cursor: crosshair; image-rendering: auto; 
            width: 100%; height: 100%;
        }
        canvas:active { cursor: grabbing; }

        /* Recording Indicator */
        #rec-indicator {
            position: absolute; top: 15px; right: 15px; z-index: 20;
            background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px;
            display: none; align-items: center; gap: 8px; color: #fff;
            font-family: monospace; font-size: 12px; border: 1px solid var(--record);
        }
        .dot { width: 8px; height: 8px; background: var(--record); border-radius: 50%; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        /* --- Code Editor --- */
        .editor-container {
            flex-grow: 1; display: flex; flex-direction: column;
            background: var(--panel); border: 1px solid #333; border-radius: 6px;
            padding: 10px; min-height: 0;
        }

        select.preset-select {
            background: #222; color: #fff; border: 1px solid #444; 
            font-family: monospace; font-size: 11px; padding: 4px; 
            border-radius: 3px; width: 100%; cursor: pointer; margin-bottom: 8px;
        }

        textarea {
            flex-grow: 1; background: var(--code-bg); color: #ccc;
            border: 1px solid #333; border-radius: 4px;
            padding: 10px; font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px; line-height: 1.4; resize: none;
            outline: none; white-space: pre; margin-bottom: 8px;
        }
        textarea:focus { border-color: var(--accent); color: #fff; }

        .editor-actions { display: flex; gap: 8px; }

        /* --- Buttons --- */
        button { 
            border: none; padding: 0 12px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; transition: all 0.2s; 
            text-transform: uppercase; font-size: 10px; height: 30px;
            display: flex; align-items: center; justify-content: center; gap: 6px;
            font-family: inherit;
        }
        .btn-run { background: var(--accent); color: #000; flex-grow: 1; }
        .btn-run:hover { filter: brightness(1.2); box-shadow: 0 0 8px var(--accent-dim); }
        .btn-sec { background: #333; color: #ccc; }
        .btn-sec:hover { background: #444; color: #fff; }
        .btn-rec { background: var(--record); color: #fff; }
        .btn-rec:hover { filter: brightness(1.1); }
        .btn-icon { width: 30px; padding: 0; font-size: 14px; }
        .btn-util { background: #222; color: #888; }
        .btn-util:hover { color: #fff; }
        
        .btn-invert { 
            width: 30px; padding: 0; font-size: 16px; background: #1a1a1a; 
            border: 1px solid #333; color: var(--accent); 
        }
        .btn-invert:hover { background: #333; }

        /* --- Modal --- */
        #info-modal {
            position: absolute; top: 60px; left: 20px; z-index: 20;
            background: rgba(17, 17, 17, 0.96); backdrop-filter: blur(12px);
            border: 1px solid #333; border-radius: 8px;
            width: 350px; padding: 25px; font-size: 13px; line-height: 1.6;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); display: none;
            max-height: 80vh; overflow-y: auto;
        }
        #info-modal h2 { margin-top: 0; color: var(--accent); font-size: 16px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        #info-modal h3 { margin: 15px 0 5px 0; font-size: 12px; color: #fff; text-transform: uppercase; }
        #info-modal p { margin: 0 0 10px 0; color: #aaa; }
        .close-info { position: absolute; top: 15px; right: 15px; cursor: pointer; color: #666; font-size: 18px; }
        code { background: #222; padding: 2px 4px; border-radius: 3px; color: var(--accent); font-family: monospace; }

        /* --- MOBILE RESPONSIVE --- */
        @media (max-width: 900px) {
            body { height: auto; overflow-y: auto; }
            header { height: auto; padding: 10px; justify-content: center; gap: 15px; }
            main { flex-direction: column; height: auto; overflow: visible; }
            .left-col { width: 100%; order: 2; }
            .right-col { width: 100%; order: 1; height: 55vh; min-height: 350px; }
            #matrix-wrapper { margin: 0 auto; max-width: 100%; }
            .editor-container { min-height: 300px; }
        }

    </style>
</head>
<body>

    <header>
        <button id="info-btn" class="btn-sec btn-icon">?</button>
        
        <div class="control-group">
            <div class="label-row"><span>Radius (N)</span> <span id="n-val" class="value">7</span></div>
            <input type="range" id="param-n" min="1" max="100" step="1" value="16">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Thickness</span> <span id="w-val" class="value">2.0</span></div>
            <input type="range" id="param-w" min="0.5" max="10" step="0.5" value="2.0">
        </div>

        <div class="ui-row">
            <div class="control-group" style="min-width: 90px;">
                <div class="label-row"><span>Theme</span></div>
                <select id="theme-select" class="mode-select" style="width: 100%;">
                    </select>
            </div>

            <select id="draw-mode" class="mode-select">
                <option value="two-lines">Two Lines</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
            </select>
            
            <label class="check-group" title="Fill regions">
                <input type="checkbox" id="check-filled" checked="true"> Filled
            </label>
            
            <label class="check-group" title="Show Grid Lines">
                <input type="checkbox" id="check-grid"> Grid
            </label>
            
            <button id="invert-fill-btn" class="btn-invert" title="Invert Fill Logic">‚áÑ</button>
        </div>

        <div style="flex-grow:1"></div>
        
        <div class="control-group" style="border-right: 1px solid #333; padding-right: 10px;">
            <div class="label-row"><span>Speed</span> <span id="speed-val" class="value">6</span></div>
            <input type="range" id="anim-speed" min="1" max="10" step="1" value="6">
        </div>
        
        <select id="anim-type" class="mode-select" style="width: 100px;">
            <option value="none">Static</option>
            <option value="cell">Cell-by-Cell</option>
            <option value="rings">Rings</option>
            <option value="row">Rows</option>
            <option value="all">All-at-Once</option>
        </select>
        
        <button id="anim-play-btn" class="btn-sec btn-icon" title="Play Animation">‚ñ∂</button>
        <button id="rec-btn" class="btn-rec">‚è∫ REC</button>
        
        <div style="width: 1px; height: 30px; background: #333; margin: 0 5px;"></div>

        <button id="save-svg-btn" class="btn-util">SVG</button>
        <button id="save-img-btn" class="btn-util">PNG</button>
        <button onclick="window.location.href='index.html'" class="btn-util">üè†</button>
    </header>

    <main>
        <div class="left-col">
            <div>
                <div class="panel-header">Matrix State</div>
                <div id="matrix-wrapper" class="canvas-wrapper">
                    <canvas id="matrixCanvas"></canvas>
                </div>
            </div>

            <div class="editor-container">
                <div class="panel-header">Generator Function</div>
                
                <select id="preset-select" class="preset-select">
                    <optgroup label="Number Triangles">
                        <option value="pascal-xor">XOR of Pascal Triangle</option>
                        <option value="pascal-mod2">Mod 2 of Pascal Triangle</option>
                        <option value="hosoya-xor">XOR of Hosoya Triangle</option>
                        <option value="hosoya-mod2">Mod 2 of Hosoya Triangle</option>
                    </optgroup>
                    <optgroup label="Patterns">
                        <option value="xor">XOR Parity (Hex)</option>
                        <option value="ring">Concentric Rings</option>
                        <option value="sectors">Sectors</option>
                        <option value="flowers">Flowers</option>
                        <option value="spiral">Spiral</option>
                        <option value="propeller">Propellers</option>
                    </optgroup>
                    <optgroup label="Basic">
                        <option value="random">Random Noise</option>
                        <option value="all0">All Zero (Circles 1)</option>
                        <option value="all1">All One (Circles 2)</option>
                    </optgroup>
                    <optgroup label="User Saved" id="user-presets-group">
                    </optgroup>
                </select>

                <textarea id="code-area" spellcheck="false"></textarea>

                <div class="editor-actions">
                    <button id="save-preset-btn" class="btn-sec">üíæ Save</button>
                    <button id="run-btn" class="btn-run">‚ñ∂ Update Grid</button>
                </div>
                <div id="code-error" style="color: #ff4757; font-size: 10px; margin-top: 5px; display: none;">Error</div>
            </div>
            
            <div style="padding: 10px; background: #111; border: 1px solid #222; border-radius: 6px; font-size: 11px; color: #888;">
                <div class="panel-header">Coordinates</div>
                <p><strong>q, r, s</strong>: Cube coordinates.<br>Constraint: <code>q + r + s = 0</code></p>
                <p>Click on the grid to toggle a specific tile.</p>
            </div>
        </div>

        <div class="right-col">
            <div style="position: absolute; top: 10px; left: 10px; z-index: 5;" class="panel-header">Hexagonal Truchet</div>
            <div id="rec-indicator"><div class="dot"></div><span id="rec-timer">00:00</span></div>
            <div id="tile-wrapper" class="canvas-wrapper">
                <canvas id="tileCanvas"></canvas>
            </div>
        </div>

        <div id="info-modal">
            <span class="close-info" id="close-info">&times;</span>
            <h2>Hexagonal Truchet</h2>
            
            <h3>How It Works</h3>
            <p>This tool generates a tiling on a hexagonal grid using Smith tiles (3 paths per hexagon). The animation works by rotating the tile state 60 degrees.</p>
            
            <h3>Modes</h3>
            <ul style="padding-left: 20px; margin: 5px 0;">
                <li><strong>Straight:</strong> Linear connections.</li>
                <li><strong>Curved:</strong> Perfect circular arcs centered at vertices.</li>
                <li><strong>Two Lines:</strong> Angled segments creating parallelograms.</li>
            </ul>

            <h3>Animation</h3>
            <p>Select a mode (Rings, Cell, etc.) and click Play or Update Grid. The tiles will rotate to their new state, fading colors to match the topology.</p>

            <h3>Export</h3>
            <p><strong>SVG:</strong> Exports vector paths for use in plotters/design tools.</p>
            <p><strong>REC:</strong> Records the animation to WebM.</p>
        </div>
    </main>

<script>
    /**
     * STATE & CONFIG
     */
    // N = Internal Radius (0-indexed). 
    // Slider shows N + 1. 
    // Default 16 on slider => N = 15.
    let N = 15; 
    let lineWidth = 2.0;
    let isFilled = true;
    let showGrid = false;
    let isInvertedFill = false;
    let drawMode = 'two-lines'; 
    let currentTheme = 'neon';
    let hexSize = 20; // Will be calculated dynamically

    // Theme Config
    const themes = {
        neon: { name: "Neon Blue", bg: "#000000", line: "#00d2ff", alt: "#007799" },
        crimson: { name: "Crimson", bg: "#000000", line: "#ff4757", alt: "#8b2530" },
        emerald: { name: "Emerald", bg: "#000000", line: "#2ecc71", alt: "#166336" },
        golden: { name: "Golden", bg: "#1e272e", line: "#ffa502", alt: "#9c6501" },
        mono: { name: "Monochrome", bg: "#000000", line: "#ffffff", alt: "#666666" },
        print: { name: "Print (B/W)", bg: "#ffffff", line: "#000000", alt: "#888888" },
        purple: { name: "Cyber Purple", bg: "#0c0515", line: "#d630ff", alt: "#6a1b9a" }
    };
    
    // Data Storage
    // Keys are "q,r,s" strings
    let hexData = new Map();         // Target state (0 or 1)
    let currentAngles = new Map();   // Current rotation in radians

    // Animation Config
    const STEP_DURATION_LEVELS = [2.0, 1.7, 1.4, 1.1, 0.8, 0.5, 0.4, 0.3, 0.2, 0.1];
    let animType = 'none';
    let isAnimating = false;
    let animProgress = 0;
    let animDirection = 1; 
    let animationFrameId;
    let currentStepDuration = STEP_DURATION_LEVELS[5];
    let lastTime = 0;

    // Recording State
    let mediaRecorder;
    let recordedChunks = [];
    let recStartTime;
    let isRecording = false;

    // DOM Elements
    const tileCanvas = document.getElementById('tileCanvas');
    const matrixCanvas = document.getElementById('matrixCanvas');
    const ctx = tileCanvas.getContext('2d');
    const mCtx = matrixCanvas.getContext('2d');
    
    const ui = {
        n: document.getElementById('param-n'), nVal: document.getElementById('n-val'),
        w: document.getElementById('param-w'), wVal: document.getElementById('w-val'),
        filled: document.getElementById('check-filled'),
        grid: document.getElementById('check-grid'),
        mode: document.getElementById('draw-mode'),
        theme: document.getElementById('theme-select'),
        invertFill: document.getElementById('invert-fill-btn'),
        editor: document.getElementById('code-area'),
        select: document.getElementById('preset-select'),
        userGroup: document.getElementById('user-presets-group'),
        runBtn: document.getElementById('run-btn'),
        savePresetBtn: document.getElementById('save-preset-btn'),
        saveImgBtn: document.getElementById('save-img-btn'),
        saveSvgBtn: document.getElementById('save-svg-btn'),
        errorMsg: document.getElementById('code-error'),
        info: document.getElementById('info-modal'),
        infoBtn: document.getElementById('info-btn'),
        closeInfo: document.getElementById('close-info'),

        animType: document.getElementById('anim-type'),
        animSpeed: document.getElementById('anim-speed'),
        speedVal: document.getElementById('speed-val'),
        playBtn: document.getElementById('anim-play-btn'),
        recBtn: document.getElementById('rec-btn'),
        recInd: document.getElementById('rec-indicator'),
        recTimer: document.getElementById('rec-timer')
    };

    /**
     * PRESETS
     */
    const presets = {
        // --- NUMBER TRIANGLE FUNCTIONS ---
        'pascal-xor': `// 1. Generic Hex-to-Triangle Coordinate Mapping
// Maps (q,r,s) to symmetric 'row' and 'col'
// row = Distance from center (ring index)
// col = Distance from nearest sector axis (0 to row/2)
const abs = [Math.abs(q), Math.abs(r), Math.abs(s)].sort((a,b) => a-b);
const row = abs[2]; // max coordinate
const col = abs[0]; // min coordinate

// 2. Combinations nCr (using BigInt for large rows)
function nCr(n, r) {
    if (r < 0 || r > n) return 0n;
    if (r === 0 || r === n) return 1n;
    if (r > n / 2) r = n - r;
    let res = 1n;
    for (let i = 1n; i <= BigInt(r); i++) {
        res = res * (BigInt(n) - i + 1n) / i;
    }
    return res;
}

// 3. Calculate value
const val = nCr(row, col);

// 4. Return XOR Parity (popcount % 2)
let count = 0;
let v = val;
while (v > 0n) {
    if (v & 1n) count++;
    v >>= 1n;
}
return count % 2;`,

        'pascal-mod2': `// 1. Generic Hex-to-Triangle Coordinate Mapping
const abs = [Math.abs(q), Math.abs(r), Math.abs(s)].sort((a,b) => a-b);
const row = abs[2];
const col = abs[0];

// 2. Lucas' Theorem:
// binom(row, col) is odd if and only if (row & col) == col
// This is equivalent to "Mod 2 of Pascal Triangle"
return (row & col) === col ? 1 : 0;`,

        'hosoya-xor': `// 1. Map hex coordinates to symmetric triangle indices
const abs = [Math.abs(q), Math.abs(r), Math.abs(s)].sort((a,b) => a-b);
const row = abs[2]; 
const col = abs[0];

// 2. Fibonacci function (BigInt)
function fib(m) {
    if (m <= 0) return 0n;
    if (m === 1 || m === 2) return 1n;
    let a = 1n, b = 1n;
    for (let i = 3; i <= m; i++) {
        let temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}

// 3. Hosoya Value: H(n, k) = F(k+1) * F(n-k+1)
const val = fib(col + 1) * fib(row - col + 1);

// 4. Return XOR Parity (popcount % 2)
let count = 0;
let v = val;
while (v > 0n) {
    if (v & 1n) count++;
    v >>= 1n;
}
return count % 2;`,
        'hosoya-mod2': `// 1. Map hex coordinates to symmetric triangle indices
const abs = [Math.abs(q), Math.abs(r), Math.abs(s)].sort((a,b) => a-b);
const row = abs[2]; 
const col = abs[0];

// 2. Fibonacci property: F(m) % 2 == 0 if m % 3 == 0.
// H(n, k) is odd if both F(k+1) and F(n-k+1) are odd.
const f1_is_odd = (col + 1) % 3 !== 0;
const f2_is_odd = (row - col + 1) % 3 !== 0;

return (f1_is_odd && f2_is_odd) ? 1 : 0;`,

        xor: `// Helper: Positive parity
const p = (k) => ((Math.abs(k).toString(2).match(/1/g) || []).length % 2);
return p(q) ^ p(r) ^ p(s);`,
        ring: `let dist = (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;
return Math.floor(dist) % 2;`,
        sectors: `let angle = Math.atan2(Math.sqrt(3) * (r + s/2), 3/2 * s);
return Math.floor(3 * angle / Math.PI) % 2 ? 1 : 0;`,
        flowers: `return (Math.abs(q)%3 === 0 && Math.abs(r)%3 === 0) ? 1 : 0;`,
        spiral: `let dist = (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;
let angle = Math.atan2(Math.sqrt(3) * (q + r/2), 3/2 * r);
return (Math.floor(dist) + Math.floor(3 * angle)) % 2 ? 1 : 0;`,
        propeller: `return (q * r * s) % 2 === 0 ? 0 : 1;`,
        random: `return Math.random() > 0.5 ? 1 : 0;`,
        all0: `return 0;`,
        all1: `return 1;`
    };

    let userPresets = JSON.parse(localStorage.getItem('hex_truchet_presets') || '{}');

    function updatePresetDropdown() {
        ui.userGroup.innerHTML = '';
        Object.keys(userPresets).forEach(name => {
            const opt = document.createElement('option');
            opt.value = `user:${name}`;
            opt.textContent = name;
            ui.userGroup.appendChild(opt);
        });
    }

    function init() {
        // Populate Themes
        Object.keys(themes).forEach(k => {
            const opt = document.createElement('option');
            opt.value = k;
            opt.textContent = themes[k].name;
            ui.theme.appendChild(opt);
        });

        ui.editor.value = presets['pascal-xor']; // Set new default
        
        // Sync initial UI state
        ui.n.value = N + 1;
        ui.nVal.textContent = N + 1;

        // Listeners
        window.addEventListener('resize', resize);
        
        ui.n.addEventListener('input', (e) => { 
            const val = parseInt(e.target.value);
            N = val - 1; // Internal N is 0-indexed (Radius)
            ui.nVal.textContent = val; 
            runCode(); 
        });
        
        ui.w.addEventListener('input', (e) => { lineWidth = parseFloat(e.target.value); ui.wVal.textContent = lineWidth.toFixed(1); requestDraw(); });
        
        ui.filled.addEventListener('change', (e) => { isFilled = e.target.checked; requestDraw(); });
        ui.grid.addEventListener('change', (e) => { showGrid = e.target.checked; requestDraw(); });
        ui.mode.addEventListener('change', (e) => { drawMode = e.target.value; requestDraw(); });
        ui.theme.addEventListener('change', (e) => { currentTheme = e.target.value; requestDraw(); });
        ui.invertFill.addEventListener('click', () => { isInvertedFill = !isInvertedFill; requestDraw(); });

        ui.select.addEventListener('change', (e) => {
            const val = e.target.value;
            if (val.startsWith('user:')) {
                ui.editor.value = userPresets[val.split(':')[1]];
            } else if (presets[val]) {
                ui.editor.value = presets[val];
            }
            runCode(); 
        });

        ui.runBtn.addEventListener('click', runCode);
        ui.editor.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') runCode(); });

        ui.savePresetBtn.addEventListener('click', () => {
            const name = prompt("Name your function:");
            if (name) {
                userPresets[name] = ui.editor.value;
                localStorage.setItem('hex_truchet_presets', JSON.stringify(userPresets));
                updatePresetDropdown();
                ui.select.value = `user:${name}`;
            }
        });

        ui.saveImgBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `hex-truchet-${drawMode}-${Date.now()}.png`;
            link.href = tileCanvas.toDataURL();
            link.click();
        });

        ui.saveSvgBtn.addEventListener('click', exportSVG);

        tileCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e, tileCanvas));
        matrixCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e, matrixCanvas));

        ui.infoBtn.onclick = () => ui.info.style.display = (ui.info.style.display === 'block') ? 'none' : 'block';
        ui.closeInfo.onclick = () => ui.info.style.display = 'none';

        // Animation Controls
        ui.animType.addEventListener('change', (e) => {
            animType = e.target.value;
            animProgress = -0.05;
            animDirection = 1;
            if (animType === 'none') {
                stopAnimation();
                snapToTarget();
                requestDraw();
            } else {
                if(!isAnimating && ui.playBtn.textContent === "‚è∏") startAnimation();
                // Reset rotation to 0 for a fresh animation start
                resetAnglesToZero();
                requestDraw();
            }
        });

        ui.animSpeed.addEventListener('input', (e) => {
            const level = parseInt(e.target.value);
            ui.speedVal.textContent = level;
            currentStepDuration = STEP_DURATION_LEVELS[level - 1];
        });

        ui.playBtn.addEventListener('click', toggleAnimation);
        ui.recBtn.addEventListener('click', toggleRecording);

        updatePresetDropdown();
        runCode();
    }

    function resetAnglesToZero() {
        hexData.forEach((_, key) => {
            currentAngles.set(key, 0);
        });
    }

    function snapToTarget() {
        hexData.forEach((val, key) => {
            currentAngles.set(key, val * (Math.PI / 3)); // 60 degrees
        });
    }

    function runCode() {
        const userCode = ui.editor.value;
        ui.errorMsg.style.display = 'none';
        
        let newHexData = new Map();

        try {
            const genFunc = new Function('q', 'r', 's', 'n', userCode);
            for (let q = -N; q <= N; q++) {
                for (let r = -N; r <= N; r++) {
                    for (let s = -N; s <= N; s++) {
                        if (q + r + s === 0) {
                            let val = 0;
                            const result = genFunc(q, r, s, N);
                            if (typeof result === 'boolean') val = result ? 1 : 0;
                            else if (typeof result === 'number') val = Math.abs(Math.round(result)) % 2;
                            else if (typeof result === 'bigint') val = Number(result % 2n);
                            
                            const key = `${q},${r},${s}`;
                            newHexData.set(key, val);
                            
                            // Initialize angle if new
                            if (!currentAngles.has(key)) currentAngles.set(key, 0);
                        }
                    }
                }
            }
            hexData = newHexData;
            
            // Cleanup unused angles
            for (let k of currentAngles.keys()) {
                if (!hexData.has(k)) currentAngles.delete(k);
            }

            if (animType === 'none' || !isAnimating) {
                snapToTarget();
            } else {
                // If animating, keep angles as is (likely 0 if just started, or partial) 
                resetAnglesToZero();
            }
            resize(); 
        } catch (err) {
            ui.errorMsg.textContent = "Error: " + err.message;
            ui.errorMsg.style.display = 'block';
        }
    }

    function resize() {
        resizeCanvas(tileCanvas, document.getElementById('tile-wrapper'), ctx);
        resizeCanvas(matrixCanvas, document.getElementById('matrix-wrapper'), mCtx);
        requestDraw();
    }

    function resizeCanvas(canvas, wrapper, context) {
        const w = wrapper.clientWidth;
        const h = wrapper.clientHeight;
        
        canvas.width = w * 2;
        canvas.height = h * 2;
        // Reset scale first
        context.setTransform(1,0,0,1,0,0);
        
        // Calculate Size to Fit
        // Grid Width in hexes approx: 2*N + 1
        // Grid Height in hexes approx: (3*N + 2) / 1.732 ??
        // Let's use exact bounds relative to 'size' (radius of circumcircle)
        
        // Width: (2*N + 1) * sqrt(3) * size
        // Height: (3*N + 2) * size
        
        const gridW_units = Math.sqrt(3) * (2 * N + 1);
        const gridH_units = (3 * N + 2);
        
        // Calculate max possible size for width and height constraints
        const sizeW = (canvas.width * 0.96) / gridW_units; // 0.96 for minimal padding (2%)
        const sizeH = (canvas.height * 0.96) / gridH_units;
        
        const size = Math.min(sizeW, sizeH);
        
        // Store size on canvas for click handlers to use
        canvas.hexSize = size; 

        // Update Clip Path
        updateClip(canvas, size, w, h);
    }

    function updateClip(canvas, hexRadius, cssW, cssH) {
        // Center in CSS pixels
        const cx = cssW / 2;
        const cy = cssH / 2;
        // radius in CSS pixels
        const r = hexRadius / 2; // dividing by 2 because hexRadius calculated above is for canvas pixel density 2

        // Define the 6 corners of the grid hull
        const corners = [
            {q: 0,  r: -N, angleDeg: 270}, // Top
            {q: N,  r: -N, angleDeg: 330}, // Top Right
            {q: N,  r: 0,  angleDeg: 30},  // Bottom Right
            {q: 0,  r: N,  angleDeg: 90},  // Bottom
            {q: -N, r: N,  angleDeg: 150}, // Bottom Left
            {q: -N, r: 0,  angleDeg: 210}  // Top Left
        ];

        const points = corners.map(c => {
            // Get center of the corner tile relative to 0,0 center
            // We use the helper logic but adapted for simple math here
            const x = r * (Math.sqrt(3) * c.q + Math.sqrt(3)/2 * c.r);
            const y = r * (3./2 * c.r);

            // Get the outer tip vertex of that tile
            const rad = c.angleDeg * Math.PI / 180;
            const vx = x + r * Math.cos(rad);
            const vy = y + r * Math.sin(rad);
            
            return `${(cx + vx).toFixed(2)}px ${(cy + vy).toFixed(2)}px`;
        });

        canvas.style.clipPath = `polygon(${points.join(', ')})`;
    }

    /* --- ANIMATION LOGIC --- */

    function toggleAnimation() {
        if (isAnimating) stopAnimation(); else startAnimation();
    }

    function startAnimation() {
        if (animType === 'none') return;
        isAnimating = true;
        ui.playBtn.textContent = "‚è∏";
        animDirection = 1;
        animProgress = -0.05; 
        lastTime = performance.now();
        resetAnglesToZero();
        animationLoop();
    }

    function stopAnimation() {
        isAnimating = false;
        ui.playBtn.textContent = "‚ñ∂";
        cancelAnimationFrame(animationFrameId);
    }

    function animationLoop() {
        if (!isAnimating) return;
        
        const now = performance.now();
        const dt = (now - lastTime) / 1000;
        lastTime = now;

        let totalDuration = 1.0;
        
        if (animType === 'cell') {
            const activeCount = Array.from(hexData.values()).filter(v => v === 1).length;
            totalDuration = activeCount * currentStepDuration;
        } else if (animType === 'rings' || animType === 'row') {
            totalDuration = N * 2 * currentStepDuration; 
        } else {
            totalDuration = currentStepDuration;
        }

        const logicSpeed = 1 / Math.max(0.001, totalDuration);
        const PAUSE_SECONDS = 0.5;
        const pauseBuffer = PAUSE_SECONDS * logicSpeed;
        const upperLimit = 1 + pauseBuffer;
        const lowerLimit = -pauseBuffer;

        if (animDirection === -1) animProgress -= dt * logicSpeed;
        else animProgress += dt * logicSpeed;

        if (animProgress >= upperLimit) { 
            animDirection = -1; 
            animProgress = upperLimit; 
        } else if (animProgress <= lowerLimit) { 
            animDirection = 1; 
            animProgress = lowerLimit; 
        }

        updateAngles(dt);
        draw();
        
        if (isRecording) updateRecTimer();
        animationFrameId = requestAnimationFrame(animationLoop);
    }

    function updateAngles(dt) {
        const p = Math.max(0, Math.min(1, animProgress));
        let activeIdx = 0;
        const totalActive = Array.from(hexData.values()).filter(v => v === 1).length;

        hexData.forEach((val, key) => {
            const [q, r, s] = key.split(',').map(Number);
            let localP = 0;

            if (val === 0) {
                currentAngles.set(key, 0);
                return;
            }

            if (animType === 'all') {
                localP = p;
            } else if (animType === 'rings') {
                const ringIdx = (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;
                const seqPos = p * (N + 1);
                localP = Math.max(0, Math.min(1, seqPos - ringIdx));
            } else if (animType === 'row') {
                const rowIdx = r + N; 
                const seqPos = p * (2 * N + 1);
                localP = Math.max(0, Math.min(1, seqPos - rowIdx));
            } else if (animType === 'cell') {
                const currentStep = p * totalActive;
                localP = Math.max(0, Math.min(1, currentStep - activeIdx));
                activeIdx++;
            }

            currentAngles.set(key, localP * (Math.PI / 3));
        });
    }

    /* --- RECORDING --- */
    function toggleRecording() {
        if (isRecording) stopRecording(); else startRecording();
    }

    function startRecording() {
        recordedChunks = [];
        const stream = tileCanvas.captureStream(60); 
        try { mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' }); } 
        catch (e) { mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); }

        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = exportVideo;
        mediaRecorder.start();
        isRecording = true;
        recStartTime = performance.now();
        ui.recBtn.textContent = "‚èπ STOP";
        ui.recInd.style.display = 'flex';
    }

    function stopRecording() {
        if (!mediaRecorder) return;
        mediaRecorder.stop();
        isRecording = false;
        ui.recBtn.textContent = "‚è∫ REC";
        ui.recInd.style.display = 'none';
    }

    function updateRecTimer() {
        if (!isRecording) return;
        const elapsed = Math.floor((performance.now() - recStartTime) / 1000);
        const mm = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const ss = (elapsed % 60).toString().padStart(2, '0');
        ui.recTimer.textContent = `${mm}:${ss}`;
    }

    function exportVideo() {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `hex-truchet-anim-${Date.now()}.webm`;
        document.body.appendChild(a); a.click();
        setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100);
    }

    /* --- SVG EXPORT --- */
    function exportSVG() {
        const theme = themes[currentTheme];
        const size = 50; 
        const pad = size * 2;
        const width = (N * 2 + 1) * Math.sqrt(3) * size + pad;
        const height = (N * 2 + 1) * 1.5 * size + pad; // Rough box
        const minX = -width/2;
        const minY = -height/2;

        // Dynamic Grid Color for Export
        const isDark = theme.bg !== '#ffffff';
        const gridColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.2)';

        let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${width} ${height}" style="background-color:${theme.bg}">`;
        const colMain = theme.line;
        const colBg = theme.bg;
        const gridStroke = 1;

        hexData.forEach((val, key) => {
            const [q, r, s] = key.split(',').map(Number);
            const pos = hexToPixel(q, r, size);
            
            const verts = [];
            for (let i = 0; i < 6; i++) {
                const deg = 30 + 60 * i;
                const rad = deg * Math.PI / 180;
                verts.push({ x: size * Math.cos(rad), y: size * Math.sin(rad) });
            }
            const mids = [];
            for (let i = 0; i < 6; i++) {
                const next = (i + 1) % 6;
                mids.push({ x: (verts[i].x + verts[next].x) / 2, y: (verts[i].y + verts[next].y) / 2 });
            }

            const pairs0 = [[0, 1], [2, 3], [4, 5]];
            const pairs1 = [[1, 2], [3, 4], [5, 0]];
            const activePairs = (val === 1) ? pairs1 : pairs0;

            svg += `<g transform="translate(${pos.x}, ${pos.y})">`;

            if (isFilled) {
                let drawCorners = (val === 0); 
                if (isInvertedFill) drawCorners = !drawCorners;

                if (drawCorners) {
                    activePairs.forEach(pair => {
                        const p1 = mids[pair[0]]; const p2 = mids[pair[1]];
                        const vIdx = (pair[0] + 1) % 6;
                        const v = verts[vIdx];
                        let d = getSvgPath(drawMode, p1, p2, v);
                        d += ` L ${v.x} ${v.y} L ${p1.x} ${p1.y} Z`;
                        svg += `<path d="${d}" fill="${colMain}" />`;
                    });
                } else {
                    let d = `M ${verts[0].x} ${verts[0].y}`;
                    for(let i=1; i<6; i++) d += ` L ${verts[i].x} ${verts[i].y}`;
                    d += ` Z`;
                    svg += `<path d="${d}" fill="${colMain}" />`;
                    
                    activePairs.forEach(pair => {
                        const p1 = mids[pair[0]]; const p2 = mids[pair[1]];
                        const vIdx = (pair[0] + 1) % 6;
                        const v = verts[vIdx];
                        let dC = getSvgPath(drawMode, p1, p2, v);
                        dC += ` L ${v.x} ${v.y} L ${p1.x} ${p1.y} Z`;
                        svg += `<path d="${dC}" fill="${colBg}" />`;
                    });
                }
            } else {
                activePairs.forEach(pair => {
                    const p1 = mids[pair[0]]; const p2 = mids[pair[1]];
                    const vIdx = (pair[0] + 1) % 6;
                    const v = verts[vIdx];
                    const d = getSvgPath(drawMode, p1, p2, v);
                    svg += `<path d="${d}" fill="none" stroke="${colMain}" stroke-width="${lineWidth}" stroke-linecap="round" stroke-linejoin="round" />`;
                });
            }
            
            if (showGrid) {
                let d = `M ${verts[0].x} ${verts[0].y}`;
                for(let i=1; i<6; i++) d += ` L ${verts[i].x} ${verts[i].y}`;
                d += ` Z`;
                svg += `<path d="${d}" fill="none" stroke="${gridColor}" stroke-width="${gridStroke}" />`;
            }

            svg += `</g>`;
        });
        svg += `</svg>`;
        const link = document.createElement("a");
        link.href = URL.createObjectURL(new Blob([svg], {type: "image/svg+xml"}));
        link.download = `hex-truchet-${Date.now()}.svg`; link.click();
    }

    function getSvgPath(mode, p1, p2, v) {
        if (mode === 'straight') {
            return `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        } else if (mode === 'curved') {
            const r = Math.hypot(v.x - p1.x, v.y - p1.y);
            const a1 = Math.atan2(p1.y - v.y, p1.x - v.x);
            const a2 = Math.atan2(p2.y - v.y, p2.x - v.x);
            let diff = a2 - a1;
            while(diff > Math.PI) diff -= 2*Math.PI;
            while(diff < -Math.PI) diff += 2*Math.PI;
            const sweep = diff > 0 ? 1 : 0;
            return `M ${p1.x} ${p1.y} A ${r} ${r} 0 0 ${sweep} ${p2.x} ${p2.y}`;
        } else {
            const px = p1.x + p2.x - v.x;
            const py = p1.y + p2.y - v.y;
            return `M ${p1.x} ${p1.y} L ${px} ${py} L ${p2.x} ${p2.y}`;
        }
    }

    /* --- HELPERS --- */
    function hexToPixel(q, r, size) {
        const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
        const y = size * (3./2 * r);
        return { x, y };
    }

    function pixelToHex(x, y, size) {
        const q = (Math.sqrt(3)/3 * x - 1./3 * y) / size;
        const r = (2./3 * y) / size;
        return hexRound(q, r);
    }

    function hexRound(q, r) {
        let s = -q - r;
        let rq = Math.round(q);
        let rr = Math.round(r);
        let rs = Math.round(s);
        const q_diff = Math.abs(rq - q), r_diff = Math.abs(rr - r), s_diff = Math.abs(rs - s);
        if (q_diff > r_diff && q_diff > s_diff) rq = -rr - rs;
        else if (r_diff > s_diff) rr = -rq - rs;
        else rs = -rq - rr;
        return { q: rq, r: rr, s: rs };
    }

    function hexToRgb(hex) {
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
    }

    /* --- RENDERING --- */
    function requestDraw() { if (!isAnimating) draw(); }

    function draw() {
        // Tile Canvas
        drawGeneric(tileCanvas, ctx, true);
        // Matrix Canvas
        drawGeneric(matrixCanvas, mCtx, false);
    }

    function drawGeneric(canvas, context, isArt) {
        const theme = themes[currentTheme];
        // Note: canvas.width/height are already set to full pixel density
        const w = canvas.width;
        const h = canvas.height;
        const size = canvas.hexSize || 20;

        if (isArt) {
            context.fillStyle = theme.bg;
            context.fillRect(0, 0, w, h);
        } else {
            // Matrix view always dark
            context.fillStyle = '#050505';
            context.fillRect(0, 0, w, h);
        }
        
        context.save();
        // Translate to center of canvas
        context.translate(w/2, h/2); 

        if (!isArt) {
            context.font = `${Math.max(8, size/1.5)}px monospace`;
            context.textAlign = 'center'; context.textBaseline = 'middle';
        }

        hexData.forEach((val, key) => {
            const [q, r, s] = key.split(',').map(Number);
            const pos = hexToPixel(q, r, size);
            
            if (isArt) {
                const angle = currentAngles.get(key) || 0;
                
                // Static Grid
                if (showGrid) {
                    context.save();
                    context.translate(pos.x, pos.y);
                    context.lineWidth = 1;
                    
                    // Improved Grid Visibility
                    const isDark = theme.bg !== '#ffffff';
                    context.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)';
                    
                    context.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const rad = (30 + 60 * i) * Math.PI / 180;
                        const vx = size * Math.cos(rad);
                        const vy = size * Math.sin(rad);
                        if (i === 0) context.moveTo(vx, vy); else context.lineTo(vx, vy);
                    }
                    context.closePath();
                    context.stroke();
                    context.restore();
                }

                // Tile
                context.save();
                context.translate(pos.x, pos.y);
                context.rotate(angle);
                drawTileContent(context, size, angle); 
                context.restore();

            } else {
                // Matrix View
                context.strokeStyle = '#222'; context.lineWidth = 1; context.beginPath();
                for (let i = 0; i < 6; i++) {
                    const r = 30 + 60 * i;
                    const rad = r * Math.PI / 180;
                    context[i===0?'moveTo':'lineTo'](pos.x + size*Math.cos(rad), pos.y + size*Math.sin(rad));
                }
                context.closePath(); context.stroke();

                if (val === 1) { context.fillStyle = 'rgba(0, 210, 255, 0.15)'; context.fill(); }
                context.fillStyle = val === 1 ? '#00d2ff' : '#444';
                context.fillText(val, pos.x, pos.y);
            }
        });
        
        context.restore();
    }

    function tracePath(ctx, drawMode, p1, p2, v) {
        ctx.moveTo(p1.x, p1.y);
        if (drawMode === 'straight') {
            ctx.lineTo(p2.x, p2.y);
        } else if (drawMode === 'curved') {
            const r = Math.hypot(v.x - p1.x, v.y - p1.y);
            const a1 = Math.atan2(p1.y - v.y, p1.x - v.x);
            const a2 = Math.atan2(p2.y - v.y, p2.x - v.x);
            let diff = a2 - a1;
            while (diff > Math.PI) diff -= 2*Math.PI;
            while (diff < -Math.PI) diff += 2*Math.PI;
            ctx.arc(v.x, v.y, r, a1, a2, diff < 0);
        } else {
            const px = p1.x + p2.x - v.x;
            const py = p1.y + p2.y - v.y;
            ctx.lineTo(px, py); ctx.lineTo(p2.x, p2.y);
        }
    }

    function drawTileContent(ctx, size, angle) {
        const theme = themes[currentTheme];
        const verts = [];
        for (let i = 0; i < 6; i++) {
            const rad = (30 + 60 * i) * Math.PI / 180;
            verts.push({ x: size * Math.cos(rad), y: size * Math.sin(rad) });
        }
        const mids = [];
        for (let i = 0; i < 6; i++) {
            const next = (i + 1) % 6;
            mids.push({ x: (verts[i].x + verts[next].x) / 2, y: (verts[i].y + verts[next].y) / 2 });
        }

        const pairs = [[0, 1], [2, 3], [4, 5]];

        if (isFilled) {
            let t = angle / (Math.PI / 3);
            if (t < 0) t = 0; if (t > 1) t = 1;

            const cMain = hexToRgb(theme.line);
            const cBg   = hexToRgb(theme.bg);

            const lerpColor = (c1, c2, factor) => {
                const r = Math.round(c1.r + (c2.r - c1.r) * factor);
                const g = Math.round(c1.g + (c2.g - c1.g) * factor);
                const b = Math.round(c1.b + (c2.b - c1.b) * factor);
                return `rgb(${r},${g},${b})`;
            };

            let cCornerStart = cMain, cCenterStart = cBg;
            let cCornerEnd = cBg, cCenterEnd = cMain;

            if (isInvertedFill) {
                cCornerStart = cBg; cCenterStart = cMain;
                cCornerEnd = cMain; cCenterEnd = cBg;
            }

            const fillCorners = lerpColor(cCornerStart, cCornerEnd, t);
            const fillCenter = lerpColor(cCenterStart, cCenterEnd, t);

            ctx.fillStyle = fillCenter;
            ctx.beginPath();
            ctx.moveTo(verts[0].x, verts[0].y);
            for(let i=1; i<6; i++) ctx.lineTo(verts[i].x, verts[i].y);
            ctx.fill();
            
            ctx.fillStyle = fillCorners;
            pairs.forEach(pair => {
                const p1 = mids[pair[0]]; const p2 = mids[pair[1]];
                const v = verts[(pair[0] + 1) % 6];
                ctx.beginPath();
                tracePath(ctx, drawMode, p1, p2, v);
                ctx.lineTo(v.x, v.y); ctx.lineTo(p1.x, p1.y);
                ctx.fill();
            });

        } else {
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = theme.line;
            ctx.beginPath();
            pairs.forEach(pair => {
                const p1 = mids[pair[0]]; const p2 = mids[pair[1]];
                const v = verts[(pair[0] + 1) % 6];
                tracePath(ctx, drawMode, p1, p2, v);
            });
            ctx.stroke();
        }
    }

    function handleCanvasClick(e, canvas) {
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) - rect.width/2;
        const my = (e.clientY - rect.top) - rect.height/2;
        // Use the size stored on the canvas object which accounts for the pixel density
        // But mx/my are in CSS pixels, so we need CSS size (which is hexSize / 2)
        const size = (canvas.hexSize || 40) / 2;

        const hex = pixelToHex(mx, my, size);
        
        if (Math.abs(hex.q) <= N && Math.abs(hex.r) <= N && Math.abs(hex.s) <= N) {
            const key = `${hex.q},${hex.r},${hex.s}`;
            const current = hexData.has(key) ? hexData.get(key) : 0;
            const newVal = 1 - current;
            hexData.set(key, newVal);
            
            if (!isAnimating) {
                currentAngles.set(key, newVal * (Math.PI / 3)); 
                draw();
            }
        }
    }

    init();
</script>
</body>
</html>