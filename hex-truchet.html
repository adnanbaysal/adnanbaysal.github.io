<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagonal Truchet-Smith Tiling</title>
    <style>
        :root { 
            /* UNIFIED BLUE THEME */
            --accent: #00d2ff; 
            --accent-dim: rgba(0, 210, 255, 0.1);
            --bg: #050505; 
            --panel: #111; 
            --code-bg: #0d0d0d;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; 
            display: flex; flex-direction: column; 
            background: var(--bg); color: #fff; 
            margin: 0; height: 100vh; overflow: hidden; 
        }
        
        /* --- Header --- */
        header { 
            background: var(--panel); padding: 8px 16px; 
            border-bottom: 1px solid #333; 
            display: flex; flex-wrap: wrap; align-items: center; 
            gap: 12px; z-index: 10; height: 50px; flex-shrink: 0;
        }
        
        .control-group { 
            display: flex; flex-direction: column; gap: 2px; 
            min-width: 80px;
        }

        .label-row { 
            display: flex; justify-content: space-between; 
            color: #888; font-size: 10px; font-weight: bold; text-transform: uppercase; 
        }
        
        span.value { color: var(--accent); font-family: monospace; }
        input[type="range"] { width: 90px; accent-color: var(--accent); cursor: pointer; height: 10px; }

        /* UI Controls */
        .ui-row { display: flex; align-items: center; gap: 8px; }

        .check-group { 
            display: flex; align-items: center; gap: 6px; 
            font-size: 11px; font-weight: bold; text-transform: uppercase; 
            color: #ccc; cursor: pointer; border: 1px solid #333; 
            padding: 0 8px; border-radius: 4px; background: #1a1a1a; height: 30px;
        }
        .check-group:hover { border-color: #666; color: #fff; }
        .check-group input { width: 14px; height: 14px; accent-color: var(--accent); cursor: pointer; margin: 0; }

        select.mode-select {
            background: #1a1a1a; color: #fff; border: 1px solid #333;
            font-size: 11px; font-weight: bold; text-transform: uppercase;
            height: 30px; border-radius: 4px; padding: 0 8px; cursor: pointer;
        }
        select.mode-select:hover { border-color: #666; }

        /* --- Main Layout --- */
        main { 
            flex-grow: 1; display: flex; flex-direction: row; 
            padding: 15px; gap: 15px; min-height: 0;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }

        .left-col { display: flex; flex-direction: column; width: 350px; gap: 10px; flex-shrink: 0; }
        .right-col { flex-grow: 1; display: flex; flex-direction: column; border: 1px solid #222; border-radius: 6px; background: #000; position: relative; }

        .panel-header {
            font-size: 11px; letter-spacing: 1px; color: var(--accent);
            text-transform: uppercase; font-weight: bold; opacity: 0.8;
            margin-bottom: 5px; display: flex; justify-content: space-between;
        }

        .canvas-wrapper {
            background: #000; border: 1px solid #222; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #matrix-wrapper { height: 280px; flex-shrink: 0; }
        #tile-wrapper { height: 100%; width: 100%; }

        canvas { cursor: crosshair; image-rendering: auto; }
        canvas:active { cursor: grabbing; }

        /* --- Code Editor --- */
        .editor-container {
            flex-grow: 1; display: flex; flex-direction: column;
            background: var(--panel); border: 1px solid #333; border-radius: 6px;
            padding: 10px; min-height: 0;
        }

        select.preset-select {
            background: #222; color: #fff; border: 1px solid #444; 
            font-family: monospace; font-size: 11px; padding: 4px; 
            border-radius: 3px; width: 100%; cursor: pointer; margin-bottom: 8px;
        }

        textarea {
            flex-grow: 1; background: var(--code-bg); color: #ccc;
            border: 1px solid #333; border-radius: 4px;
            padding: 10px; font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px; line-height: 1.4; resize: none;
            outline: none; white-space: pre; margin-bottom: 8px;
        }
        textarea:focus { border-color: var(--accent); color: #fff; }

        .editor-actions { display: flex; gap: 8px; }

        /* --- Buttons --- */
        button { 
            border: none; padding: 0 12px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; transition: all 0.2s; 
            text-transform: uppercase; font-size: 10px; height: 30px;
            display: flex; align-items: center; justify-content: center; gap: 6px;
            font-family: inherit;
        }
        .btn-run { background: var(--accent); color: #000; flex-grow: 1; }
        .btn-run:hover { filter: brightness(1.2); box-shadow: 0 0 8px var(--accent-dim); }
        .btn-sec { background: #333; color: #ccc; }
        .btn-sec:hover { background: #444; color: #fff; }
        .btn-icon { width: 30px; padding: 0; font-size: 14px; }
        .btn-util { background: #222; color: #888; }
        .btn-util:hover { color: #fff; }
        
        .btn-invert { 
            width: 30px; padding: 0; font-size: 16px; background: #1a1a1a; 
            border: 1px solid #333; color: var(--accent); 
        }
        .btn-invert:hover { background: #333; }

        /* --- Modal --- */
        #info-modal {
            position: absolute; top: 60px; left: 20px; z-index: 20;
            background: rgba(17, 17, 17, 0.96); backdrop-filter: blur(12px);
            border: 1px solid #333; border-radius: 8px;
            width: 350px; padding: 25px; font-size: 13px; line-height: 1.6;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); display: none;
            max-height: 80vh; overflow-y: auto;
        }
        #info-modal h2 { margin-top: 0; color: var(--accent); font-size: 16px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        #info-modal h3 { margin: 15px 0 5px 0; font-size: 12px; color: #fff; text-transform: uppercase; }
        #info-modal p { margin: 0 0 10px 0; color: #aaa; }
        .close-info { position: absolute; top: 15px; right: 15px; cursor: pointer; color: #666; font-size: 18px; }
        code { background: #222; padding: 2px 4px; border-radius: 3px; color: var(--accent); font-family: monospace; }
        .shortcut { background: #333; color: #fff; padding: 1px 5px; border-radius: 3px; font-size: 10px; }

    </style>
</head>
<body>

    <header>
        <button id="info-btn" class="btn-sec btn-icon">?</button>
        
        <div class="control-group">
            <div class="label-row"><span>Radius (N)</span> <span id="n-val" class="value">8</span></div>
            <input type="range" id="param-n" min="1" max="100" step="1" value="8">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Thickness</span> <span id="w-val" class="value">2.5</span></div>
            <input type="range" id="param-w" min="0.5" max="15" step="0.5" value="2.5">
        </div>

        <div class="ui-row">
            <select id="draw-mode" class="mode-select">
                <option value="two-lines">Two Lines</option>
                <option value="straight">Straight</option>
                <option value="curved">Curved</option>
            </select>
            
            <label class="check-group" title="Fill regions">
                <input type="checkbox" id="check-filled"> Filled
            </label>
            
            <button id="invert-fill-btn" class="btn-invert" title="Invert Fill Logic">â‡„</button>
        </div>

        <div style="flex-grow:1"></div>
        <button id="save-img-btn" class="btn-sec">ðŸ“¸ PNG</button>
    </header>

    <main>
        <div class="left-col">
            <div>
                <div class="panel-header">Matrix State</div>
                <div id="matrix-wrapper" class="canvas-wrapper">
                    <canvas id="matrixCanvas"></canvas>
                </div>
            </div>

            <div class="editor-container">
                <div class="panel-header">Generator Function</div>
                
                <select id="preset-select" class="preset-select">
                    <optgroup label="Patterns">
                        <option value="xor">XOR Parity (Hex)</option>
                        <option value="ring">Concentric Rings</option>
                        <option value="sectors">Sectors</option>
                        <option value="flowers">Flowers</option>
                        <option value="spiral">Spiral</option>
                        <option value="propeller">Propellers</option>
                    </optgroup>
                    <optgroup label="Basic">
                        <option value="random">Random Noise</option>
                        <option value="all0">All Zero (Circles 1)</option>
                        <option value="all1">All One (Circles 2)</option>
                    </optgroup>
                    <optgroup label="User Saved" id="user-presets-group">
                    </optgroup>
                </select>

                <textarea id="code-area" spellcheck="false"></textarea>

                <div class="editor-actions">
                    <button id="save-preset-btn" class="btn-sec">ðŸ’¾ Save</button>
                    <button id="run-btn" class="btn-run">â–¶ Run Code</button>
                </div>
                <div id="code-error" style="color: #ff4757; font-size: 10px; margin-top: 5px; display: none;">Error</div>
            </div>
            
            <div style="padding: 10px; background: #111; border: 1px solid #222; border-radius: 6px; font-size: 11px; color: #888;">
                <div class="panel-header">Coordinates</div>
                <p><strong>q, r, s</strong>: Cube coordinates.<br>Constraint: <code>q + r + s = 0</code></p>
                <p>Click on the grid to toggle a specific tile.</p>
            </div>
        </div>

        <div class="right-col">
            <div style="position: absolute; top: 10px; left: 10px; z-index: 5;" class="panel-header">Hexagonal Truchet</div>
            <div id="tile-wrapper" class="canvas-wrapper">
                <canvas id="tileCanvas"></canvas>
            </div>
        </div>

        <div id="info-modal">
            <span class="close-info" id="close-info">&times;</span>
            <h2>Hexagonal Truchet</h2>
            
            <h3>How It Works</h3>
            <p>This tool generates a tiling on a hexagonal grid using Smith tiles (two orientations of 3 paths per hexagon).</p>
            
            <h3>Modes</h3>
            <ul style="padding-left: 20px; margin: 5px 0;">
                <li><strong>Straight:</strong> Linear connections.</li>
                <li><strong>Curved:</strong> Perfect circular arcs centered at vertices.</li>
                <li><strong>Two Lines:</strong> Angled segments creating parallelograms.</li>
            </ul>

            <h3>Functions</h3>
            <p>Write JavaScript to return <code>0</code> or <code>1</code> for each tile.</p>
            <p><strong>Variables:</strong> <code>q</code>, <code>r</code>, <code>s</code> (coords), <code>n</code> (radius).</p>
            <p><strong>Example:</strong> <code>return (Math.abs(q) % 2);</code></p>
        </div>
    </main>

<script>
    /**
     * STATE & CONFIG
     */
    let N = 8;
    let lineWidth = 2.0;
    let isFilled = false;
    let isInvertedFill = false;
    let drawMode = 'two-lines'; // 'two-lines', 'straight', 'curved'
    
    // UNIFIED COLOR THEME
    const THEME_COLOR = '#00d2ff'; // Cyan Blue
    
    let hexData = new Map(); 

    // DOM Elements
    const tileCanvas = document.getElementById('tileCanvas');
    const matrixCanvas = document.getElementById('matrixCanvas');
    const ctx = tileCanvas.getContext('2d');
    const mCtx = matrixCanvas.getContext('2d');
    
    const ui = {
        n: document.getElementById('param-n'), nVal: document.getElementById('n-val'),
        w: document.getElementById('param-w'), wVal: document.getElementById('w-val'),
        filled: document.getElementById('check-filled'),
        mode: document.getElementById('draw-mode'),
        invertFill: document.getElementById('invert-fill-btn'),
        editor: document.getElementById('code-area'),
        select: document.getElementById('preset-select'),
        userGroup: document.getElementById('user-presets-group'),
        runBtn: document.getElementById('run-btn'),
        savePresetBtn: document.getElementById('save-preset-btn'),
        saveImgBtn: document.getElementById('save-img-btn'),
        errorMsg: document.getElementById('code-error'),
        info: document.getElementById('info-modal'),
        infoBtn: document.getElementById('info-btn'),
        closeInfo: document.getElementById('close-info')
    };

    /**
     * PRESETS
     */
    const presets = {
        xor: `// Helper: Positive parity, inverted if negative
const p = (k) => ((Math.abs(k).toString(2).match(/1/g) || []).length % 2) ^ (k < 0 ? 1 : 0);
return p(q) ^ p(r) ^ p(s);`,
        ring: `let dist = (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;
return Math.floor(dist) % 2;`,
        sectors: `// Based on angle
let angle = Math.atan2(Math.sqrt(3) * (r + s/2), 3/2 * s);
return Math.floor(3 * angle / Math.PI) % 2 ? 1 : 0;`,
        flowers: `return (Math.abs(q)%3 === 0 && Math.abs(r)%3 === 0) ? 1 : 0;`,
        spiral: `let dist = (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;
let angle = Math.atan2(Math.sqrt(3) * (q + r/2), 3/2 * r);
return (Math.floor(dist) + Math.floor(3 * angle)) % 2 ? 1 : 0;`,
        propeller: `return (q * r * s) % 2 === 0 ? 0 : 1;`,
        random: `return Math.random() > 0.5 ? 1 : 0;`,
        all0: `return 0;`,
        all1: `return 1;`
    };

    let userPresets = JSON.parse(localStorage.getItem('hex_truchet_presets') || '{}');

    function updatePresetDropdown() {
        ui.userGroup.innerHTML = '';
        Object.keys(userPresets).forEach(name => {
            const opt = document.createElement('option');
            opt.value = `user:${name}`;
            opt.textContent = name;
            ui.userGroup.appendChild(opt);
        });
    }

    function init() {
        ui.editor.value = presets.xor;

        // Listeners
        window.addEventListener('resize', resize);
        
        ui.n.addEventListener('input', (e) => { N = parseInt(e.target.value); ui.nVal.textContent = N; runCode(); });
        ui.w.addEventListener('input', (e) => { lineWidth = parseFloat(e.target.value); ui.wVal.textContent = lineWidth.toFixed(1); draw(); });
        
        ui.filled.addEventListener('change', (e) => { isFilled = e.target.checked; draw(); });
        ui.mode.addEventListener('change', (e) => { drawMode = e.target.value; draw(); });
        ui.invertFill.addEventListener('click', () => { isInvertedFill = !isInvertedFill; draw(); });

        ui.select.addEventListener('change', (e) => {
            const val = e.target.value;
            if (val.startsWith('user:')) {
                ui.editor.value = userPresets[val.split(':')[1]];
            } else if (presets[val]) {
                ui.editor.value = presets[val];
            }
            runCode(); 
        });

        ui.runBtn.addEventListener('click', runCode);
        ui.editor.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') runCode(); });

        ui.savePresetBtn.addEventListener('click', () => {
            const name = prompt("Name your function:");
            if (name) {
                userPresets[name] = ui.editor.value;
                localStorage.setItem('hex_truchet_presets', JSON.stringify(userPresets));
                updatePresetDropdown();
                ui.select.value = `user:${name}`;
            }
        });

        ui.saveImgBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `hex-truchet-${drawMode}-${Date.now()}.png`;
            link.href = tileCanvas.toDataURL();
            link.click();
        });

        tileCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e, tileCanvas));
        matrixCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e, matrixCanvas));

        ui.infoBtn.onclick = () => ui.info.style.display = (ui.info.style.display === 'block') ? 'none' : 'block';
        ui.closeInfo.onclick = () => ui.info.style.display = 'none';

        updatePresetDropdown();
        runCode();
    }

    function runCode() {
        const userCode = ui.editor.value;
        ui.errorMsg.style.display = 'none';
        hexData.clear();

        try {
            const genFunc = new Function('q', 'r', 's', 'n', userCode);
            for (let q = -N; q <= N; q++) {
                for (let r = -N; r <= N; r++) {
                    for (let s = -N; s <= N; s++) {
                        if (q + r + s === 0) {
                            let val = 0;
                            const result = genFunc(q, r, s, N);
                            if (typeof result === 'boolean') val = result ? 1 : 0;
                            else if (typeof result === 'number') val = Math.abs(Math.round(result)) % 2;
                            hexData.set(`${q},${r},${s}`, val);
                        }
                    }
                }
            }
            resize(); 
        } catch (err) {
            ui.errorMsg.textContent = "Error: " + err.message;
            ui.errorMsg.style.display = 'block';
        }
    }

    function resize() {
        // Resize Tile Canvas
        const tWrap = document.getElementById('tile-wrapper');
        const tSize = Math.min(tWrap.clientWidth, tWrap.clientHeight);
        tileCanvas.width = tSize * 2; tileCanvas.height = tSize * 2;
        tileCanvas.style.width = `${tSize}px`; tileCanvas.style.height = `${tSize}px`;
        ctx.setTransform(2,0,0,2,0,0);

        // Resize Matrix Canvas
        const mWrap = document.getElementById('matrix-wrapper');
        const mSize = Math.min(mWrap.clientWidth, mWrap.clientHeight) - 10;
        matrixCanvas.width = mSize * 2; matrixCanvas.height = mSize * 2;
        matrixCanvas.style.width = `${mSize}px`; matrixCanvas.style.height = `${mSize}px`;
        mCtx.setTransform(2,0,0,2,0,0);

        draw();
    }

    /* * HEXAGON MATH & UTILS
     */
    function hexToPixel(q, r, size) {
        const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
        const y = size * (3./2 * r);
        return { x, y };
    }

    function pixelToHex(x, y, size) {
        const q = (Math.sqrt(3)/3 * x - 1./3 * y) / size;
        const r = (2./3 * y) / size;
        return hexRound(q, r);
    }

    function hexRound(q, r) {
        let s = -q - r;
        let rq = Math.round(q);
        let rr = Math.round(r);
        let rs = Math.round(s);

        const q_diff = Math.abs(rq - q);
        const r_diff = Math.abs(rr - r);
        const s_diff = Math.abs(rs - s);

        if (q_diff > r_diff && q_diff > s_diff) rq = -rr - rs;
        else if (r_diff > s_diff) rr = -rq - rs;
        else rs = -rq - rr;

        return { q: rq, r: rr, s: rs };
    }

    /* * DRAWING 
     */
    function draw() {
        drawTiles();
        drawMatrix();
    }

    function drawTiles() {
        const w = tileCanvas.width / 2;
        const h = tileCanvas.height / 2;
        const size = (Math.min(w, h) / (N * 2 + 1)) * 0.9;

        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
        ctx.save();
        ctx.translate(w/2, h/2);

        hexData.forEach((val, key) => {
            const [q, r, s] = key.split(',').map(Number);
            const pos = hexToPixel(q, r, size);
            drawTile(pos.x, pos.y, size, val);
        });
        
        ctx.restore();
    }

    function drawMatrix() {
        const w = matrixCanvas.width / 2;
        const h = matrixCanvas.height / 2;
        const size = (Math.min(w, h) / (N * 2 + 1)) * 0.9;

        mCtx.fillStyle = '#050505'; mCtx.fillRect(0, 0, w, h);
        mCtx.save();
        mCtx.translate(w/2, h/2);
        
        mCtx.font = `${Math.max(8, size/1.5)}px monospace`;
        mCtx.textAlign = 'center';
        mCtx.textBaseline = 'middle';

        hexData.forEach((val, key) => {
            const [q, r, s] = key.split(',').map(Number);
            const pos = hexToPixel(q, r, size);
            
            // Draw Hexagon Outline
            mCtx.strokeStyle = '#222';
            mCtx.lineWidth = 1;
            mCtx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle_deg = 60 * i + 30;
                const angle_rad = Math.PI / 180 * angle_deg;
                const px = pos.x + size * Math.cos(angle_rad);
                const py = pos.y + size * Math.sin(angle_rad);
                if (i === 0) mCtx.moveTo(px, py);
                else mCtx.lineTo(px, py);
            }
            mCtx.closePath();
            mCtx.stroke();

            // Background for active cell
            if (val === 1) {
                mCtx.fillStyle = 'rgba(0, 210, 255, 0.15)';
                mCtx.fill();
            }

            // Draw Number
            mCtx.fillStyle = val === 1 ? THEME_COLOR : '#444';
            mCtx.fillText(val, pos.x, pos.y);
        });

        mCtx.restore();
    }

    // Helper to draw the path segment
    function tracePath(ctx, drawMode, p1, p2, v) {
        ctx.moveTo(p1.x, p1.y);
        
        if (drawMode === 'straight') {
            ctx.lineTo(p2.x, p2.y);
        } 
        else if (drawMode === 'curved') {
            // Strict Geometry: Center at Vertex V, Radius = dist(V, P1)
            const r = Math.hypot(v.x - p1.x, v.y - p1.y);
            const startAngle = Math.atan2(p1.y - v.y, p1.x - v.x);
            const endAngle = Math.atan2(p2.y - v.y, p2.x - v.x);
            
            // Determine arc direction (shortest path, roughly 120deg)
            let diff = endAngle - startAngle;
            // Normalize to -PI to PI
            while (diff > Math.PI) diff -= 2*Math.PI;
            while (diff < -Math.PI) diff += 2*Math.PI;
            
            const anticlockwise = diff < 0;
            ctx.arc(v.x, v.y, r, startAngle, endAngle, anticlockwise);
        } 
        else if (drawMode === 'two-lines') {
            // Parallelogram: P = M1 + M2 - V
            const px = p1.x + p2.x - v.x;
            const py = p1.y + p2.y - v.y;
            ctx.lineTo(px, py);
            ctx.lineTo(p2.x, p2.y);
        }
    }

    function drawTile(cx, cy, size, val) {
        // Hex Vertices (Pointy top)
        const verts = [];
        for (let i = 0; i < 6; i++) {
            const deg = 30 + 60 * i;
            const rad = deg * Math.PI / 180;
            verts.push({
                x: cx + size * Math.cos(rad),
                y: cy + size * Math.sin(rad)
            });
        }

        // Edge Midpoints
        const mids = [];
        for (let i = 0; i < 6; i++) {
            const next = (i + 1) % 6;
            mids.push({
                x: (verts[i].x + verts[next].x) / 2,
                y: (verts[i].y + verts[next].y) / 2
            });
        }

        // Connections
        const shift = val === 0 ? 0 : 1;
        const pairs = [
            [0 + shift, 1 + shift],
            [2 + shift, 3 + shift],
            [4 + shift, 5 + shift]
        ].map(p => p.map(idx => idx % 6));

        if (isFilled) {
            drawFilledTile(cx, cy, size, verts, mids, pairs, val);
        } else {
            drawStrokedTile(cx, cy, size, verts, mids, pairs, val);
        }
    }

    function drawStrokedTile(cx, cy, size, verts, mids, pairs, val) {
        ctx.lineWidth = lineWidth;
        ctx.lineCap = drawMode === 'straight' ? 'round' : 'butt';
        // Single Color
        ctx.strokeStyle = THEME_COLOR;

        ctx.beginPath();
        pairs.forEach(pair => {
            const p1 = mids[pair[0]];
            const p2 = mids[pair[1]];
            const sharedVertIdx = (pair[0] + 1) % 6; 
            const v = verts[sharedVertIdx];

            tracePath(ctx, drawMode, p1, p2, v);
        });
        ctx.stroke();
    }

    function drawFilledTile(cx, cy, size, verts, mids, pairs, val) {
        // REGRESSION FIX:
        // We must swap the coloring regions (Center vs Corners) based on 'val'
        // to maintain topological continuity (the ribbon effect).
        
        const cPrimary = THEME_COLOR;
        const cSecondary = 'transparent'; // Background matches canvas
        
        let cornerColor, centerColor;

        // 1. Determine base assignment based on val
        // If val == 0: Corners are Primary, Center is Secondary (creates Ribbon A)
        // If val == 1: Center is Primary, Corners are Secondary (creates Ribbon B)
        if (val === 0) {
            cornerColor = cPrimary;
            centerColor = cSecondary;
        } else {
            cornerColor = cSecondary;
            centerColor = cPrimary;
        }

        // 2. Apply Inversion
        if (isInvertedFill) {
            const temp = cornerColor;
            cornerColor = centerColor;
            centerColor = temp;
        }

        // 3. Fill Center (Background)
        if (centerColor !== 'transparent') {
            ctx.fillStyle = centerColor;
            ctx.beginPath();
            ctx.moveTo(verts[0].x, verts[0].y);
            for(let i=1; i<6; i++) ctx.lineTo(verts[i].x, verts[i].y);
            ctx.closePath();
            ctx.fill();
        }

        // 4. Fill Corners
        // If Corners are 'transparent', we need to ERASE the center color to reveal the canvas black.
        // If Corners are Color, we simply draw them.
        
        if (cornerColor !== 'transparent') {
            // Draw Color on top
            ctx.fillStyle = cornerColor;
            pairs.forEach(pair => {
                const p1 = mids[pair[0]];
                const p2 = mids[pair[1]];
                const sharedVertIdx = (pair[0] + 1) % 6; 
                const v = verts[sharedVertIdx];
                ctx.beginPath();
                tracePath(ctx, drawMode, p1, p2, v);
                ctx.lineTo(v.x, v.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.fill();
            });
        } else if (centerColor !== 'transparent') {
            // Erase corners (draw black)
            ctx.fillStyle = '#000'; // Match BG
            pairs.forEach(pair => {
                const p1 = mids[pair[0]];
                const p2 = mids[pair[1]];
                const sharedVertIdx = (pair[0] + 1) % 6; 
                const v = verts[sharedVertIdx];
                ctx.beginPath();
                tracePath(ctx, drawMode, p1, p2, v);
                ctx.lineTo(v.x, v.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.fill();
            });
        }
    }

    function handleCanvasClick(e, canvas) {
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) - rect.width/2;
        const my = (e.clientY - rect.top) - rect.height/2;
        const w = canvas.width / 2;
        const h = canvas.height / 2;
        const size = (Math.min(w, h) / (N * 2 + 1)) * 0.9;

        const hex = pixelToHex(mx, my, size);
        
        if (Math.abs(hex.q) <= N && Math.abs(hex.r) <= N && Math.abs(hex.s) <= N) {
            const key = `${hex.q},${hex.r},${hex.s}`;
            const current = hexData.has(key) ? hexData.get(key) : 0;
            hexData.set(key, 1 - current);
            
            // Redraw everything so both matrix and tiles update
            draw(); 
        }
    }

    init();
</script>
</body>
</html>