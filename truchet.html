<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truchet-Smith Line Tiling</title>
    <style>
        :root { --accent: #00d2ff; --bg: #050505; --panel: #111; --text-dim: #555; }
        body { 
            font-family: -apple-system, system-ui, "Segoe UI", Roboto, Helvetica, sans-serif; 
            display: flex; flex-direction: column; 
            background: var(--bg); color: #fff; 
            margin: 0; height: 100vh; overflow: hidden; 
        }
        
        /* --- Header UI --- */
        header { 
            background: var(--panel); padding: 8px; 
            border-bottom: 1px solid #333; 
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center;
            gap: 12px; z-index: 10;
        }
        
        .control-group { 
            background: #1a1a1a; padding: 6px 10px; border-radius: 6px; 
            display: flex; flex-direction: column; gap: 4px; border: 1px solid #222;
            min-width: 90px;
        }

        .label-row { 
            display: flex; justify-content: space-between; 
            color: #888; font-size: 9px; font-weight: bold; text-transform: uppercase; 
        }

        /* --- Main Layout --- */
        main { 
            flex-grow: 1; display: flex; flex-direction: row; 
            align-items: center; justify-content: center;
            position: relative; padding: 20px; gap: 20px; min-height: 0;
            background: radial-gradient(circle at center, #0a0a0a 0%, #000 100%);
        }

        .view-container {
            position: relative;
            display: flex; flex-direction: column; align-items: center;
            height: 100%; width: 45%; max-width: 80vh;
        }

        .view-label {
            margin-bottom: 10px; font-size: 11px; letter-spacing: 1px; color: var(--accent);
            text-transform: uppercase; font-weight: bold; opacity: 0.8;
        }

        canvas { 
            background: #000; border-radius: 4px; cursor: pointer;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            border: 1px solid #222;
            width: 100%; aspect-ratio: 1/1; object-fit: contain;
            transition: border-color 0.2s;
        }
        canvas:hover { border-color: #444; }

        /* --- UI Elements --- */
        button { 
            border: none; padding: 0 16px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; transition: all 0.2s; 
            text-transform: uppercase; font-size: 11px; height: 38px;
            display: flex; align-items: center; justify-content: center; gap: 6px;
        }
        .btn-action { background: var(--accent); color: #000; box-shadow: 0 0 10px rgba(0, 210, 255, 0.2); }
        .btn-action:hover { background: #fff; box-shadow: 0 0 15px rgba(255, 255, 255, 0.4); }
        .btn-util { background: #333; color: #ccc; }
        .btn-util:hover { background: #444; color: #fff; }
        .btn-danger { background: #d63031; color: #fff; }
        
        span.value { color: var(--accent); font-size: 11px; font-family: monospace; }
        input[type="range"] { width: 100px; accent-color: var(--accent); cursor: pointer; }
        
        /* Modal */
        #info-modal {
            position: absolute; top: 60px; left: 20px; z-index: 20;
            background: rgba(17, 17, 17, 0.96); backdrop-filter: blur(12px);
            border: 1px solid #333; border-radius: 8px;
            width: 300px; padding: 20px; font-size: 13px; line-height: 1.6;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); display: none;
        }
        #info-modal h2 { margin-top: 0; color: var(--accent); font-size: 16px; text-transform: uppercase; }
        .close-info { position: absolute; top: 10px; right: 10px; cursor: pointer; color: #666; font-size: 20px; }

        @media (max-width: 800px) {
            main { flex-direction: column; overflow-y: auto; }
            .view-container { width: 80%; height: auto; margin-bottom: 20px; }
        }
    </style>
</head>
<body>

    <header>
        <button id="info-btn" class="btn-util" style="width:38px; padding:0;">?</button>
        
        <div class="control-group">
            <div class="label-row"><span>Grid Size (N)</span> <span id="n-val" class="value">8</span></div>
            <input type="range" id="param-n" min="2" max="32" step="1" value="8">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Line Width</span> <span id="w-val" class="value">2.0</span></div>
            <input type="range" id="param-w" min="1" max="10" step="0.5" value="2.5">
        </div>

        <button id="rand-btn" class="btn-action">ðŸŽ² Randomize</button>
        <button id="reset-btn" class="btn-danger">Reset (0)</button>
        <button id="save-btn" class="btn-util">ðŸ“¸ Save Img</button>
    </header>

    <main>
        <div id="info-modal">
            <span class="close-info" id="close-info">&times;</span>
            <h2>Truchet-Smith Tiling</h2>
            <p><strong>The Concept:</strong> A variation of Truchet tiles where arcs are replaced by straight lines connecting the midpoints of the square's edges.</p>
            <p><strong>Tile 0:</strong> Connects Leftâ†’Top and Bottomâ†’Right.</p>
            <p><strong>Tile 1:</strong> Connects Bottomâ†’Left and Topâ†’Right.</p>
            <p><strong>Interaction:</strong> Click on either the 0/1 Matrix (left) or the Tiling (right) to flip a tile's orientation.</p>
        </div>

        <div class="view-container">
            <div class="view-label">State Matrix</div>
            <canvas id="matrixCanvas"></canvas>
        </div>

        <div class="view-container">
            <div class="view-label">Geometric Tiling</div>
            <canvas id="tileCanvas"></canvas>
        </div>
    </main>

<script>
    /**
     * STATE & CONFIG
     */
    let N = 8;
    let lineWidth = 2.5;
    let grid = []; // 2D array storing 0 or 1
    
    // UI References
    const matrixCanvas = document.getElementById('matrixCanvas');
    const tileCanvas = document.getElementById('tileCanvas');
    const mCtx = matrixCanvas.getContext('2d');
    const tCtx = tileCanvas.getContext('2d');
    
    const ui = {
        n: document.getElementById('param-n'),
        nVal: document.getElementById('n-val'),
        w: document.getElementById('param-w'),
        wVal: document.getElementById('w-val'),
        rand: document.getElementById('rand-btn'),
        reset: document.getElementById('reset-btn'),
        save: document.getElementById('save-btn'),
        info: document.getElementById('info-modal'),
        infoBtn: document.getElementById('info-btn'),
        closeInfo: document.getElementById('close-info')
    };

    /**
     * INITIALIZATION
     */
    function initGrid() {
        grid = [];
        for (let y = 0; y < N; y++) {
            let row = [];
            for (let x = 0; x < N; x++) {
                row.push(0);
            }
            grid.push(row);
        }
    }

    function resize() {
        // Resize Matrix Canvas
        const mRect = matrixCanvas.parentElement.getBoundingClientRect();
        const size = Math.min(mRect.width, mRect.height - 30); // account for label
        matrixCanvas.width = size * 2; // Retinal scaling
        matrixCanvas.height = size * 2;
        mCtx.scale(2, 2);

        // Resize Tile Canvas
        const tRect = tileCanvas.parentElement.getBoundingClientRect();
        const tSize = Math.min(tRect.width, tRect.height - 30);
        tileCanvas.width = tSize * 2;
        tileCanvas.height = tSize * 2;
        tCtx.scale(2, 2);

        draw();
    }

    /**
     * DRAWING LOGIC
     */
    function draw() {
        drawMatrix();
        drawTiling();
    }

    function drawMatrix() {
        const w = matrixCanvas.width / 2;
        const h = matrixCanvas.height / 2;
        const cellSize = w / N;

        // Background
        mCtx.fillStyle = '#080808';
        mCtx.fillRect(0, 0, w, h);

        mCtx.font = `bold ${cellSize * 0.5}px monospace`;
        mCtx.textAlign = 'center';
        mCtx.textBaseline = 'middle';

        for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
                const val = grid[y][x];
                const px = x * cellSize;
                const py = y * cellSize;

                // Highlight background slightly for 1s
                if (val === 1) {
                    mCtx.fillStyle = '#111';
                    mCtx.fillRect(px, py, cellSize, cellSize);
                }

                // Text color
                if (val === 0) mCtx.fillStyle = '#333';
                else mCtx.fillStyle = '#00d2ff';

                mCtx.fillText(val, px + cellSize/2, py + cellSize/2);

                // Grid lines
                mCtx.strokeStyle = '#222';
                mCtx.lineWidth = 1;
                mCtx.strokeRect(px, py, cellSize, cellSize);
            }
        }
    }

    function drawTiling() {
        const w = tileCanvas.width / 2;
        const h = tileCanvas.height / 2;
        const cellSize = w / N;

        // Background
        tCtx.fillStyle = '#000';
        tCtx.fillRect(0, 0, w, h);

        // Setup Glow
        tCtx.shadowBlur = 8;
        tCtx.shadowColor = 'rgba(0, 210, 255, 0.6)';
        tCtx.lineCap = 'round';
        tCtx.lineWidth = lineWidth;

        for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
                const val = grid[y][x];
                const px = x * cellSize;
                const py = y * cellSize;
                const mid = cellSize / 2;

                tCtx.strokeStyle = val === 1 ? '#00d2ff' : '#007799'; 
                // Subtle color difference for visual variety, or keep uniform. 
                // Let's keep uniform neon for clean look, or vary slightly by tile type.
                if(val === 0) {
                    tCtx.strokeStyle = '#0088aa'; // Dimmer teal for 0
                    tCtx.shadowColor = 'rgba(0, 136, 170, 0.4)';
                } else {
                    tCtx.strokeStyle = '#00d2ff'; // Bright cyan for 1
                    tCtx.shadowColor = 'rgba(0, 210, 255, 0.6)';
                }

                tCtx.beginPath();

                // Points relative to cell:
                // Top-Mid: (mid, 0)
                // Right-Mid: (cellSize, mid)
                // Bottom-Mid: (mid, cellSize)
                // Left-Mid: (0, mid)

                if (val === 0) {
                    // Tile 0: Left->Top and Bottom->Right
                    // Line 1: (0, mid) to (mid, 0)
                    tCtx.moveTo(px, py + mid);
                    tCtx.lineTo(px + mid, py);
                    
                    // Line 2: (mid, cellSize) to (cellSize, mid)
                    tCtx.moveTo(px + mid, py + cellSize);
                    tCtx.lineTo(px + cellSize, py + mid);
                } else {
                    // Tile 1: Bottom->Left and Top->Right
                    // Line 1: (mid, cellSize) to (0, mid)
                    tCtx.moveTo(px + mid, py + cellSize);
                    tCtx.lineTo(px, py + mid);

                    // Line 2: (mid, 0) to (cellSize, mid)
                    tCtx.moveTo(px + mid, py);
                    tCtx.lineTo(px + cellSize, py + mid);
                }

                tCtx.stroke();
            }
        }
        
        // Reset shadow for grid lines (if we wanted to draw them, but clean look is better)
        tCtx.shadowBlur = 0;
    }

    /**
     * INTERACTION
     */
    function handleInput(e, canvasRef) {
        const rect = canvasRef.getBoundingClientRect();
        // Calculate click position relative to canvas display size
        const scaleX = canvasRef.width / 2 / rect.width;
        const scaleY = canvasRef.height / 2 / rect.height;
        
        const x = (e.clientX - rect.left) * scaleX; // Logic coord
        const y = (e.clientY - rect.top) * scaleY;
        
        const cellW = (canvasRef.width / 2) / N;
        const cellH = (canvasRef.height / 2) / N;

        const col = Math.floor(x / cellW);
        const row = Math.floor(y / cellH);

        if (col >= 0 && col < N && row >= 0 && row < N) {
            grid[row][col] = grid[row][col] === 0 ? 1 : 0;
            draw();
        }
    }

    // Canvas Listeners
    matrixCanvas.addEventListener('mousedown', (e) => handleInput(e, matrixCanvas));
    tileCanvas.addEventListener('mousedown', (e) => handleInput(e, tileCanvas));

    // UI Listeners
    ui.n.addEventListener('input', (e) => {
        N = parseInt(e.target.value);
        ui.nVal.textContent = N;
        initGrid();
        resize(); // Recalculate cell sizes
    });

    ui.w.addEventListener('input', (e) => {
        lineWidth = parseFloat(e.target.value);
        ui.wVal.textContent = lineWidth.toFixed(1);
        draw();
    });

    ui.rand.addEventListener('click', () => {
        for(let y=0; y<N; y++) {
            for(let x=0; x<N; x++) {
                grid[y][x] = Math.random() > 0.5 ? 1 : 0;
            }
        }
        draw();
    });

    ui.reset.addEventListener('click', () => {
        for(let y=0; y<N; y++) {
            for(let x=0; x<N; x++) {
                grid[y][x] = 0;
            }
        }
        draw();
    });

    ui.save.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `truchet-smith-${N}x${N}-${Date.now()}.png`;
        link.href = tileCanvas.toDataURL();
        link.click();
    });

    ui.infoBtn.onclick = () => ui.info.style.display = (ui.info.style.display === 'block') ? 'none' : 'block';
    ui.closeInfo.onclick = () => ui.info.style.display = 'none';

    // Window Resize
    window.addEventListener('resize', resize);

    // Boot
    initGrid();
    // Small timeout to ensure DOM layout is settled before first draw
    setTimeout(resize, 50);

</script>
</body>
</html>