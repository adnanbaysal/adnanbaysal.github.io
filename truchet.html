<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programmable Truchet-Smith Tiling</title>
    <style>
        :root { 
            --accent: #00d2ff; 
            --accent-dim: rgba(0, 210, 255, 0.1);
            --bg: #050505; 
            --panel: #111; 
            --code-bg: #0d0d0d;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; 
            display: flex; flex-direction: column; 
            background: var(--bg); color: #fff; 
            margin: 0; height: 100vh; overflow: hidden; 
        }
        
        /* --- Header --- */
        header { 
            background: var(--panel); padding: 8px 16px; 
            border-bottom: 1px solid #333; 
            display: flex; flex-wrap: wrap; align-items: center; justify-content: center;
            gap: 12px; z-index: 10; height: 50px; flex-shrink: 0;
        }
        
        .control-group { 
            display: flex; flex-direction: column; gap: 2px; 
            min-width: 80px;
        }

        .label-row { 
            display: flex; justify-content: space-between; 
            color: #888; font-size: 10px; font-weight: bold; text-transform: uppercase; 
        }
        
        span.value { color: var(--accent); font-family: monospace; }
        input[type="range"] { width: 90px; accent-color: var(--accent); cursor: pointer; height: 10px; }

        /* UI Controls */
        .ui-row { display: flex; align-items: center; gap: 8px; }

        .check-group { 
            display: flex; align-items: center; gap: 6px; 
            font-size: 11px; font-weight: bold; text-transform: uppercase; 
            color: #ccc; cursor: pointer; border: 1px solid #333; 
            padding: 0 8px; border-radius: 4px; background: #1a1a1a; height: 30px;
        }
        .check-group:hover { border-color: #666; color: #fff; }
        .check-group input { width: 14px; height: 14px; accent-color: var(--accent); cursor: pointer; margin: 0; }

        select.mode-select {
            background: #1a1a1a; color: #fff; border: 1px solid #333;
            font-size: 11px; font-weight: bold; text-transform: uppercase;
            height: 30px; border-radius: 4px; padding: 0 8px; cursor: pointer;
        }
        select.mode-select:hover { border-color: #666; }

        /* --- Main Layout --- */
        main { 
            flex-grow: 1; display: flex; flex-direction: row; 
            padding: 15px; gap: 15px; min-height: 0;
            background: radial-gradient(circle at center, #0a0a0a 0%, #000 100%);
        }

        .left-col { display: flex; flex-direction: column; width: 350px; gap: 10px; flex-shrink: 0; }
        .right-col { flex-grow: 1; display: flex; flex-direction: column; border: 1px solid #222; border-radius: 6px; background: #000; position: relative; }

        .panel-header {
            font-size: 11px; letter-spacing: 1px; color: var(--accent);
            text-transform: uppercase; font-weight: bold; opacity: 0.8;
            margin-bottom: 5px; display: flex; justify-content: space-between;
        }

        .canvas-wrapper {
            background: #000; border: 1px solid #222; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #matrix-wrapper { height: 280px; flex-shrink: 0; }
        #tile-wrapper { height: 100%; width: 100%; }

        canvas { cursor: crosshair; image-rendering: auto; }

        /* --- Code Editor --- */
        .editor-container {
            flex-grow: 1; display: flex; flex-direction: column;
            background: var(--panel); border: 1px solid #333; border-radius: 6px;
            padding: 10px; min-height: 0;
        }

        select.preset-select {
            background: #222; color: #fff; border: 1px solid #444; 
            font-family: monospace; font-size: 11px; padding: 4px; 
            border-radius: 3px; width: 100%; cursor: pointer; margin-bottom: 8px;
        }

        textarea {
            flex-grow: 1; background: var(--code-bg); color: #ccc;
            border: 1px solid #333; border-radius: 4px;
            padding: 10px; font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px; line-height: 1.4; resize: none;
            outline: none; white-space: pre; margin-bottom: 8px;
        }
        textarea:focus { border-color: var(--accent); color: #fff; }

        .editor-actions { display: flex; gap: 8px; }

        /* --- Buttons --- */
        button { 
            border: none; padding: 0 12px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; transition: all 0.2s; 
            text-transform: uppercase; font-size: 10px; height: 30px;
            display: flex; align-items: center; justify-content: center; gap: 6px;
            font-family: inherit;
        }
        .btn-run { background: var(--accent); color: #000; flex-grow: 1; }
        .btn-run:hover { filter: brightness(1.2); box-shadow: 0 0 8px var(--accent-dim); }
        .btn-sec { background: #333; color: #ccc; }
        .btn-sec:hover { background: #444; color: #fff; }
        .btn-icon { width: 30px; padding: 0; font-size: 14px; }
        .btn-util { background: #222; color: #888; }
        .btn-util:hover { color: #fff; }
        
        .btn-invert { 
            width: 30px; padding: 0; font-size: 16px; background: #1a1a1a; 
            border: 1px solid #333; color: var(--accent); 
        }
        .btn-invert:hover { background: #333; }

        /* --- Modal --- */
        #info-modal {
            position: absolute; top: 60px; left: 20px; z-index: 20;
            background: rgba(17, 17, 17, 0.96); backdrop-filter: blur(12px);
            border: 1px solid #333; border-radius: 8px;
            width: 350px; padding: 25px; font-size: 13px; line-height: 1.6;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); display: none;
            max-height: 80vh; overflow-y: auto;
        }
        #info-modal h2 { margin-top: 0; color: var(--accent); font-size: 16px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        #info-modal h3 { margin: 15px 0 5px 0; font-size: 12px; color: #fff; text-transform: uppercase; }
        #info-modal p { margin: 0 0 10px 0; color: #aaa; }
        .close-info { position: absolute; top: 15px; right: 15px; cursor: pointer; color: #666; font-size: 18px; }
        code { background: #222; padding: 2px 4px; border-radius: 3px; color: var(--accent); font-family: monospace; }
        .shortcut { background: #333; color: #fff; padding: 1px 5px; border-radius: 3px; font-size: 10px; }

    </style>
</head>
<body>

    <header>
        <button id="info-btn" class="btn-sec btn-icon">?</button>
        
        <div class="control-group">
            <div class="label-row"><span>Grid (N)</span> <span id="n-val" class="value">12</span></div>
            <input type="range" id="param-n" min="2" max="64" step="1" value="12">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Thickness</span> <span id="w-val" class="value">2.5</span></div>
            <input type="range" id="param-w" min="0.5" max="15" step="0.5" value="2.5">
        </div>

        <div class="ui-row">
            <select id="draw-mode" class="mode-select">
                <option value="straight">Straight</option>
                <option value="curved">Curved</option>
            </select>
            
            <label class="check-group" title="Fill regions with unit width">
                <input type="checkbox" id="check-filled"> Filled
            </label>
            
            <button id="invert-fill-btn" class="btn-invert" title="Invert Colors">‚áÑ</button>
        </div>

        <div style="flex-grow:1"></div>
        <button id="save-img-btn" class="btn-sec">üì∏ PNG</button>
        <button onclick="window.location.href='index.html'" class="btn-util">üè†</button>
    </header>

    <main>
        <div class="left-col">
            <div>
                <div class="panel-header">Matrix State</div>
                <div id="matrix-wrapper" class="canvas-wrapper">
                    <canvas id="matrixCanvas"></canvas>
                </div>
            </div>

            <div class="editor-container">
                <div class="panel-header">Generator Function</div>
                
                <select id="preset-select" class="preset-select">
                    <optgroup label="Patterns">
                        <option value="xor">XOR Parity</option>
                        <option value="checker">Checkers</option>
                        <option value="stripes">Vertical Stripes</option>
                        <option value="diagonals">Diagonals</option>
                        <option value="quarters">Quarters</option>
                        <option value="radial">Radial Ring</option>
                    </optgroup>
                    <optgroup label="Basic">
                        <option value="reset">Reset (All 0)</option>
                        <option value="random">Random Noise</option>
                        <option value="invert">Invert Grid</option>
                    </optgroup>
                    <optgroup label="User Saved" id="user-presets-group">
                    </optgroup>
                </select>

                <textarea id="code-area" spellcheck="false"></textarea>

                <div class="editor-actions">
                    <button id="save-preset-btn" class="btn-sec">üíæ Save</button>
                    <button id="run-btn" class="btn-run">‚ñ∂ Run Code</button>
                </div>
                <div id="code-error" style="color: #ff4757; font-size: 10px; margin-top: 5px; display: none;">Error</div>
            </div>
        </div>

        <div class="right-col">
            <div style="position: absolute; top: 10px; left: 10px; z-index: 5;" class="panel-header">Truchet-Smith Tiling</div>
            <div id="tile-wrapper" class="canvas-wrapper">
                <canvas id="tileCanvas"></canvas>
            </div>
        </div>

        <div id="info-modal">
            <span class="close-info" id="close-info">&times;</span>
            <h2>About this Tool</h2>
            
            <h3>How It Works</h3>
            <p>This is a playground for <strong>Truchet-Smith Tiling</strong>. The grid on the left controls the rotation of tiles on the right. <code>0</code> represents one orientation, <code>1</code> represents its 90-degree rotation.</p>
            <p><strong>Modes:</strong> Switch between <em>Straight</em> lines and <em>Curved</em> arcs (Smith tiles). Toggle <em>Filled</em> to visualize the continuous ribbons (unit-width paths) formed by the tiling.</p>

            <h3>Functions</h3>
            <p>You can program the grid using JavaScript. The function runs for every cell (row, col) and returns 0 or 1.</p>
            <p><strong>Variables:</strong> <code>row</code>, <code>col</code>, <code>n</code> (grid size).<br>
            <strong>Example:</strong> <code>return (row + col) % 2;</code> creates a checkerboard.</p>

            <h3>Saving Code</h3>
            <p>Modified a function? Click <strong>üíæ Save</strong> to store it in your browser's local storage. It will appear in the dropdown menu for future use.</p>
            
            <p style="margin-top:15px; font-size:11px; color:#666;">Use <span class="shortcut">Ctrl</span>+<span class="shortcut">Enter</span> to run code quickly.</p>
        </div>
    </main>

<script>
    /**
     * STATE & CONFIG
     */
    let N = 12;
    let lineWidth = 2.5;
    let isFilled = false;
    let isInvertedFill = false;
    let drawMode = 'straight'; // 'straight' or 'curved'
    let grid = []; 

    // DOM Elements
    const matrixCanvas = document.getElementById('matrixCanvas');
    const tileCanvas = document.getElementById('tileCanvas');
    const mCtx = matrixCanvas.getContext('2d');
    const tCtx = tileCanvas.getContext('2d');
    
    const ui = {
        n: document.getElementById('param-n'), nVal: document.getElementById('n-val'),
        w: document.getElementById('param-w'), wVal: document.getElementById('w-val'),
        filled: document.getElementById('check-filled'),
        mode: document.getElementById('draw-mode'),
        invertFill: document.getElementById('invert-fill-btn'),
        editor: document.getElementById('code-area'),
        select: document.getElementById('preset-select'),
        userGroup: document.getElementById('user-presets-group'),
        runBtn: document.getElementById('run-btn'),
        savePresetBtn: document.getElementById('save-preset-btn'),
        saveImgBtn: document.getElementById('save-img-btn'),
        errorMsg: document.getElementById('code-error'),
        info: document.getElementById('info-modal'),
        infoBtn: document.getElementById('info-btn'),
        closeInfo: document.getElementById('close-info')
    };

    /**
     * PRESETS
     */
    const presets = {
        xor: `// Parity: 1 if odd number of 1s in binary, else 0
let rP = (row.toString(2).match(/1/g) || []).length % 2;
let cP = (col.toString(2).match(/1/g) || []).length % 2;
return rP ^ cP;`,
        checker: "return (row + col) % 2;",
        stripes: "return col % 2;",
        diagonals: "return (row % 2) === (col % 2) ? 1 : 0;",
        quarters: "return (row < n/2) === (col < n/2) ? 0 : 1;",
        radial: "let cx = n/2 - 0.5, cy = n/2 - 0.5;\nlet dist = Math.sqrt((row-cy)**2 + (col-cx)**2);\nreturn Math.floor(dist) % 2;",
        reset: "return 0;",
        random: "return Math.random() > 0.5 ? 1 : 0;",
        invert: "return (row % 2) === 0 ? 1 : 0; // Fallback"
    };

    let userPresets = JSON.parse(localStorage.getItem('truchet_user_presets') || '{}');

    function updatePresetDropdown() {
        ui.userGroup.innerHTML = '';
        Object.keys(userPresets).forEach(name => {
            const opt = document.createElement('option');
            opt.value = `user:${name}`;
            opt.textContent = name;
            ui.userGroup.appendChild(opt);
        });
    }

    function init() {
        grid = Array(N).fill().map(() => Array(N).fill(0));
        ui.editor.value = presets.xor;

        // Listeners
        window.addEventListener('resize', resize);
        
        ui.n.addEventListener('input', (e) => { N = parseInt(e.target.value); ui.nVal.textContent = N; runCode(); });
        ui.w.addEventListener('input', (e) => { lineWidth = parseFloat(e.target.value); ui.wVal.textContent = lineWidth.toFixed(1); draw(); });
        
        ui.filled.addEventListener('change', (e) => { isFilled = e.target.checked; draw(); });
        ui.mode.addEventListener('change', (e) => { drawMode = e.target.value; draw(); });
        ui.invertFill.addEventListener('click', () => { isInvertedFill = !isInvertedFill; draw(); });

        ui.select.addEventListener('change', (e) => {
            const val = e.target.value;
            if (val === 'invert') { invertGrid(); return; }
            if (val.startsWith('user:')) {
                ui.editor.value = userPresets[val.split(':')[1]];
            } else if (presets[val]) {
                ui.editor.value = presets[val];
            }
            runCode(); 
        });

        ui.runBtn.addEventListener('click', runCode);
        ui.editor.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') runCode(); });

        ui.savePresetBtn.addEventListener('click', () => {
            const name = prompt("Name your function:");
            if (name) {
                userPresets[name] = ui.editor.value;
                localStorage.setItem('truchet_user_presets', JSON.stringify(userPresets));
                updatePresetDropdown();
                ui.select.value = `user:${name}`;
            }
        });

        ui.saveImgBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `truchet-${drawMode}-${Date.now()}.png`;
            link.href = tileCanvas.toDataURL();
            link.click();
        });

        matrixCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e, matrixCanvas));
        tileCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e, tileCanvas));

        ui.infoBtn.onclick = () => ui.info.style.display = (ui.info.style.display === 'block') ? 'none' : 'block';
        ui.closeInfo.onclick = () => ui.info.style.display = 'none';

        updatePresetDropdown();
        resize();
        runCode();
    }

    function invertGrid() {
        for(let r=0; r<N; r++) for(let c=0; c<N; c++) grid[r][c] = 1 - grid[r][c];
        draw();
    }

    function runCode() {
        const userCode = ui.editor.value;
        ui.errorMsg.style.display = 'none';
        try {
            const genFunc = new Function('row', 'col', 'n', userCode);
            const newGrid = [];
            for (let r = 0; r < N; r++) {
                const rowArr = [];
                for (let c = 0; c < N; c++) {
                    let val = 0;
                    const result = genFunc(r, c, N);
                    if (typeof result === 'boolean') val = result ? 1 : 0;
                    else if (typeof result === 'number') val = Math.abs(Math.round(result)) % 2;
                    rowArr.push(val);
                }
                newGrid.push(rowArr);
            }
            grid = newGrid;
            resize(); 
        } catch (err) {
            ui.errorMsg.textContent = "Error: " + err.message;
            ui.errorMsg.style.display = 'block';
        }
    }

    function resize() {
        const mWrap = document.getElementById('matrix-wrapper');
        const mSize = Math.min(mWrap.clientWidth, mWrap.clientHeight) - 10;
        matrixCanvas.width = mSize * 2; matrixCanvas.height = mSize * 2;
        matrixCanvas.style.width = `${mSize}px`; matrixCanvas.style.height = `${mSize}px`;
        mCtx.setTransform(2,0,0,2,0,0);

        const tWrap = document.getElementById('tile-wrapper');
        const tSize = Math.min(tWrap.clientWidth, tWrap.clientHeight) - 10;
        tileCanvas.width = tSize * 2; tileCanvas.height = tSize * 2;
        tileCanvas.style.width = `${tSize}px`; tileCanvas.style.height = `${tSize}px`;
        tCtx.setTransform(2,0,0,2,0,0);

        draw();
    }

    function draw() {
        // Draw Matrix
        const mSz = matrixCanvas.width/2;
        const mc = mSz/N;
        mCtx.fillStyle = '#050505'; mCtx.fillRect(0,0,mSz,mSz);
        
        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                const px = c*mc, py = r*mc;
                mCtx.strokeStyle = '#222'; mCtx.strokeRect(px, py, mc, mc);
                if(grid[r][c]) {
                    mCtx.fillStyle = '#111'; mCtx.fillRect(px, py, mc, mc);
                    mCtx.fillStyle = varColor(1);
                    if(mc > 12) mCtx.fillText("1", px+mc/2-3, py+mc/2+3);
                    else mCtx.fillRect(px+2, py+2, mc-4, mc-4);
                } else {
                    mCtx.fillStyle = '#333';
                    if(mc > 12) mCtx.fillText("0", px+mc/2-3, py+mc/2+3);
                }
            }
        }

        // Draw Tiling
        const tSz = tileCanvas.width/2;
        const tc = tSz/N;
        tCtx.fillStyle = '#000'; tCtx.fillRect(0,0,tSz,tSz);

        if (isFilled) {
            drawFilledTiling(tc);
        } else {
            drawStrokeTiling(tc);
        }
    }

    function drawStrokeTiling(tc) {
        tCtx.lineWidth = lineWidth;
        tCtx.lineCap = drawMode === 'curved' ? 'butt' : 'round';
        
        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                const x = c*tc, y = r*tc, m = tc/2;
                // Visual Bugfix: Use the lighter color for all curved tiles, 
                // but keep orientation-dependent colors for straight mode.
                tCtx.strokeStyle = (drawMode === 'curved') ? varColor(1) : varColor(grid[r][c]);
                tCtx.beginPath();
                
                if (drawMode === 'straight') {
                    if(grid[r][c] === 0) { // /
                        tCtx.moveTo(x, y+m); tCtx.lineTo(x+m, y);
                        tCtx.moveTo(x+m, y+tc); tCtx.lineTo(x+tc, y+m);
                    } else { // \
                        tCtx.moveTo(x+m, y); tCtx.lineTo(x+tc, y+m);
                        tCtx.moveTo(x, y+m); tCtx.lineTo(x+m, y+tc);
                    }
                } else { // Curved
                    if (grid[r][c] === 0) {
                        tCtx.arc(x, y, m, 0, Math.PI/2); // Top-Left corner
                        tCtx.stroke(); tCtx.beginPath();
                        tCtx.arc(x+tc, y+tc, m, Math.PI, 1.5*Math.PI); // Btm-Right corner
                    } else {
                        tCtx.arc(x, y+tc, m, 1.5*Math.PI, 0); // Btm-Left corner
                        tCtx.stroke(); tCtx.beginPath();
                        tCtx.arc(x+tc, y, m, Math.PI/2, Math.PI); // Top-Right corner
                    }
                }
                tCtx.stroke();
            }
        }
    }

    function drawFilledTiling(tc) {
        // 1. Color Propagation
        let colors = Array(N).fill().map(() => Array(N).fill(0));
        
        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                if(r===0 && c===0) { colors[r][c] = isInvertedFill ? 1 : 0; continue; }
                
                let prevR, prevC;
                if (c > 0) { prevR = r; prevC = c-1; }
                else { prevR = r-1; prevC = 0; }
                
                let sameRotation = (grid[r][c] === grid[prevR][prevC]);
                colors[r][c] = sameRotation ? (1 - colors[prevR][prevC]) : colors[prevR][prevC];
            }
        }

        // 2. Render
        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                const x = c*tc, y = r*tc, m = tc/2;
                const rot = grid[r][c];
                const col = colors[r][c];
                
                tCtx.fillStyle = varColor(1);
                tCtx.beginPath();
                
                if (col === 0) {
                    // COLOR 0: The "Corridor" (Connects regions between lines)
                    if (drawMode === 'straight') {
                        if (rot === 0) { // Connects Left-Bottom to Right-Top
                            tCtx.moveTo(x, y+m); tCtx.lineTo(x, y+tc); tCtx.lineTo(x+m, y+tc); 
                            tCtx.lineTo(x+tc, y+m); tCtx.lineTo(x+tc, y); tCtx.lineTo(x+m, y);
                        } else { // Connects Left-Top to Right-Bottom
                            tCtx.moveTo(x, y+m); tCtx.lineTo(x, y); tCtx.lineTo(x+m, y);
                            tCtx.lineTo(x+tc, y+m); tCtx.lineTo(x+tc, y+tc); tCtx.lineTo(x+m, y+tc);
                        }
                    } else { // Curved Corridor
                        if (rot === 0) { // Fills between TL and BR arcs
                            tCtx.moveTo(x+m, y); 
                            tCtx.arc(x, y, m, 0, Math.PI/2); // Inner Arc TL
                            tCtx.lineTo(x, y+tc); // Fill Corner BL
                            tCtx.lineTo(x+m, y+tc);
                            tCtx.arc(x+tc, y+tc, m, Math.PI, 1.5*Math.PI); // Inner Arc BR
                            tCtx.lineTo(x+tc, y); // Fill Corner TR
                            tCtx.lineTo(x+m, y);
                        } else { // Fills between BL and TR arcs
                            tCtx.moveTo(x, y+m);
                            tCtx.arc(x, y+tc, m, 1.5*Math.PI, 0); // Inner Arc BL
                            tCtx.lineTo(x+tc, y+tc); // Fill Corner BR
                            tCtx.lineTo(x+tc, y+m);
                            tCtx.arc(x+tc, y, m, Math.PI/2, Math.PI); // Inner Arc TR
                            tCtx.lineTo(x, y); // Fill Corner TL
                            tCtx.lineTo(x, y+m);
                        }
                    }
                } else {
                    // COLOR 1: The "Corners" (Behind the lines)
                    if (drawMode === 'straight') {
                        if (rot === 0) {
                            tCtx.moveTo(x, y); tCtx.lineTo(x+m, y); tCtx.lineTo(x, y+m); 
                            tCtx.moveTo(x+tc, y+tc); tCtx.lineTo(x+m, y+tc); tCtx.lineTo(x+tc, y+m);
                        } else {
                            tCtx.moveTo(x, y+tc); tCtx.lineTo(x+m, y+tc); tCtx.lineTo(x, y+m);
                            tCtx.moveTo(x+tc, y); tCtx.lineTo(x+m, y); tCtx.lineTo(x+tc, y+m);
                        }
                    } else { // Curved Corners (Fans)
                        if (rot === 0) {
                            tCtx.moveTo(x, y); tCtx.arc(x, y, m, 0, Math.PI/2); 
                            tCtx.moveTo(x+tc, y+tc); tCtx.arc(x+tc, y+tc, m, Math.PI, 1.5*Math.PI);
                        } else {
                            tCtx.moveTo(x, y+tc); tCtx.arc(x, y+tc, m, 1.5*Math.PI, 0);
                            tCtx.moveTo(x+tc, y); tCtx.arc(x+tc, y, m, Math.PI/2, Math.PI);
                        }
                    }
                }
                tCtx.fill();
            }
        }
    }

    function varColor(v) { return v === 1 ? '#00d2ff' : '#007799'; }

    function handleCanvasClick(e, canvas) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const r = Math.floor(y * N), c = Math.floor(x * N);
        if(r >=0 && r < N && c >= 0 && c < N) {
            grid[r][c] = 1 - grid[r][c];
            draw();
        }
    }

    init();
</script>
</body>
</html>