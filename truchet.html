<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truchet-Smith Tiling</title>
    <style>
        :root { 
            --accent: #00d2ff; 
            --accent-dim: rgba(0, 210, 255, 0.1);
            --bg: #050505; 
            --panel: #111; 
            --code-bg: #0d0d0d;
            --record: #eb4d4b;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; 
            display: flex; flex-direction: column; 
            background: var(--bg); color: #fff; 
            margin: 0; height: 100vh; overflow: hidden; 
        }
        
        /* --- Header --- */
        header { 
            background: var(--panel); padding: 8px 16px; 
            border-bottom: 1px solid #333; 
            display: flex; flex-wrap: wrap; align-items: center; justify-content: center;
            gap: 12px; z-index: 10; height: 60px; flex-shrink: 0;
        }
        
        .control-group { 
            display: flex; flex-direction: column; gap: 2px; 
            min-width: 80px;
        }

        .label-row { 
            display: flex; justify-content: space-between; 
            color: #888; font-size: 9px; font-weight: bold; text-transform: uppercase; 
        }
        
        span.value { color: var(--accent); font-family: monospace; }
        input[type="range"] { width: 90px; accent-color: var(--accent); cursor: pointer; height: 10px; }

        /* UI Controls */
        .ui-row { display: flex; align-items: center; gap: 8px; }

        .check-group { 
            display: flex; align-items: center; gap: 6px; 
            font-size: 11px; font-weight: bold; text-transform: uppercase; 
            color: #ccc; cursor: pointer; border: 1px solid #333; 
            padding: 0 8px; border-radius: 4px; background: #1a1a1a; height: 30px;
        }
        .check-group:hover { border-color: #666; color: #fff; }
        .check-group input { width: 14px; height: 14px; accent-color: var(--accent); cursor: pointer; margin: 0; }

        select.mode-select {
            background: #1a1a1a; color: #fff; border: 1px solid #333;
            font-size: 11px; font-weight: bold; text-transform: uppercase;
            height: 30px; border-radius: 4px; padding: 0 8px; cursor: pointer;
        }
        select.mode-select:hover { border-color: #666; }

        /* --- Main Layout --- */
        main { 
            flex-grow: 1; display: flex; flex-direction: row; 
            padding: 15px; gap: 15px; min-height: 0;
            background: radial-gradient(circle at center, #0a0a0a 0%, #000 100%);
        }

        .left-col { display: flex; flex-direction: column; width: 350px; gap: 10px; flex-shrink: 0; }
        .right-col { flex-grow: 1; display: flex; flex-direction: column; border: 1px solid #222; border-radius: 6px; background: #000; position: relative; }

        .panel-header {
            font-size: 11px; letter-spacing: 1px; color: var(--accent);
            text-transform: uppercase; font-weight: bold; opacity: 0.8;
            margin-bottom: 5px; display: flex; justify-content: space-between;
        }

        .canvas-wrapper {
            background: #000; border: 1px solid #222; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: relative;
        }

        #matrix-wrapper { height: 280px; flex-shrink: 0; }
        #tile-wrapper { height: 100%; width: 100%; }

        canvas { cursor: crosshair; image-rendering: auto; }

        /* Recording Indicator */
        #rec-indicator {
            position: absolute; top: 15px; right: 15px; z-index: 20;
            background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px;
            display: none; align-items: center; gap: 8px; color: #fff;
            font-family: monospace; font-size: 12px; border: 1px solid var(--record);
        }
        .dot { width: 8px; height: 8px; background: var(--record); border-radius: 50%; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        /* --- Code Editor --- */
        .editor-container {
            flex-grow: 1; display: flex; flex-direction: column;
            background: var(--panel); border: 1px solid #333; border-radius: 6px;
            padding: 10px; min-height: 0;
        }

        select.preset-select {
            background: #222; color: #fff; border: 1px solid #444; 
            font-family: monospace; font-size: 11px; padding: 4px; 
            border-radius: 3px; width: 100%; cursor: pointer; margin-bottom: 8px;
        }

        textarea {
            flex-grow: 1; background: var(--code-bg); color: #ccc;
            border: 1px solid #333; border-radius: 4px;
            padding: 10px; font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px; line-height: 1.4; resize: none;
            outline: none; white-space: pre; margin-bottom: 8px;
        }
        textarea:focus { border-color: var(--accent); color: #fff; }

        .editor-actions { display: flex; gap: 8px; }

        /* --- Buttons --- */
        button { 
            border: none; padding: 0 12px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; transition: all 0.2s; 
            text-transform: uppercase; font-size: 10px; height: 30px;
            display: flex; align-items: center; justify-content: center; gap: 6px;
            font-family: inherit;
        }
        .btn-run { background: var(--accent); color: #000; flex-grow: 1; }
        .btn-run:hover { filter: brightness(1.2); box-shadow: 0 0 8px var(--accent-dim); }
        .btn-sec { background: #333; color: #ccc; }
        .btn-sec:hover { background: #444; color: #fff; }
        .btn-rec { background: var(--record); color: #fff; }
        .btn-rec:hover { filter: brightness(1.1); }
        .btn-icon { width: 30px; padding: 0; font-size: 14px; }
        .btn-util { background: #222; color: #888; }
        .btn-util:hover { color: #fff; }
        
        .btn-invert { 
            width: 30px; padding: 0; font-size: 16px; background: #1a1a1a; 
            border: 1px solid #333; color: var(--accent); 
        }
        .btn-invert:hover { background: #333; }

        /* --- Modal --- */
        #info-modal {
            position: absolute; top: 60px; left: 20px; z-index: 20;
            background: rgba(17, 17, 17, 0.96); backdrop-filter: blur(12px);
            border: 1px solid #333; border-radius: 8px;
            width: 350px; padding: 25px; font-size: 13px; line-height: 1.6;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); display: none;
            max-height: 80vh; overflow-y: auto;
        }
        #info-modal h2 { margin-top: 0; color: var(--accent); font-size: 16px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        #info-modal h3 { margin: 15px 0 5px 0; font-size: 12px; color: #fff; text-transform: uppercase; }
        #info-modal p { margin: 0 0 10px 0; color: #aaa; }
        .close-info { position: absolute; top: 15px; right: 15px; cursor: pointer; color: #666; font-size: 18px; }
        code { background: #222; padding: 2px 4px; border-radius: 3px; color: var(--accent); font-family: monospace; }
        .shortcut { background: #333; color: #fff; padding: 1px 5px; border-radius: 3px; font-size: 10px; }

        /* --- MOBILE RESPONSIVE --- */
        @media (max-width: 900px) {
            body { height: auto; overflow-y: auto; }
            header { height: auto; padding: 10px; justify-content: center; gap: 15px; }
            main { flex-direction: column; height: auto; overflow: visible; }
            .left-col { width: 100%; order: 2; }
            .right-col { width: 100%; order: 1; height: 55vh; min-height: 350px; }
            #matrix-wrapper { margin: 0 auto; max-width: 300px; }
            .editor-container { min-height: 300px; }
        }

    </style>
</head>
<body>

    <header>
        <button id="info-btn" class="btn-sec btn-icon">?</button>
        
        <div class="control-group">
            <div class="label-row"><span>Grid (N)</span> <span id="n-val" class="value">12</span></div>
            <input type="range" id="param-n" min="2" max="64" step="1" value="12">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Thickness</span> <span id="w-val" class="value">2.5</span></div>
            <input type="range" id="param-w" min="0.5" max="15" step="0.5" value="2.5">
        </div>

        <div class="ui-row">
            <select id="draw-mode" class="mode-select">
                <option value="straight">Straight</option>
                <option value="curved">Curved</option>
            </select>
            
            <label class="check-group" title="Fill regions with unit width">
                <input type="checkbox" id="check-filled"> Filled
            </label>
            
            <button id="invert-fill-btn" class="btn-invert" title="Invert Colors">‚áÑ</button>
        </div>

        <div style="flex-grow:1"></div>
        
        <div class="control-group" style="border-right: 1px solid #333; padding-right: 10px;">
            <div class="label-row"><span>Speed</span> <span id="speed-val" class="value">6</span></div>
            <input type="range" id="anim-speed" min="1" max="10" step="1" value="6">
        </div>
        
        <select id="anim-type" class="mode-select" style="width: 100px;">
            <option value="none">Static</option>
            <option value="cell">Cell-by-Cell</option>
            <option value="row">Row-wise</option>
            <option value="rings">Rings</option>
            <option value="all">All-at-Once</option>
        </select>
        
        <button id="anim-play-btn" class="btn-sec btn-icon" title="Play Animation">‚ñ∂</button>
        <button id="rec-btn" class="btn-rec">‚è∫ REC</button>
        
        <div style="width: 1px; height: 30px; background: #333; margin: 0 5px;"></div>
        
        <button id="save-svg-btn" class="btn-util">SVG</button>
        <button id="save-img-btn" class="btn-util">PNG</button>
        <button onclick="window.location.href='index.html'" class="btn-util">üè†</button>
    </header>

    <main>
        <div class="left-col">
            <div>
                <div class="panel-header">Matrix State</div>
                <div id="matrix-wrapper" class="canvas-wrapper">
                    <canvas id="matrixCanvas"></canvas>
                </div>
            </div>

            <div class="editor-container">
                <div class="panel-header">Generator Function</div>
                
                <select id="preset-select" class="preset-select">
                    <optgroup label="Patterns">
                        <option value="xor">XOR Parity</option>
                        <option value="checker">Checkers</option>
                        <option value="stripes">Vertical Stripes</option>
                        <option value="diagonals">Diagonals</option>
                        <option value="quarters">Quarters</option>
                        <option value="radial">Radial Ring</option>
                    </optgroup>
                    <optgroup label="Basic">
                        <option value="reset">Reset (All 0)</option>
                        <option value="random">Random Noise</option>
                        <option value="invert">Invert Grid</option>
                    </optgroup>
                    <optgroup label="User Saved" id="user-presets-group">
                    </optgroup>
                </select>

                <textarea id="code-area" spellcheck="false"></textarea>

                <div class="editor-actions">
                    <button id="save-preset-btn" class="btn-sec">üíæ Save</button>
                    <button id="run-btn" class="btn-run">‚ñ∂ Update Grid</button>
                </div>
                <div id="code-error" style="color: #ff4757; font-size: 10px; margin-top: 5px; display: none;">Error</div>
            </div>
        </div>

        <div class="right-col">
            <div style="position: absolute; top: 10px; left: 10px; z-index: 5;" class="panel-header">Truchet-Smith Tiling</div>
            <div id="rec-indicator"><div class="dot"></div><span id="rec-timer">00:00</span></div>
            <div id="tile-wrapper" class="canvas-wrapper">
                <canvas id="tileCanvas"></canvas>
            </div>
        </div>

        <div id="info-modal">
            <span class="close-info" id="close-info">&times;</span>
            <h2>About this Tool</h2>
            
            <h3>Animation Modes</h3>
            <p><strong>Cell-by-Cell:</strong> Scans grid for active cells and rotates them one-by-one.</p>
            <p><strong>Row-wise:</strong> Activates one full row at a time.</p>
            <p><strong>Rings:</strong> Concentric waves starting from center.</p>
            <p><strong>All-at-Once:</strong> Global transition.</p>
            <p><em>All animations now cycle back (rewind) to the zero state before restarting.</em></p>

            <h3>Export Options</h3>
            <p><strong>‚è∫ REC:</strong> Records a .webm video of the animation.</p>
            <p><strong>SVG:</strong> Exports a vector snapshot of the exact current frame.</p>
            <p><strong>PNG:</strong> Saves the current canvas view.</p>
        </div>
    </main>

<script>
    /**
     * STATE & CONFIG
     */
    let N = 12;
    let lineWidth = 2.5;
    let isFilled = false;
    let isInvertedFill = false;
    let drawMode = 'straight'; 
    
    // Grids
    let targetGrid = [];   // The final state (0 or 1)
    let angleGrid = [];    // Current rotation (Radians)

    // Animation Speed Array: Level 1 (Slowest: 2.0s) to Level 10 (Fastest: 0.1s)
    const STEP_DURATION_LEVELS = [
        2.0, 1.7, 1.4, 1.1, 0.8, 0.5, 0.4, 0.3, 0.2, 0.1
    ];

    // Animation State
    let animType = 'none';
    let isAnimating = false;
    let animProgress = 0; 
    let animDirection = 1; // 1 = forward, -1 = rewind
    let animationFrameId;
    let currentStepDuration = STEP_DURATION_LEVELS[5]; // Default Level 6 (~0.5s)

    // Recording State
    let mediaRecorder;
    let recordedChunks = [];
    let recStartTime;
    let isRecording = false;

    // DOM Elements
    const matrixCanvas = document.getElementById('matrixCanvas');
    const tileCanvas = document.getElementById('tileCanvas');
    const mCtx = matrixCanvas.getContext('2d');
    const tCtx = tileCanvas.getContext('2d');
    
    const ui = {
        n: document.getElementById('param-n'), nVal: document.getElementById('n-val'),
        w: document.getElementById('param-w'), wVal: document.getElementById('w-val'),
        filled: document.getElementById('check-filled'),
        mode: document.getElementById('draw-mode'),
        invertFill: document.getElementById('invert-fill-btn'),
        editor: document.getElementById('code-area'),
        select: document.getElementById('preset-select'),
        userGroup: document.getElementById('user-presets-group'),
        runBtn: document.getElementById('run-btn'),
        savePresetBtn: document.getElementById('save-preset-btn'),
        saveImgBtn: document.getElementById('save-img-btn'),
        saveSvgBtn: document.getElementById('save-svg-btn'),
        errorMsg: document.getElementById('code-error'),
        info: document.getElementById('info-modal'),
        infoBtn: document.getElementById('info-btn'),
        closeInfo: document.getElementById('close-info'),
        
        animType: document.getElementById('anim-type'),
        animSpeed: document.getElementById('anim-speed'),
        speedVal: document.getElementById('speed-val'),
        playBtn: document.getElementById('anim-play-btn'),
        
        recBtn: document.getElementById('rec-btn'),
        recInd: document.getElementById('rec-indicator'),
        recTimer: document.getElementById('rec-timer')
    };

    /**
     * PRESETS
     */
    const presets = {
        xor: `// Parity: 1 if odd number of 1s in binary, else 0
let rP = (row.toString(2).match(/1/g) || []).length % 2;
let cP = (col.toString(2).match(/1/g) || []).length % 2;
return rP ^ cP;`,
        checker: "return (row + col) % 2;",
        stripes: "return col % 2;",
        diagonals: "return (row % 2) === (col % 2) ? 1 : 0;",
        quarters: "return (row < n/2) === (col < n/2) ? 0 : 1;",
        radial: "let cx = n/2 - 0.5, cy = n/2 - 0.5;\nlet dist = Math.sqrt((row-cy)**2 + (col-cx)**2);\nreturn Math.floor(dist) % 2;",
        reset: "return 0;",
        random: "return Math.random() > 0.5 ? 1 : 0;",
        invert: "return (row % 2) === 0 ? 1 : 0; // Fallback"
    };

    let userPresets = JSON.parse(localStorage.getItem('truchet_user_presets') || '{}');

    function updatePresetDropdown() {
        ui.userGroup.innerHTML = '';
        Object.keys(userPresets).forEach(name => {
            const opt = document.createElement('option');
            opt.value = `user:${name}`;
            opt.textContent = name;
            ui.userGroup.appendChild(opt);
        });
    }

    function init() {
        targetGrid = Array(N).fill().map(() => Array(N).fill(0));
        angleGrid = Array(N).fill().map(() => Array(N).fill(0));
        ui.editor.value = presets.xor;

        window.addEventListener('resize', resize);
        
        ui.n.addEventListener('input', (e) => { 
            N = parseInt(e.target.value); 
            ui.nVal.textContent = N; 
            runCode(); 
        });
        ui.w.addEventListener('input', (e) => { 
            lineWidth = parseFloat(e.target.value); 
            ui.wVal.textContent = lineWidth.toFixed(1); 
            requestDraw(); 
        });
        
        ui.filled.addEventListener('change', (e) => { isFilled = e.target.checked; requestDraw(); });
        ui.mode.addEventListener('change', (e) => { drawMode = e.target.value; requestDraw(); });
        ui.invertFill.addEventListener('click', () => { isInvertedFill = !isInvertedFill; requestDraw(); });

        ui.select.addEventListener('change', (e) => {
            const val = e.target.value;
            if (val === 'invert') { invertGrid(); return; }
            if (val.startsWith('user:')) {
                ui.editor.value = userPresets[val.split(':')[1]];
            } else if (presets[val]) {
                ui.editor.value = presets[val];
            }
            runCode(); 
        });

        ui.runBtn.addEventListener('click', runCode);
        ui.editor.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') runCode(); });

        ui.savePresetBtn.addEventListener('click', () => {
            const name = prompt("Name your function:");
            if (name) {
                userPresets[name] = ui.editor.value;
                localStorage.setItem('truchet_user_presets', JSON.stringify(userPresets));
                updatePresetDropdown();
                ui.select.value = `user:${name}`;
            }
        });

        ui.saveImgBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `truchet-${drawMode}-${Date.now()}.png`;
            link.href = tileCanvas.toDataURL();
            link.click();
        });

        ui.saveSvgBtn.addEventListener('click', exportSVG);

        matrixCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e));
        tileCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e));

        ui.infoBtn.onclick = () => ui.info.style.display = (ui.info.style.display === 'block') ? 'none' : 'block';
        ui.closeInfo.onclick = () => ui.info.style.display = 'none';

        // Animation controls
        ui.animType.addEventListener('change', (e) => {
            animType = e.target.value;
            // Reset state on change
            animProgress = -0.05; 
            animDirection = 1;
            
            if (animType === 'none') {
                stopAnimation();
                snapToTarget();
                requestDraw();
            } else {
                if(!isAnimating && ui.playBtn.textContent === "‚è∏") startAnimation(); 
                for(let r=0; r<N; r++) for(let c=0; c<N; c++) angleGrid[r][c] = 0;
                requestDraw();
            }
        });

        ui.animSpeed.addEventListener('input', (e) => {
            const level = parseInt(e.target.value);
            ui.speedVal.textContent = level;
            currentStepDuration = STEP_DURATION_LEVELS[level - 1];
        });

        ui.playBtn.addEventListener('click', toggleAnimation);
        ui.recBtn.addEventListener('click', toggleRecording);

        updatePresetDropdown();
        runCode(); 
    }

    function invertGrid() {
        for(let r=0; r<N; r++) for(let c=0; c<N; c++) targetGrid[r][c] = 1 - targetGrid[r][c];
        if (animType === 'none') snapToTarget();
        requestDraw();
    }

    function snapToTarget() {
        for(let r=0; r<N; r++) for(let c=0; c<N; c++) {
            angleGrid[r][c] = targetGrid[r][c] * (Math.PI/2);
        }
    }

    function runCode() {
        const userCode = ui.editor.value;
        ui.errorMsg.style.display = 'none';
        try {
            const genFunc = new Function('row', 'col', 'n', userCode);
            const newGrid = [];
            for (let r = 0; r < N; r++) {
                const rowArr = [];
                for (let c = 0; c < N; c++) {
                    let val = 0;
                    const result = genFunc(r, c, N);
                    if (typeof result === 'boolean') val = result ? 1 : 0;
                    else if (typeof result === 'number') val = Math.abs(Math.round(result)) % 2;
                    rowArr.push(val);
                }
                newGrid.push(rowArr);
            }
            targetGrid = newGrid;
            
            if (animType === 'none' || !isAnimating) {
                if(angleGrid.length !== N) angleGrid = Array(N).fill().map(() => Array(N).fill(0));
                snapToTarget();
            } else {
                 if(angleGrid.length !== N) angleGrid = Array(N).fill().map(() => Array(N).fill(0));
            }
            resize(); 
        } catch (err) {
            ui.errorMsg.textContent = "Error: " + err.message;
            ui.errorMsg.style.display = 'block';
        }
    }

    function resize() {
        const mWrap = document.getElementById('matrix-wrapper');
        const mSize = Math.min(mWrap.clientWidth, mWrap.clientHeight) - 10;
        matrixCanvas.width = mSize * 2; matrixCanvas.height = mSize * 2;
        matrixCanvas.style.width = `${mSize}px`; matrixCanvas.style.height = `${mSize}px`;
        mCtx.setTransform(2,0,0,2,0,0);

        const tWrap = document.getElementById('tile-wrapper');
        const tSize = Math.min(tWrap.clientWidth, tWrap.clientHeight) - 10;
        tileCanvas.width = tSize * 2; tileCanvas.height = tSize * 2;
        tileCanvas.style.width = `${tSize}px`; tileCanvas.style.height = `${tSize}px`;
        tCtx.setTransform(2,0,0,2,0,0);

        requestDraw();
    }

    /* --- ANIMATION LOGIC --- */
    
    function toggleAnimation() {
        if (isAnimating) stopAnimation(); else startAnimation();
    }

    function startAnimation() {
        if (animType === 'none') return;
        isAnimating = true;
        ui.playBtn.textContent = "‚è∏";
        animDirection = 1;
        animProgress = -0.05; 
        lastTime = performance.now();
        
        for(let r=0; r<N; r++) for(let c=0; c<N; c++) angleGrid[r][c] = 0;
        
        animationLoop();
    }

    function stopAnimation() {
        isAnimating = false;
        ui.playBtn.textContent = "‚ñ∂";
        cancelAnimationFrame(animationFrameId);
    }

    let lastTime = 0;
    
    /* --- Replace animationLoop --- */
    function animationLoop() {
        if (!isAnimating) return;
        
        const now = performance.now();
        const dt = (now - lastTime) / 1000;
        lastTime = now;

        let totalDuration = 1.0;

        // Calculate duration based on strict sequential steps
        if (animType === 'cell') {
            const activeCellCount = targetGrid.flat().filter(v => v === 1).length;
            totalDuration = activeCellCount * currentStepDuration;
        } else if (animType === 'row') {
            totalDuration = N * currentStepDuration;
        } else if (animType === 'rings') {
            // Total duration is exactly the number of rings * time per ring
            // This ensures the speed slider directly controls the rotation speed of a SINGLE ring
            const numRings = Math.ceil(N / 2);
            totalDuration = numRings * currentStepDuration;
        } else {
            totalDuration = currentStepDuration;
        }

        const logicSpeed = 1 / Math.max(0.001, totalDuration);

        if (animDirection === -1) animProgress -= dt * logicSpeed;
        else animProgress += dt * logicSpeed;

        // Expanded bounds for "Dead Zone" pauses
        if (animProgress >= 1.1) { 
            animDirection = -1; 
            animProgress = 1.1; 
        } else if (animProgress <= -0.1) {
            animDirection = 1; 
            animProgress = -0.1;
        }

        updateGridAngles(dt);
        draw();
        
        if (isRecording) updateRecTimer();
        animationFrameId = requestAnimationFrame(animationLoop);
    }

    /* --- Replace updateGridAngles --- */
    function updateGridAngles(dt) {
        // Clamp logic progress to 0-1 for rotation calculations
        const p = Math.max(0, Math.min(1, animProgress));
        
        if (animType === 'cell' || animType === 'row') {
            if (animType === 'cell') {
                let activeIndex = 0;
                const activeTotal = targetGrid.flat().filter(v => v === 1).length;
                const currentStep = p * activeTotal;
                for (let r = 0; r < N; r++) {
                    for (let c = 0; c < N; c++) {
                        if (targetGrid[r][c] === 1) {
                            let localProgress = Math.max(0, Math.min(1, currentStep - activeIndex));
                            angleGrid[r][c] = localProgress * (Math.PI / 2);
                            activeIndex++;
                        } else { angleGrid[r][c] = 0; }
                    }
                }
            } else {
                const currentStep = p * N;
                for (let r = 0; r < N; r++) {
                    let localProgress = Math.max(0, Math.min(1, currentStep - r));
                    for (let c = 0; c < N; c++) {
                        angleGrid[r][c] = targetGrid[r][c] ? localProgress * (Math.PI / 2) : 0;
                    }
                }
            }
            return;
        }
        
        // Pre-calculate ring geometry constants
        const cx = (N - 1) / 2;
        const cy = (N - 1) / 2;
        const numRings = Math.ceil(N / 2);
        
        // Scale p from (0 to 1) -> (0 to numRings)
        // This creates the "counter" that moves from ring 0 to ring N
        const sequencePos = p * numRings;

        for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
                if (targetGrid[r][c] === 0) {
                    angleGrid[r][c] = 0;
                    continue;
                }
                let localP = 0;
                if (animType === 'all') {
                    localP = p;
                } else if (animType === 'rings') {
                    // Determine which ring index (0, 1, 2...) this cell belongs to
                    // Math.floor ensures discrete steps (integers)
                    const dist = Math.max(Math.abs(r - cy), Math.abs(c - cx));
                    const ringIndex = Math.floor(dist); 
                    
                    // Strictly sequential logic:
                    // If sequencePos is 0.5, ring 0 is half done.
                    // If sequencePos is 1.5, ring 0 is done (1.0), ring 1 is half done (0.5).
                    // Subtracting ringIndex aligns the wave to this specific ring.
                    localP = Math.max(0, Math.min(1, sequencePos - ringIndex));
                }
                angleGrid[r][c] = localP * (Math.PI / 2);
            }
        }
    }

    /* --- RECORDING --- */
    function toggleRecording() {
        if (isRecording) stopRecording(); else startRecording();
    }

    function startRecording() {
        recordedChunks = [];
        const stream = tileCanvas.captureStream(60); 
        try { mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' }); } 
        catch (e) { mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); }

        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = exportVideo;
        mediaRecorder.start();
        isRecording = true;
        recStartTime = performance.now();
        ui.recBtn.textContent = "‚èπ STOP";
        ui.recInd.style.display = 'flex';
    }

    function stopRecording() {
        if (!mediaRecorder) return;
        mediaRecorder.stop();
        isRecording = false;
        ui.recBtn.textContent = "‚è∫ REC";
        ui.recInd.style.display = 'none';
    }

    function updateRecTimer() {
        if (!isRecording) return;
        const elapsed = Math.floor((performance.now() - recStartTime) / 1000);
        const mm = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const ss = (elapsed % 60).toString().padStart(2, '0');
        ui.recTimer.textContent = `${mm}:${ss}`;
    }

    function exportVideo() {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `truchet-anim-${Date.now()}.webm`;
        document.body.appendChild(a); a.click();
        setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100);
    }

    /* --- SVG EXPORT --- */
    function exportSVG() {
        const size = 1000; 
        const cellSize = size / N;
        const half = cellSize / 2;
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${size} ${size}" width="${size}" height="${size}" style="background-color:black">`;
        const colMain = "#00d2ff", colBg = "#111111"; 
        const lineWidthSVG = (lineWidth / (tileCanvas.width / 2 / N)) * cellSize;

        let fillColors = Array(N).fill().map(() => Array(N).fill(0));
        for(let r = 0; r < N; r++) {
            for(let c = 0; c < N; c++) {
                if(r === 0 && c === 0) { fillColors[r][c] = isInvertedFill ? 1 : 0; continue; }
                let pr = (c > 0) ? r : r - 1, pc = (c > 0) ? c - 1 : 0;
                fillColors[r][c] = (targetGrid[r][c] === targetGrid[pr][pc]) ? (1 - fillColors[pr][pc]) : fillColors[pr][pc];
            }
        }

        for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
                svg += `<g transform="translate(${c * cellSize}, ${r * cellSize}) rotate(${targetGrid[r][c] * 90}, ${half}, ${half})">`;
                if (isFilled) {
                    const c1 = (fillColors[r][c] === 0) ? colMain : colBg, c2 = (fillColors[r][c] === 0) ? colBg : colMain; 
                    if (drawMode === 'straight') {
                        svg += `<path d="M0 0 L${half} 0 L0 ${half} Z" fill="${c2}" />`;
                        svg += `<path d="M${cellSize} ${cellSize} L${cellSize} ${half} L${half} ${cellSize} Z" fill="${c2}" />`;
                        svg += `<path d="M${half} 0 L${cellSize} 0 L${cellSize} ${half} L${half} ${cellSize} L0 ${cellSize} L0 ${half} Z" fill="${c1}" />`;
                    } else {
                        svg += `<path d="M0 0 L${half} 0 A ${half} ${half} 0 0 1 0 ${half} Z" fill="${c2}" />`;
                        svg += `<path d="M${cellSize} ${cellSize} L${half} ${cellSize} A ${half} ${half} 0 0 1 ${cellSize} ${half} Z" fill="${c2}" />`;
                        svg += `<path d="M ${half} 0 A ${half} ${half} 0 0 1 0 ${half} L 0 ${cellSize} L ${half} ${cellSize} A ${half} ${half} 0 0 1 ${cellSize} ${half} L ${cellSize} 0 Z" fill="${c1}" />`;
                    }
                } else {
                    if (drawMode === 'straight') {
                        svg += `<line x1="0" y1="${half}" x2="${half}" y2="0" stroke="${colMain}" stroke-width="${lineWidthSVG}" />`;
                        svg += `<line x1="${half}" y1="${cellSize}" x2="${cellSize}" y2="${half}" stroke="${colMain}" stroke-width="${lineWidthSVG}" />`;
                    } else {
                        svg += `<path d="M${half} 0 A ${half} ${half} 0 0 1 0 ${half}" fill="none" stroke="${colMain}" stroke-width="${lineWidthSVG}" />`;
                        svg += `<path d="M${half} ${cellSize} A ${half} ${half} 0 0 1 ${cellSize} ${half}" fill="none" stroke="${colMain}" stroke-width="${lineWidthSVG}" />`;
                    }
                }
                svg += `</g>`;
            }
        }
        svg += `</svg>`;
        const link = document.createElement("a");
        link.href = URL.createObjectURL(new Blob([svg], {type: "image/svg+xml"}));
        link.download = `truchet-static-${Date.now()}.svg`; link.click();
    }

    /* --- RENDERING --- */
    function requestDraw() { if (!isAnimating) draw(); }

    function computeFillForGrid(gridState) {
        let fColors = Array(N).fill().map(() => Array(N).fill(0));
        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                if(r===0 && c===0) { fColors[r][c] = isInvertedFill ? 1 : 0; continue; }
                let pr = (c > 0) ? r : r - 1, pc = (c > 0) ? c - 1 : 0;
                fColors[r][c] = (gridState[r][c] === gridState[pr][pc]) ? (1 - fColors[pr][pc]) : fColors[pr][pc];
            }
        }
        return fColors;
    }

    function draw() {
        const mSz = matrixCanvas.width/2, mc = mSz/N;
        mCtx.fillStyle = '#050505'; mCtx.fillRect(0,0,mSz,mSz);
        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                mCtx.strokeStyle = '#222'; mCtx.strokeRect(c*mc, r*mc, mc, mc);
                if(targetGrid[r][c]) {
                    mCtx.fillStyle = '#111'; mCtx.fillRect(c*mc, r*mc, mc, mc);
                    mCtx.fillStyle = varColor(1);
                    if(mc > 12) mCtx.fillText("1", c*mc+mc/2-3, r*mc+mc/2+3);
                    else mCtx.fillRect(c*mc+2, r*mc+2, mc-4, mc-4);
                } else {
                    mCtx.fillStyle = '#333';
                    if(mc > 12) mCtx.fillText("0", c*mc+mc/2-3, r*mc+mc/2+3);
                }
            }
        }

        const tSz = tileCanvas.width/2, tc = tSz/N;
        tCtx.fillStyle = '#000'; tCtx.fillRect(0,0,tSz,tSz);
        
        // Pre-calculate fill maps for start (all zeros) and end (target)
        let startFill = null, endFill = null;
        if (isFilled) {
            const zerosGrid = Array(N).fill().map(() => Array(N).fill(0));
            startFill = computeFillForGrid(zerosGrid);
            endFill = computeFillForGrid(targetGrid);
        }

        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                const cx = c*tc+tc/2, cy = r*tc+tc/2;
                
                // Calculate animation progress 0.0 to 1.0 based on rotation
                let progress = Math.max(0, Math.min(1, angleGrid[r][c] / (Math.PI/2)));

                tCtx.save();
                tCtx.translate(cx, cy); 
                tCtx.rotate(angleGrid[r][c]); 
                tCtx.translate(-cx, -cy);

                if (isFilled) {
                    drawOneFilledTileInterp(tCtx, c*tc, r*tc, tc, startFill[r][c], endFill[r][c], progress);
                } else {
                    drawOneStrokeTile(tCtx, c*tc, r*tc, tc);
                }
                tCtx.restore();
            }
        }
    }

    function drawOneStrokeTile(ctx, x, y, tc) {
        const m = tc/2; ctx.lineWidth = lineWidth; ctx.strokeStyle = varColor(1); ctx.beginPath();
        if (drawMode === 'straight') { ctx.moveTo(x, y+m); ctx.lineTo(x+m, y); ctx.moveTo(x+m, y+tc); ctx.lineTo(x+tc, y+m); }
        else { ctx.arc(x, y, m, 0, Math.PI/2); ctx.stroke(); ctx.beginPath(); ctx.arc(x+tc, y+tc, m, Math.PI, 1.5*Math.PI); }
        ctx.stroke();
    }

    function drawOneFilledTileInterp(ctx, x, y, tc, pStart, pEnd, t) {
        const m = tc/2;
        
        // Colors from CSS
        const colAccent = {r:0, g:210, b:255}; // #00d2ff
        const colDark = {r:17, g:17, b:17};    // #111111

        const lerpColor = (c1, c2, factor) => {
            const r = Math.round(c1.r + (c2.r - c1.r) * factor);
            const g = Math.round(c1.g + (c2.g - c1.g) * factor);
            const b = Math.round(c1.b + (c2.b - c1.b) * factor);
            return `rgb(${r},${g},${b})`;
        };

        // Determine colors for the two regions (A and B) based on parity 0 or 1
        const c1Start = pStart === 0 ? colDark : colAccent;
        const c1End   = pEnd === 0 ? colDark : colAccent;
        
        const c2Start = pStart === 0 ? colAccent : colDark;
        const c2End   = pEnd === 0 ? colAccent : colDark;

        const fill1 = lerpColor(c1Start, c1End, t);
        const fill2 = lerpColor(c2Start, c2End, t);

        // Region 1 (Top-Left / Bottom-Right)
        ctx.fillStyle = fill1; ctx.beginPath();
        if (drawMode === 'straight') { 
            ctx.moveTo(x, y); ctx.lineTo(x+m, y); ctx.lineTo(x, y+m); 
            ctx.moveTo(x+tc, y+tc); ctx.lineTo(x+m, y+tc); ctx.lineTo(x+tc, y+m); 
        } else { 
            ctx.moveTo(x, y); ctx.arc(x, y, m, 0, Math.PI/2); 
            ctx.moveTo(x+tc, y+tc); ctx.arc(x+tc, y+tc, m, Math.PI, 1.5*Math.PI); 
        }
        ctx.fill();

        // Region 2 (Top-Right / Bottom-Left)
        ctx.fillStyle = fill2; ctx.beginPath();
        if (drawMode === 'straight') { 
            ctx.moveTo(x, y+m); ctx.lineTo(x, y+tc); ctx.lineTo(x+m, y+tc); 
            ctx.lineTo(x+tc, y+m); ctx.lineTo(x+tc, y); ctx.lineTo(x+m, y); 
        } else { 
            ctx.moveTo(x+m, y); ctx.arc(x, y, m, 0, Math.PI/2); 
            ctx.lineTo(x, y+tc); ctx.lineTo(x+m, y+tc); 
            ctx.arc(x+tc, y+tc, m, Math.PI, 1.5*Math.PI); 
            ctx.lineTo(x+tc, y); ctx.lineTo(x+m, y); 
        }
        ctx.fill();
    }

    function varColor(v) { return v === 1 ? '#00d2ff' : '#007799'; }

    function handleCanvasClick(e) {
        const rect = e.target.getBoundingClientRect();
        const r = Math.floor(((e.clientY - rect.top) / rect.height) * N), c = Math.floor(((e.clientX - rect.left) / rect.width) * N);
        if(r >=0 && r < N && c >= 0 && c < N) { targetGrid[r][c] = 1 - targetGrid[r][c]; if (!isAnimating) snapToTarget(); draw(); }
    }

    init();
</script>
</body>
</html>