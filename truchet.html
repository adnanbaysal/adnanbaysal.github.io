<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truchet-Smith Tiling</title>
    <style>
        :root { 
            --accent: #00d2ff; 
            --accent-dim: rgba(0, 210, 255, 0.1);
            --bg: #050505; 
            --panel: #111; 
            --code-bg: #0d0d0d;
            --record: #eb4d4b;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; 
            display: flex; flex-direction: column; 
            background: var(--bg); color: #fff; 
            margin: 0; height: 100vh; overflow: hidden; 
        }
        
        /* --- Header --- */
        header { 
            background: var(--panel); padding: 8px 16px; 
            border-bottom: 1px solid #333; 
            display: flex; flex-wrap: wrap; align-items: center; justify-content: center;
            gap: 12px; z-index: 10; height: 60px; flex-shrink: 0;
        }
        
        .control-group { 
            display: flex; flex-direction: column; gap: 2px; 
            min-width: 80px;
        }

        .label-row { 
            display: flex; justify-content: space-between; 
            color: #888; font-size: 9px; font-weight: bold; text-transform: uppercase; 
        }
        
        span.value { color: var(--accent); font-family: monospace; }
        input[type="range"] { width: 90px; accent-color: var(--accent); cursor: pointer; height: 10px; }

        /* UI Controls */
        .ui-row { display: flex; align-items: center; gap: 8px; }

        .check-group { 
            display: flex; align-items: center; gap: 6px; 
            font-size: 11px; font-weight: bold; text-transform: uppercase; 
            color: #ccc; cursor: pointer; border: 1px solid #333; 
            padding: 0 8px; border-radius: 4px; background: #1a1a1a; height: 30px;
        }
        .check-group:hover { border-color: #666; color: #fff; }
        .check-group input { width: 14px; height: 14px; accent-color: var(--accent); cursor: pointer; margin: 0; }

        select.mode-select {
            background: #1a1a1a; color: #fff; border: 1px solid #333;
            font-size: 11px; font-weight: bold; text-transform: uppercase;
            height: 30px; border-radius: 4px; padding: 0 8px; cursor: pointer;
        }
        select.mode-select:hover { border-color: #666; }

        /* --- Main Layout --- */
        main { 
            flex-grow: 1; display: flex; flex-direction: row; 
            padding: 15px; gap: 15px; min-height: 0;
            background: radial-gradient(circle at center, #0a0a0a 0%, #000 100%);
        }

        .left-col { display: flex; flex-direction: column; width: 350px; gap: 10px; flex-shrink: 0; }
        .right-col { flex-grow: 1; display: flex; flex-direction: column; border: 1px solid #222; border-radius: 6px; background: #000; position: relative; }

        .panel-header {
            font-size: 11px; letter-spacing: 1px; color: var(--accent);
            text-transform: uppercase; font-weight: bold; opacity: 0.8;
            margin-bottom: 5px; display: flex; justify-content: space-between;
        }

        .canvas-wrapper {
            background: #000; border: 1px solid #222; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: relative;
        }

        #matrix-wrapper { height: 280px; flex-shrink: 0; }
        #tile-wrapper { height: 100%; width: 100%; }

        canvas { cursor: crosshair; image-rendering: auto; }

        /* Recording Indicator */
        #rec-indicator {
            position: absolute; top: 15px; right: 15px; z-index: 20;
            background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px;
            display: none; align-items: center; gap: 8px; color: #fff;
            font-family: monospace; font-size: 12px; border: 1px solid var(--record);
        }
        .dot { width: 8px; height: 8px; background: var(--record); border-radius: 50%; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        /* --- Code Editor --- */
        .editor-container {
            flex-grow: 1; display: flex; flex-direction: column;
            background: var(--panel); border: 1px solid #333; border-radius: 6px;
            padding: 10px; min-height: 0;
        }

        select.preset-select {
            background: #222; color: #fff; border: 1px solid #444; 
            font-family: monospace; font-size: 11px; padding: 4px; 
            border-radius: 3px; width: 100%; cursor: pointer; margin-bottom: 8px;
        }

        textarea {
            flex-grow: 1; background: var(--code-bg); color: #ccc;
            border: 1px solid #333; border-radius: 4px;
            padding: 10px; font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px; line-height: 1.4; resize: none;
            outline: none; white-space: pre; margin-bottom: 8px;
        }
        textarea:focus { border-color: var(--accent); color: #fff; }

        .editor-actions { display: flex; gap: 8px; }

        /* --- Buttons --- */
        button { 
            border: none; padding: 0 12px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; transition: all 0.2s; 
            text-transform: uppercase; font-size: 10px; height: 30px;
            display: flex; align-items: center; justify-content: center; gap: 6px;
            font-family: inherit;
        }
        .btn-run { background: var(--accent); color: #000; flex-grow: 1; }
        .btn-run:hover { filter: brightness(1.2); box-shadow: 0 0 8px var(--accent-dim); }
        .btn-sec { background: #333; color: #ccc; }
        .btn-sec:hover { background: #444; color: #fff; }
        .btn-rec { background: var(--record); color: #fff; }
        .btn-rec:hover { filter: brightness(1.1); }
        .btn-icon { width: 30px; padding: 0; font-size: 14px; }
        .btn-util { background: #222; color: #888; }
        .btn-util:hover { color: #fff; }
        
        .btn-invert { 
            width: 30px; padding: 0; font-size: 16px; background: #1a1a1a; 
            border: 1px solid #333; color: var(--accent); 
        }
        .btn-invert:hover { background: #333; }

        /* --- Modal --- */
        #info-modal {
            position: absolute; top: 60px; left: 20px; z-index: 20;
            background: rgba(17, 17, 17, 0.96); backdrop-filter: blur(12px);
            border: 1px solid #333; border-radius: 8px;
            width: 350px; padding: 25px; font-size: 13px; line-height: 1.6;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); display: none;
            max-height: 80vh; overflow-y: auto;
        }
        #info-modal h2 { margin-top: 0; color: var(--accent); font-size: 16px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        #info-modal h3 { margin: 15px 0 5px 0; font-size: 12px; color: #fff; text-transform: uppercase; }
        #info-modal p { margin: 0 0 10px 0; color: #aaa; }
        .close-info { position: absolute; top: 15px; right: 15px; cursor: pointer; color: #666; font-size: 18px; }
        code { background: #222; padding: 2px 4px; border-radius: 3px; color: var(--accent); font-family: monospace; }
        .shortcut { background: #333; color: #fff; padding: 1px 5px; border-radius: 3px; font-size: 10px; }

        /* --- MOBILE RESPONSIVE FIXES --- */
        @media (max-width: 900px) {
            body { height: auto; overflow-y: auto; }
            header { height: auto; padding: 10px; justify-content: center; gap: 15px; }
            main { flex-direction: column; height: auto; overflow: visible; }
            .left-col { width: 100%; order: 2; }
            .right-col { width: 100%; order: 1; height: 55vh; min-height: 350px; }
            #matrix-wrapper { margin: 0 auto; max-width: 300px; }
            .editor-container { min-height: 300px; }
        }

    </style>
</head>
<body>

    <header>
        <button id="info-btn" class="btn-sec btn-icon">?</button>
        
        <div class="control-group">
            <div class="label-row"><span>Grid (N)</span> <span id="n-val" class="value">12</span></div>
            <input type="range" id="param-n" min="2" max="64" step="1" value="12">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Thickness</span> <span id="w-val" class="value">2.5</span></div>
            <input type="range" id="param-w" min="0.5" max="15" step="0.5" value="2.5">
        </div>

        <div class="ui-row">
            <select id="draw-mode" class="mode-select">
                <option value="straight">Straight</option>
                <option value="curved">Curved</option>
            </select>
            
            <label class="check-group" title="Fill regions with unit width">
                <input type="checkbox" id="check-filled"> Filled
            </label>
            
            <button id="invert-fill-btn" class="btn-invert" title="Invert Colors">‚áÑ</button>
        </div>

        <div style="flex-grow:1"></div>
        
        <div class="control-group" style="border-right: 1px solid #333; padding-right: 10px;">
            <div class="label-row"><span>Anim Speed</span> <span id="speed-val" class="value">50%</span></div>
            <input type="range" id="anim-speed" min="1" max="100" step="1" value="50">
        </div>
        
        <select id="anim-type" class="mode-select" style="width: 100px;">
            <option value="none">Static</option>
            <option value="cell">Cell-by-Cell</option>
            <option value="row">Row-wise</option>
            <option value="rings">Rings</option>
            <option value="all">All-at-Once</option>
        </select>
        
        <button id="anim-play-btn" class="btn-sec btn-icon" title="Play Animation">‚ñ∂</button>
        <button id="rec-btn" class="btn-rec">‚è∫ REC</button>
        
        <div style="width: 1px; height: 30px; background: #333; margin: 0 5px;"></div>
        
        <button id="save-svg-btn" class="btn-util">SVG</button>
        <button id="save-img-btn" class="btn-util">PNG</button>
        <button onclick="window.location.href='index.html'" class="btn-util">üè†</button>
    </header>

    <main>
        <div class="left-col">
            <div>
                <div class="panel-header">Matrix State</div>
                <div id="matrix-wrapper" class="canvas-wrapper">
                    <canvas id="matrixCanvas"></canvas>
                </div>
            </div>

            <div class="editor-container">
                <div class="panel-header">Generator Function</div>
                
                <select id="preset-select" class="preset-select">
                    <optgroup label="Patterns">
                        <option value="xor">XOR Parity</option>
                        <option value="checker">Checkers</option>
                        <option value="stripes">Vertical Stripes</option>
                        <option value="diagonals">Diagonals</option>
                        <option value="quarters">Quarters</option>
                        <option value="radial">Radial Ring</option>
                    </optgroup>
                    <optgroup label="Basic">
                        <option value="reset">Reset (All 0)</option>
                        <option value="random">Random Noise</option>
                        <option value="invert">Invert Grid</option>
                    </optgroup>
                    <optgroup label="User Saved" id="user-presets-group">
                    </optgroup>
                </select>

                <textarea id="code-area" spellcheck="false"></textarea>

                <div class="editor-actions">
                    <button id="save-preset-btn" class="btn-sec">üíæ Save</button>
                    <button id="run-btn" class="btn-run">‚ñ∂ Update Grid</button>
                </div>
                <div id="code-error" style="color: #ff4757; font-size: 10px; margin-top: 5px; display: none;">Error</div>
            </div>
        </div>

        <div class="right-col">
            <div style="position: absolute; top: 10px; left: 10px; z-index: 5;" class="panel-header">Truchet-Smith Tiling</div>
            <div id="rec-indicator"><div class="dot"></div><span id="rec-timer">00:00</span></div>
            <div id="tile-wrapper" class="canvas-wrapper">
                <canvas id="tileCanvas"></canvas>
            </div>
        </div>

        <div id="info-modal">
            <span class="close-info" id="close-info">&times;</span>
            <h2>About this Tool</h2>
            
            <h3>Animation Modes</h3>
            <p><strong>Cell-by-Cell:</strong> Scans grid left-to-right, top-to-bottom.</p>
            <p><strong>Row-wise:</strong> Activates one full row at a time.</p>
            <p><strong>Rings:</strong> Concentric waves starting from center.</p>
            <p><strong>All-at-Once:</strong> Global transition.</p>
            <p><em>All animations now cycle back (rewind) to the zero state before restarting.</em></p>

            <h3>Export Options</h3>
            <p><strong>‚è∫ REC:</strong> Records a .webm video of the animation.</p>
            <p><strong>SVG:</strong> Exports a vector snapshot of the exact current frame.</p>
            <p><strong>PNG:</strong> Saves the current canvas view.</p>
        </div>
    </main>

<script>
    /**
     * STATE & CONFIG
     */
    let N = 12;
    let lineWidth = 2.5;
    let isFilled = false;
    let isInvertedFill = false;
    let drawMode = 'straight'; 
    
    // Grids
    let targetGrid = [];   // The final state (0 or 1)
    let angleGrid = [];    // Current rotation (Radians)

    // Animation State
    let animType = 'none';
    let isAnimating = false;
    let animProgress = 0; 
    let animDirection = 1; // 1 = forward, -1 = rewind
    let animationFrameId;
    let animSpeedFactor = 0.5;

    // Recording State
    let mediaRecorder;
    let recordedChunks = [];
    let recStartTime;
    let isRecording = false;

    // DOM Elements
    const matrixCanvas = document.getElementById('matrixCanvas');
    const tileCanvas = document.getElementById('tileCanvas');
    const mCtx = matrixCanvas.getContext('2d');
    const tCtx = tileCanvas.getContext('2d');
    
    const ui = {
        n: document.getElementById('param-n'), nVal: document.getElementById('n-val'),
        w: document.getElementById('param-w'), wVal: document.getElementById('w-val'),
        filled: document.getElementById('check-filled'),
        mode: document.getElementById('draw-mode'),
        invertFill: document.getElementById('invert-fill-btn'),
        editor: document.getElementById('code-area'),
        select: document.getElementById('preset-select'),
        userGroup: document.getElementById('user-presets-group'),
        runBtn: document.getElementById('run-btn'),
        savePresetBtn: document.getElementById('save-preset-btn'),
        saveImgBtn: document.getElementById('save-img-btn'),
        saveSvgBtn: document.getElementById('save-svg-btn'),
        errorMsg: document.getElementById('code-error'),
        info: document.getElementById('info-modal'),
        infoBtn: document.getElementById('info-btn'),
        closeInfo: document.getElementById('close-info'),
        
        animType: document.getElementById('anim-type'),
        animSpeed: document.getElementById('anim-speed'),
        speedVal: document.getElementById('speed-val'),
        playBtn: document.getElementById('anim-play-btn'),
        
        recBtn: document.getElementById('rec-btn'),
        recInd: document.getElementById('rec-indicator'),
        recTimer: document.getElementById('rec-timer')
    };

    /**
     * PRESETS
     */
    const presets = {
        xor: `// Parity: 1 if odd number of 1s in binary, else 0
let rP = (row.toString(2).match(/1/g) || []).length % 2;
let cP = (col.toString(2).match(/1/g) || []).length % 2;
return rP ^ cP;`,
        checker: "return (row + col) % 2;",
        stripes: "return col % 2;",
        diagonals: "return (row % 2) === (col % 2) ? 1 : 0;",
        quarters: "return (row < n/2) === (col < n/2) ? 0 : 1;",
        radial: "let cx = n/2 - 0.5, cy = n/2 - 0.5;\nlet dist = Math.sqrt((row-cy)**2 + (col-cx)**2);\nreturn Math.floor(dist) % 2;",
        reset: "return 0;",
        random: "return Math.random() > 0.5 ? 1 : 0;",
        invert: "return (row % 2) === 0 ? 1 : 0; // Fallback"
    };

    let userPresets = JSON.parse(localStorage.getItem('truchet_user_presets') || '{}');

    function updatePresetDropdown() {
        ui.userGroup.innerHTML = '';
        Object.keys(userPresets).forEach(name => {
            const opt = document.createElement('option');
            opt.value = `user:${name}`;
            opt.textContent = name;
            ui.userGroup.appendChild(opt);
        });
    }

    function init() {
        targetGrid = Array(N).fill().map(() => Array(N).fill(0));
        angleGrid = Array(N).fill().map(() => Array(N).fill(0));
        ui.editor.value = presets.xor;

        // Event Listeners
        window.addEventListener('resize', resize);
        
        ui.n.addEventListener('input', (e) => { 
            N = parseInt(e.target.value); 
            ui.nVal.textContent = N; 
            runCode(); 
        });
        ui.w.addEventListener('input', (e) => { 
            lineWidth = parseFloat(e.target.value); 
            ui.wVal.textContent = lineWidth.toFixed(1); 
            requestDraw(); 
        });
        
        ui.filled.addEventListener('change', (e) => { isFilled = e.target.checked; requestDraw(); });
        ui.mode.addEventListener('change', (e) => { drawMode = e.target.value; requestDraw(); });
        ui.invertFill.addEventListener('click', () => { isInvertedFill = !isInvertedFill; requestDraw(); });

        ui.select.addEventListener('change', (e) => {
            const val = e.target.value;
            if (val === 'invert') { invertGrid(); return; }
            if (val.startsWith('user:')) {
                ui.editor.value = userPresets[val.split(':')[1]];
            } else if (presets[val]) {
                ui.editor.value = presets[val];
            }
            runCode(); 
        });

        ui.runBtn.addEventListener('click', runCode);
        ui.editor.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') runCode(); });

        ui.savePresetBtn.addEventListener('click', () => {
            const name = prompt("Name your function:");
            if (name) {
                userPresets[name] = ui.editor.value;
                localStorage.setItem('truchet_user_presets', JSON.stringify(userPresets));
                updatePresetDropdown();
                ui.select.value = `user:${name}`;
            }
        });

        ui.saveImgBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `truchet-${drawMode}-${Date.now()}.png`;
            link.href = tileCanvas.toDataURL();
            link.click();
        });

        ui.saveSvgBtn.addEventListener('click', exportSVG);

        matrixCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e));
        tileCanvas.addEventListener('mousedown', (e) => handleCanvasClick(e));

        ui.infoBtn.onclick = () => ui.info.style.display = (ui.info.style.display === 'block') ? 'none' : 'block';
        ui.closeInfo.onclick = () => ui.info.style.display = 'none';

        // Animation controls
        ui.animType.addEventListener('change', (e) => {
            animType = e.target.value;
            // Reset state on change
            animProgress = -0.1; 
            animDirection = 1;
            
            if (animType === 'none') {
                stopAnimation();
                snapToTarget();
                requestDraw();
            } else {
                if(!isAnimating && ui.playBtn.textContent === "‚è∏") startAnimation(); // Auto-restart if already playing?
                // Or just ensure angles are reset
                for(let r=0; r<N; r++) for(let c=0; c<N; c++) angleGrid[r][c] = 0;
                requestDraw();
            }
        });

        ui.animSpeed.addEventListener('input', (e) => {
            animSpeedFactor = parseInt(e.target.value) / 100;
            ui.speedVal.textContent = e.target.value + '%';
        });

        ui.playBtn.addEventListener('click', toggleAnimation);
        ui.recBtn.addEventListener('click', toggleRecording);

        updatePresetDropdown();
        runCode(); 
    }

    function invertGrid() {
        for(let r=0; r<N; r++) for(let c=0; c<N; c++) targetGrid[r][c] = 1 - targetGrid[r][c];
        if (animType === 'none') snapToTarget();
        requestDraw();
    }

    function snapToTarget() {
        for(let r=0; r<N; r++) for(let c=0; c<N; c++) {
            angleGrid[r][c] = targetGrid[r][c] * (Math.PI/2);
        }
    }

    function runCode() {
        const userCode = ui.editor.value;
        ui.errorMsg.style.display = 'none';
        try {
            const genFunc = new Function('row', 'col', 'n', userCode);
            const newGrid = [];
            for (let r = 0; r < N; r++) {
                const rowArr = [];
                for (let c = 0; c < N; c++) {
                    let val = 0;
                    const result = genFunc(r, c, N);
                    if (typeof result === 'boolean') val = result ? 1 : 0;
                    else if (typeof result === 'number') val = Math.abs(Math.round(result)) % 2;
                    rowArr.push(val);
                }
                newGrid.push(rowArr);
            }
            targetGrid = newGrid;
            
            if (animType === 'none' || !isAnimating) {
                if(angleGrid.length !== N) angleGrid = Array(N).fill().map(() => Array(N).fill(0));
                snapToTarget();
            } else {
                 if(angleGrid.length !== N) angleGrid = Array(N).fill().map(() => Array(N).fill(0));
            }
            resize(); 
        } catch (err) {
            ui.errorMsg.textContent = "Error: " + err.message;
            ui.errorMsg.style.display = 'block';
        }
    }

    function resize() {
        const mWrap = document.getElementById('matrix-wrapper');
        const mSize = Math.min(mWrap.clientWidth, mWrap.clientHeight) - 10;
        matrixCanvas.width = mSize * 2; matrixCanvas.height = mSize * 2;
        matrixCanvas.style.width = `${mSize}px`; matrixCanvas.style.height = `${mSize}px`;
        mCtx.setTransform(2,0,0,2,0,0);

        const tWrap = document.getElementById('tile-wrapper');
        const tSize = Math.min(tWrap.clientWidth, tWrap.clientHeight) - 10;
        tileCanvas.width = tSize * 2; tileCanvas.height = tSize * 2;
        tileCanvas.style.width = `${tSize}px`; tileCanvas.style.height = `${tSize}px`;
        tCtx.setTransform(2,0,0,2,0,0);

        requestDraw();
    }

    /* --- ANIMATION LOGIC --- */
    
    function toggleAnimation() {
        if (isAnimating) stopAnimation(); else startAnimation();
    }

    function startAnimation() {
        if (animType === 'none') return;
        isAnimating = true;
        ui.playBtn.textContent = "‚è∏";
        animDirection = 1;
        animProgress = -0.2; // Start with a brief pause at 0
        lastTime = performance.now();
        
        // Reset angles to 0 for start of animation
        for(let r=0; r<N; r++) for(let c=0; c<N; c++) angleGrid[r][c] = 0;
        
        animationLoop();
    }

    function stopAnimation() {
        isAnimating = false;
        ui.playBtn.textContent = "‚ñ∂";
        cancelAnimationFrame(animationFrameId);
    }

    let lastTime = 0;
    function animationLoop() {
        if (!isAnimating) return;
        
        const now = performance.now();
        const dt = (now - lastTime) / 1000;
        lastTime = now;

        // Logic Speed 
        let logicSpeed = (animSpeedFactor * 1.5); 
        
        if (animDirection === -1) animProgress -= dt * logicSpeed;
        else animProgress += dt * logicSpeed;

        // "Ping-Pong" Rewind Logic for ALL modes
        // 1.2 gives a small pause at full state before rewinding
        // -0.2 gives a small pause at empty state before restarting
        if (animProgress >= 1.2) { 
            animDirection = -1; 
            animProgress = 1.2; 
        } else if (animProgress <= -0.2) {
            animDirection = 1; 
            animProgress = -0.2;
        }

        updateGridAngles(dt);
        draw();
        
        if (isRecording) updateRecTimer();
        animationFrameId = requestAnimationFrame(animationLoop);
    }

    function updateGridAngles(dt) {
        // Rotational Speed - faster than logic wave
        const rotSpeed = 5 * animSpeedFactor + 1; 

        // Use strict progress
        const t = animProgress;

        for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
                
                let shouldBeActive = false;
                
                if (animType === 'all') {
                    shouldBeActive = t > 0.1;
                } else if (animType === 'row') {
                    // Start rows slightly apart
                    const rowProg = r / N;
                    shouldBeActive = t > rowProg; // Strict inequality to help Reset
                } else if (animType === 'cell') {
                    const cellIdx = r * N + c;
                    const totalCells = N * N;
                    const cellProg = cellIdx / totalCells;
                    shouldBeActive = t > cellProg;
                } else if (animType === 'rings') {
                    const cx = (N - 1) / 2;
                    const cy = (N - 1) / 2;
                    const dist = Math.max(Math.abs(r - cy), Math.abs(c - cx));
                    const maxDist = (N / 2);
                    const ringProg = dist / maxDist;
                    shouldBeActive = t > ringProg;
                }

                // If t is negative (Rewind phase finished), force everyone inactive
                if (t < 0) shouldBeActive = false;

                let targetAngle = 0;
                if (shouldBeActive && targetGrid[r][c] === 1) {
                    targetAngle = Math.PI / 2;
                }

                const diff = targetAngle - angleGrid[r][c];
                if (Math.abs(diff) > 0.01) {
                    const move = Math.sign(diff) * rotSpeed * dt;
                    if (Math.abs(move) > Math.abs(diff)) angleGrid[r][c] = targetAngle;
                    else angleGrid[r][c] += move;
                } else {
                    angleGrid[r][c] = targetAngle;
                }
            }
        }
    }

    /* --- RECORDING --- */
    function toggleRecording() {
        if (isRecording) stopRecording(); else startRecording();
    }

    function startRecording() {
        recordedChunks = [];
        const stream = tileCanvas.captureStream(60); 
        try { mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' }); } 
        catch (e) { mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); }

        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = exportVideo;

        mediaRecorder.start();
        isRecording = true;
        recStartTime = performance.now();
        ui.recBtn.textContent = "‚èπ STOP";
        ui.recInd.style.display = 'flex';
    }

    function stopRecording() {
        if (!mediaRecorder) return;
        mediaRecorder.stop();
        isRecording = false;
        ui.recBtn.textContent = "‚è∫ REC";
        ui.recInd.style.display = 'none';
    }

    function updateRecTimer() {
        if (!isRecording) return;
        const elapsed = Math.floor((performance.now() - recStartTime) / 1000);
        const mm = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const ss = (elapsed % 60).toString().padStart(2, '0');
        ui.recTimer.textContent = `${mm}:${ss}`;
    }

    function exportVideo() {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `truchet-anim-${Date.now()}.webm`;
        document.body.appendChild(a); a.click();
        setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100);
    }

    /* --- SVG EXPORT --- */
    function exportSVG() {
        const size = 1000; // Resolution for high-quality vector output
        const cellSize = size / N;
        const half = cellSize / 2;
        
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${size} ${size}" width="${size}" height="${size}" style="background-color:black">`;
        
        const colMain = "#00d2ff"; 
        const colBg = "#111111"; 
        const lineWidthSVG = (lineWidth / (tileCanvas.width / 2 / N)) * cellSize;

        // 1. Calculate the fill parity for the logical targetGrid
        let fillColors = Array(N).fill().map(() => Array(N).fill(0));
        for(let r = 0; r < N; r++) {
            for(let c = 0; c < N; c++) {
                if(r === 0 && c === 0) { 
                    fillColors[r][c] = isInvertedFill ? 1 : 0; 
                    continue; 
                }
                // Trace parity from the previous tile (top or left)
                let pr = (c > 0) ? r : r - 1;
                let pc = (c > 0) ? c - 1 : 0;
                let same = (targetGrid[r][c] === targetGrid[pr][pc]);
                fillColors[r][c] = same ? (1 - fillColors[pr][pc]) : fillColors[pr][pc];
            }
        }

        // 2. Generate Tile Geometry
        for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
                const x = c * cellSize;
                const y = r * cellSize;
                const angDeg = targetGrid[r][c] * 90;
                
                // Group handles position and orientation
                svg += `<g transform="translate(${x}, ${y}) rotate(${angDeg}, ${half}, ${half})">`;
                
                if (isFilled) {
                    const c1 = (fillColors[r][c] === 0) ? colMain : colBg; 
                    const c2 = (fillColors[r][c] === 0) ? colBg : colMain; 
                    
                    if (drawMode === 'straight') {
                        // Background
                        svg += `<path d="M0 0 L${half} 0 L0 ${half} Z" fill="${c2}" />`;
                        svg += `<path d="M${cellSize} ${cellSize} L${cellSize} ${half} L${half} ${cellSize} Z" fill="${c2}" />`;
                        // Corridor
                        svg += `<path d="M${half} 0 L${cellSize} 0 L${cellSize} ${half} L${half} ${cellSize} L0 ${cellSize} L0 ${half} Z" fill="${c1}" />`;
                    } else {
                        // Curved Background (Sweep flag 1 = Clockwise)
                        // Top-Left corner wedge
                        svg += `<path d="M0 0 L${half} 0 A ${half} ${half} 0 0 1 0 ${half} Z" fill="${c2}" />`;
                        // Bottom-Right corner wedge
                        svg += `<path d="M${cellSize} ${cellSize} L${half} ${cellSize} A ${half} ${half} 0 0 1 ${cellSize} ${half} Z" fill="${c2}" />`;
                        
                        // Curved Corridor (Using Sweep flag 1 for both arcs to match wedges)
                        svg += `<path d="
                            M ${half} 0 
                            A ${half} ${half} 0 0 1 0 ${half} 
                            L 0 ${cellSize} 
                            L ${half} ${cellSize} 
                            A ${half} ${half} 0 0 1 ${cellSize} ${half} 
                            L ${cellSize} 0 
                            Z" fill="${c1}" />`;
                    }
                } else {
                    // Stroke Mode
                    if (drawMode === 'straight') {
                        svg += `<line x1="0" y1="${half}" x2="${half}" y2="0" stroke="${colMain}" stroke-width="${lineWidthSVG}" stroke-linecap="round" />`;
                        svg += `<line x1="${half}" y1="${cellSize}" x2="${cellSize}" y2="${half}" stroke="${colMain}" stroke-width="${lineWidthSVG}" stroke-linecap="round" />`;
                    } else {
                        svg += `<path d="M${half} 0 A ${half} ${half} 0 0 1 0 ${half}" fill="none" stroke="${colMain}" stroke-width="${lineWidthSVG}" />`;
                        svg += `<path d="M${half} ${cellSize} A ${half} ${half} 0 0 1 ${cellSize} ${half}" fill="none" stroke="${colMain}" stroke-width="${lineWidthSVG}" />`;
                    }
                }
                svg += `</g>`;
            }
        }
        svg += `</svg>`;

        const blob = new Blob([svg], {type: "image/svg+xml"});
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `truchet-static-${Date.now()}.svg`;
        link.click();
    }
    /* --- RENDERING --- */

    function requestDraw() {
        if (!isAnimating) draw();
    }

    // New Helper: Compute flood fill based on CURRENT VISUAL ANGLES
    function computeDynamicFill() {
        let fColors = Array(N).fill().map(() => Array(N).fill(0));
        
        // 1. Create a Discrete Grid Snapshot based on angles
        // If angle > 45deg, it behaves like '1', else '0'
        let currentLogicGrid = [];
        for(let r=0; r<N; r++) {
            let rowArr = [];
            for(let c=0; c<N; c++) {
                rowArr.push(angleGrid[r][c] > Math.PI/4 ? 1 : 0);
            }
            currentLogicGrid.push(rowArr);
        }

        // 2. Propagate colors
        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                if(r===0 && c===0) { fColors[r][c] = isInvertedFill ? 1 : 0; continue; }
                
                let pr, pc;
                if (c > 0) { pr = r; pc = c-1; }
                else { pr = r-1; pc = 0; }
                
                let same = (currentLogicGrid[r][c] === currentLogicGrid[pr][pc]);
                fColors[r][c] = same ? (1 - fColors[pr][pc]) : fColors[pr][pc];
            }
        }
        return fColors;
    }

    function draw() {
        // Draw Matrix (Left Side)
        const mSz = matrixCanvas.width/2;
        const mc = mSz/N;
        mCtx.fillStyle = '#050505'; mCtx.fillRect(0,0,mSz,mSz);
        
        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                const px = c*mc, py = r*mc;
                mCtx.strokeStyle = '#222'; mCtx.strokeRect(px, py, mc, mc);
                // Matrix visualizes TARGET logic
                if(targetGrid[r][c]) {
                    mCtx.fillStyle = '#111'; mCtx.fillRect(px, py, mc, mc);
                    mCtx.fillStyle = varColor(1);
                    if(mc > 12) mCtx.fillText("1", px+mc/2-3, py+mc/2+3);
                    else mCtx.fillRect(px+2, py+2, mc-4, mc-4);
                } else {
                    mCtx.fillStyle = '#333';
                    if(mc > 12) mCtx.fillText("0", px+mc/2-3, py+mc/2+3);
                }
            }
        }

        // Draw Tiling (Right Side)
        const tSz = tileCanvas.width/2;
        const tc = tSz/N;
        tCtx.fillStyle = '#000'; tCtx.fillRect(0,0,tSz,tSz);

        let fillColors = null;
        if (isFilled) {
            fillColors = computeDynamicFill();
        }

        for(let r=0; r<N; r++) {
            for(let c=0; c<N; c++) {
                const x = c*tc, y = r*tc, m = tc/2;
                const cx = x + m, cy = y + m;
                const ang = angleGrid[r][c];

                tCtx.save();
                tCtx.translate(cx, cy);
                tCtx.rotate(ang); // ROTATE CANVAS
                tCtx.translate(-cx, -cy);

                if (isFilled) {
                    drawOneFilledTile(tCtx, x, y, tc, fillColors[r][c]);
                } else {
                    drawOneStrokeTile(tCtx, x, y, tc);
                }
                
                tCtx.restore();
            }
        }
    }

    function drawOneStrokeTile(ctx, x, y, tc) {
        const m = tc/2;
        ctx.lineWidth = lineWidth;
        ctx.lineCap = drawMode === 'curved' ? 'butt' : 'round';
        ctx.strokeStyle = varColor(1); 
        ctx.beginPath();
        
        if (drawMode === 'straight') {
            ctx.moveTo(x, y+m); ctx.lineTo(x+m, y);
            ctx.moveTo(x+m, y+tc); ctx.lineTo(x+tc, y+m);
        } else {
            ctx.arc(x, y, m, 0, Math.PI/2);
            ctx.stroke(); ctx.beginPath();
            ctx.arc(x+tc, y+tc, m, Math.PI, 1.5*Math.PI);
        }
        ctx.stroke();
    }

    function drawOneFilledTile(ctx, x, y, tc, colorVal) {
        const m = tc/2;
        // High Contrast Colors
        const colMain = varColor(1); // Blue
        const colBg = '#111';        // Black/Dark Grey
        
        const c1 = colorVal === 0 ? colMain : colBg; // Corridor
        const c2 = colorVal === 0 ? colBg : colMain; // Background
        
        // 1. Draw Backgrounds (Corners)
        ctx.fillStyle = c2;
        ctx.beginPath();
        if (drawMode === 'straight') {
            ctx.moveTo(x, y); ctx.lineTo(x+m, y); ctx.lineTo(x, y+m);
            ctx.moveTo(x+tc, y+tc); ctx.lineTo(x+m, y+tc); ctx.lineTo(x+tc, y+m);
        } else {
            ctx.moveTo(x, y); ctx.arc(x, y, m, 0, Math.PI/2);
            ctx.moveTo(x+tc, y+tc); ctx.arc(x+tc, y+tc, m, Math.PI, 1.5*Math.PI);
        }
        ctx.fill();

        // 2. Draw Corridor (Foreground)
        ctx.fillStyle = c1;
        ctx.beginPath();
        if (drawMode === 'straight') {
            ctx.moveTo(x, y+m); ctx.lineTo(x, y+tc); ctx.lineTo(x+m, y+tc); 
            ctx.lineTo(x+tc, y+m); ctx.lineTo(x+tc, y); ctx.lineTo(x+m, y);
        } else {
            ctx.moveTo(x+m, y); 
            ctx.arc(x, y, m, 0, Math.PI/2); 
            ctx.lineTo(x, y+tc); 
            ctx.lineTo(x+m, y+tc);
            ctx.arc(x+tc, y+tc, m, Math.PI, 1.5*Math.PI); 
            ctx.lineTo(x+tc, y); 
            ctx.lineTo(x+m, y);
        }
        ctx.fill();
    }

    function varColor(v) { return v === 1 ? '#00d2ff' : '#007799'; }

    function handleCanvasClick(e) {
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const r = Math.floor(y * N), c = Math.floor(x * N);
        
        if(r >=0 && r < N && c >= 0 && c < N) {
            targetGrid[r][c] = 1 - targetGrid[r][c];
            if (!isAnimating) snapToTarget();
            requestDraw();
        }
    }

    init();
</script>
</body>
</html>