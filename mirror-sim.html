<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Closed mirror reflections</title>
    <style>
        :root { --accent: #00d2ff; --bg: #050505; --panel: #111; }
        body { 
            font-family: -apple-system, system-ui, sans-serif; 
            display: flex; flex-direction: column; 
            background: var(--bg); color: #fff; 
            margin: 0; height: 100vh; overflow: hidden; 
        }
        
        header { 
            background: var(--panel); padding: 8px; 
            border-bottom: 1px solid #333; 
            display: flex; flex-wrap: wrap; justify-content: center;
            gap: 8px; z-index: 10;
        }
        
        .control-group { 
            background: #1a1a1a; padding: 6px 10px; border-radius: 6px; 
            display: flex; flex-direction: column; gap: 4px; border: 1px solid #222;
            min-width: 90px;
        }

        .label-row { display: flex; justify-content: space-between; color: #888; font-size: 9px; font-weight: bold; text-transform: uppercase; }

        main { 
            flex-grow: 1; display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
            position: relative; padding: 10px; min-height: 0;
        }
        
        #canvas-container { position: relative; height: 100%; width: 100%; display: flex; justify-content: center; align-items: center; }
        canvas { 
            background: #000; border-radius: 4px; cursor: crosshair;
            box-shadow: 0 0 40px rgba(0,0,0,1);
            max-height: 100%; max-width: 100%; object-fit: contain;
        }

        #info-modal {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            background: rgba(17, 17, 17, 0.96); backdrop-filter: blur(12px);
            border: 1px solid #333; border-radius: 8px;
            width: 320px; display: none; padding: 20px; font-size: 13px; line-height: 1.6;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        #info-modal h2 { margin-top: 0; color: var(--accent); font-size: 16px; text-transform: uppercase; }
        .close-info { position: absolute; top: 10px; right: 10px; cursor: pointer; color: #666; font-size: 20px; }

        #rec-indicator {
            position: absolute; top: 20px; right: 20px; 
            background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 6px;
            display: none; align-items: center; gap: 10px; color: #fff;
            border: 1px solid #eb4d4b;
        }
        .dot { width: 10px; height: 10px; background: #eb4d4b; border-radius: 50%; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        button { 
            border: none; padding: 0 12px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; transition: 0.2s; 
            text-transform: uppercase; font-size: 10px; height: 34px; align-self: center;
        }
        .btn-fire { background: #005f73; color: #fff; }
        .btn-rec { background: #eb4d4b; color: #fff; }
        .btn-util { background: #444; color: #fff; }
        .btn-rand { background: #6c5ce7; color: #fff; }
        .btn-info { background: transparent; border: 1px solid #444; color: #888; width: 34px; padding: 0; font-size: 14px; }

        span.value { color: var(--accent); font-size: 11px; font-family: monospace; }
        input[type="range"] { width: 80px; accent-color: var(--accent); cursor: pointer; }
        select { background: #222; color: #fff; border: 1px solid #444; font-size: 11px; padding: 4px; border-radius: 4px; }
        .stats-badge { font-family: monospace; font-size: 10px; color: #00ffaa; border-left: 1px solid #333; padding-left: 10px; }
    </style>
</head>
<body>

    <header>
        <button id="info-btn" class="btn-info">?</button>

        <div class="control-group">
            <div class="label-row"><span>Shape</span></div>
            <select id="shape-select">
                <option value="ellipse">Ellipse</option>
                <option value="rectangle">Rectangle</option>
            </select>
        </div>

        <div class="control-group">
            <div class="label-row"><span>Width (a)</span> <span id="a-val" class="value">1.50</span></div>
            <input type="range" id="param-a" min="0.5" max="2.5" step="0.01" value="1.5">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Speed (2^x)</span> <span id="spd-val" class="value">1</span></div>
            <input type="range" id="param-speed-log" min="0" max="14" step="1" value="0">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Particles</span> <span id="part-val" class="value">3000</span></div>
            <input type="range" id="param-particles" min="500" max="10000" step="500" value="3000">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Precision</span> <span id="prec-val" class="value">20</span></div>
            <input type="range" id="param-precision" min="1" max="100" step="1" value="20">
        </div>

        <div class="stats-badge">REFL/S<br><span id="disp-cps">0</span></div>

        <button id="rand-btn" class="btn-rand">üé≤ Random</button>
        <button id="heatmap-btn" class="btn-util">Heatmap: ON</button>
        <button id="pause-btn" class="btn-util">Pause</button>
        <button id="fire-btn" class="btn-fire">Reset</button>
        <button id="save-btn" class="btn-util">üì∏ Save</button>
        <button id="rec-btn" class="btn-rec">‚è∫ Record</button>
        <button onclick="window.location.href='index.html'" class="btn-util" style="background:#222">üè†</button>
    </header>

    <main>
        <div id="info-modal">
            <span class="close-info" id="close-info">&times;</span>
            <h2>Optics Laboratory</h2>
            <p><strong>Billiard Dynamics:</strong> Observe how ray paths evolve within closed geometries.</p>
            <p><strong>Speed & Precision:</strong> At high speeds ($2^{14}$), increase precision to ensure particles don't "tunnel" through boundaries.</p>
            <p><strong>Tools:</strong> Use the üì∏ Save button for high-res screenshots and ‚è∫ Record to capture video with automatic timestamps.</p>
        </div>

        <div id="canvas-container">
            <canvas id="mainCanvas"></canvas>
            <div id="rec-indicator"><div class="dot"></div><span id="rec-timer">00:00</span></div>
        </div>
        <div id="status" style="font-size: 10px; color: #555; margin-top: 5px; font-family: monospace;">CLICK TO MOVE SOURCE | SNAPPING ENABLED</div>
    </main>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    let width, height, centerX, centerY, scale = 100;
    let paramA = 1.5, speed = 1, precision = 20, isPaused = false, showHeatmap = true;
    let currentShape = 'ellipse', numParticles = 3000;
    let source = { x: -0.5, y: 0 }, mouse = { x: 0, y: 0 };
    let particles = [], heatmapBins = new Float32Array(360);
    let collisionCount = 0, lastMetricTime = performance.now();
    let mediaRecorder, recordedChunks = [], recStartTime;

    const SNAP_DIST = 0.12, AXIS_SNAP = 0.06;

    const ui = {
        a: document.getElementById('param-a'), aVal: document.getElementById('a-val'),
        spd: document.getElementById('param-speed-log'), spdVal: document.getElementById('spd-val'),
        part: document.getElementById('param-particles'), partVal: document.getElementById('part-val'),
        prec: document.getElementById('param-precision'), precVal: document.getElementById('prec-val'),
        cps: document.getElementById('disp-cps'), shape: document.getElementById('shape-select'),
        info: document.getElementById('info-modal'), infoBtn: document.getElementById('info-btn'),
        recBtn: document.getElementById('rec-btn'), recInd: document.getElementById('rec-indicator'),
        recTimer: document.getElementById('rec-timer'), pauseBtn: document.getElementById('pause-btn')
    };

    function resize() {
        width = canvas.width = canvas.parentElement.clientWidth;
        height = canvas.height = canvas.parentElement.clientHeight;
        centerX = width / 2; centerY = height / 2;
        scale = Math.min((width * 0.8) / (paramA * 2), (height * 0.8) / 2);
    }

    function toScreen(x, y) { return { x: centerX + x * scale, y: centerY - y * scale }; }
    function fromScreen(sx, sy) { return { x: (sx - centerX) / scale, y: -(sy - centerY) / scale }; }

    function getSnap(px, py) {
        let fx = px, fy = py, type = 'none';
        if (Math.hypot(px, py) < SNAP_DIST) { fx = 0; fy = 0; type = 'point'; } 
        else if (currentShape === 'ellipse' && paramA > 1) {
            const c = Math.sqrt(paramA*paramA - 1);
            if (Math.hypot(px - c, py) < SNAP_DIST) { fx = c; fy = 0; type = 'point'; }
            else if (Math.hypot(px + c, py) < SNAP_DIST) { fx = -c; fy = 0; type = 'point'; }
        }
        if (type === 'none') {
            if (Math.abs(py) < AXIS_SNAP) { fy = 0; type = 'axis'; }
            if (Math.abs(px) < AXIS_SNAP) { fx = 0; type = 'axis'; }
        }
        return { x: fx, y: fy, type: type };
    }

    function checkBounds(x, y) {
        if (currentShape === 'ellipse') return (x / paramA) ** 2 + y ** 2 <= 1.001;
        return Math.abs(x) <= paramA + 0.001 && Math.abs(y) <= 1.001;
    }

    function firePulse() {
        particles = []; collisionCount = 0; heatmapBins.fill(0);
        for (let i = 0; i < numParticles; i++) {
            const angle = (Math.PI * 2 * i) / numParticles;
            particles.push({ x: source.x, y: source.y, vx: Math.cos(angle), vy: Math.sin(angle) });
        }
    }

    function updatePhysics() {
        if (isPaused) return;
        const dt = (speed * 0.001) / precision;
        for(let i=0; i<360; i++) heatmapBins[i] *= 0.985;

        for (let step = 0; step < precision; step++) {
            for (let i = 0; i < numParticles; i++) {
                let p = particles[i];
                let nx = p.x + p.vx * dt, ny = p.y + p.vy * dt;
                let collided = false;

                if (currentShape === 'ellipse') {
                    if ((nx / paramA) ** 2 + ny ** 2 >= 1.0) {
                        collided = true;
                        let normX = (2 * nx) / (paramA * paramA), normY = 2 * ny;
                        let len = Math.sqrt(normX*normX + normY*normY);
                        normX /= len; normY /= len;
                        const dot = p.vx * normX + p.vy * normY;
                        p.vx -= 2 * dot * normX; p.vy -= 2 * dot * normY;
                        const ang = Math.atan2(ny, nx / paramA);
                        p.x = paramA * Math.cos(ang) * 0.999; p.y = Math.sin(ang) * 0.999;
                    }
                } else {
                    if (Math.abs(nx) >= paramA) { collided = true; p.vx = -p.vx; p.x = (nx > 0 ? paramA : -paramA) * 0.999; p.y = ny; }
                    if (Math.abs(ny) >= 1.0) { collided = true; p.vy = -p.vy; p.y = (ny > 0 ? 1.0 : -1.0) * 0.999; if(Math.abs(p.x) < paramA) p.x = nx; }
                }

                if (collided) {
                    collisionCount++;
                    const hitAngle = Math.atan2(p.y, p.x);
                    heatmapBins[Math.floor(((hitAngle + Math.PI) / (Math.PI * 2)) * 360) % 360] += 1.0;
                } else { p.x = nx; p.y = ny; }
            }
        }
        const now = performance.now();
        if (now - lastMetricTime > 500) {
            ui.cps.textContent = Math.round((collisionCount / (now - lastMetricTime)) * 1000).toLocaleString();
            collisionCount = 0; lastMetricTime = now;
        }
    }

    function draw() {
        ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; ctx.fillRect(0, 0, width, height);
        ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(0, centerY); ctx.lineTo(width, centerY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(centerX, 0); ctx.lineTo(centerX, height); ctx.stroke();
        ctx.setLineDash([]);

        if (showHeatmap) {
            for (let i = 0; i < 360; i++) {
                const val = Math.min(heatmapBins[i] * 0.5, 255);
                if (val < 1) continue;
                const rad = (i / 360) * Math.PI * 2 - Math.PI;
                let bx, by;
                if (currentShape === 'ellipse') { bx = paramA * Math.cos(rad); by = Math.sin(rad); }
                else {
                    const tx = paramA / Math.abs(Math.cos(rad)), ty = 1.0 / Math.abs(Math.sin(rad));
                    const t = Math.min(tx, ty); bx = t * Math.cos(rad); by = t * Math.sin(rad);
                }
                const s = toScreen(bx, by);
                ctx.fillStyle = `hsla(${180 + val * 0.6}, 100%, 50%, ${Math.min(val/20, 0.8)})`;
                ctx.fillRect(s.x-2, s.y-2, 4, 4);
            }
        }

        const snapped = getSnap(mouse.x, mouse.y);
        if (snapped.type !== 'none' && checkBounds(snapped.x, snapped.y)) {
            const gui = toScreen(snapped.x, snapped.y);
            ctx.strokeStyle = 'rgba(0, 210, 255, 0.3)';
            ctx.beginPath(); ctx.arc(gui.x, gui.y, (snapped.type==='point'?12:6), 0, Math.PI*2); ctx.stroke();
        }

        ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.beginPath();
        if (currentShape === 'ellipse') ctx.ellipse(centerX, centerY, paramA * scale, 1 * scale, 0, 0, Math.PI * 2);
        else { const tl = toScreen(-paramA, 1), br = toScreen(paramA, -1); ctx.rect(tl.x, tl.y, br.x - tl.x, br.y - tl.y); }
        ctx.stroke();

        if (currentShape === 'ellipse' && paramA > 1) {
            const c = Math.sqrt(paramA*paramA - 1);
            [-c, c].forEach(fx => {
                const f = toScreen(fx, 0); ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.arc(f.x, f.y, 4, 0, Math.PI*2); ctx.fill();
            });
        }

        ctx.fillStyle = '#00d2ff'; ctx.globalCompositeOperation = 'lighter'; 
        for (let i = 0; i < numParticles; i++) {
            const s = toScreen(particles[i].x, particles[i].y);
            ctx.fillRect(s.x, s.y, 1.2, 1.2);
        }
        ctx.globalCompositeOperation = 'source-over';
        const src = toScreen(source.x, source.y);
        ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(src.x, src.y, 6, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();

        if (mediaRecorder && mediaRecorder.state === "recording") {
            const elapsed = Math.floor((performance.now() - recStartTime) / 1000);
            ui.recTimer.textContent = `${Math.floor(elapsed/60).toString().padStart(2,'0')}:${(elapsed%60).toString().padStart(2,'0')}`;
        }
    }

    function loop() { updatePhysics(); draw(); requestAnimationFrame(loop); }

    const getTimestamp = () => new Date().toISOString().replace(/[:.]/g, '-').slice(0, 16);

    function randomize() {
        // 1. Randomize Shape
        currentShape = Math.random() > 0.5 ? 'ellipse' : 'rectangle';
        ui.shape.value = currentShape;

        // 2. Param Randomization (Speed <= 2^5, Part/Prec top 50%)
        const randLogSpeed = Math.floor(Math.random() * 6); 
        const randParticles = 5250 + Math.floor(Math.random() * 4751); 
        const randPrecision = 51 + Math.floor(Math.random() * 50); 
        const randA = 0.5 + Math.random() * 2.0;

        ui.spd.value = randLogSpeed;
        ui.part.value = randParticles;
        ui.prec.value = randPrecision;
        ui.a.value = randA;

        speed = Math.pow(2, randLogSpeed); ui.spdVal.textContent = speed;
        numParticles = randParticles; ui.partVal.textContent = numParticles;
        precision = randPrecision; ui.precVal.textContent = precision;
        paramA = randA; ui.aVal.textContent = paramA.toFixed(2);
        
        resize();

        // 3. Position Randomization (Biased Regions)
        const region = Math.floor(Math.random() * 6);
        let rx = 0, ry = 0;

        switch(region) {
            case 0: // Focal Point (or focal-analogue for Rect)
                if (currentShape === 'ellipse' && paramA > 1) {
                    const c = Math.sqrt(paramA*paramA - 1);
                    rx = Math.random() > 0.5 ? c : -c; ry = 0;
                } else { rx = (Math.random() > 0.5 ? 0.4 : -0.4) * paramA; ry = 0; }
                break;
            case 1: // Center
                rx = 0; ry = 0;
                break;
            case 2: // On one of the axes
                if (Math.random() > 0.5) { rx = (Math.random()*2-1)*paramA; ry = 0; }
                else { rx = 0; ry = Math.random()*2-1; }
                break;
            case 3: // Edge where axes meet (Vertices)
                const coin = Math.random();
                if (coin < 0.25) { rx = paramA; ry = 0; }
                else if (coin < 0.5) { rx = -paramA; ry = 0; }
                else if (coin < 0.75) { rx = 0; ry = 1; }
                else { rx = 0; ry = -1; }
                break;
            case 4: // Any point on the edge
                const angle = Math.random() * Math.PI * 2;
                if (currentShape === 'ellipse') { rx = paramA * Math.cos(angle); ry = Math.sin(angle); }
                else {
                    const side = Math.floor(Math.random() * 4);
                    const t = Math.random() * 2 - 1;
                    if (side === 0) { rx = paramA; ry = t; }
                    else if (side === 1) { rx = -paramA; ry = t; }
                    else if (side === 2) { rx = t * paramA; ry = 1; }
                    else { rx = t * paramA; ry = -1; }
                }
                break;
            case 5: // Any internal point
                do {
                    rx = (Math.random() * 2 - 1) * paramA;
                    ry = Math.random() * 2 - 1;
                } while (!checkBounds(rx, ry));
                break;
        }

        source.x = rx; source.y = ry;
        firePulse();
    }

    ui.infoBtn.onclick = () => { ui.info.style.display = (ui.info.style.display === 'block') ? 'none' : 'block'; };
    document.getElementById('close-info').onclick = () => ui.info.style.display = 'none';
    document.getElementById('rand-btn').onclick = randomize;
    
    document.getElementById('save-btn').onclick = () => {
        const preSavePaused = isPaused;
        isPaused = true;
        requestAnimationFrame(() => {
            const link = document.createElement('a');
            link.download = `optics-${getTimestamp()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            if (!preSavePaused) isPaused = false;
        });
    };

    document.getElementById('rec-btn').onclick = () => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.stop(); ui.recBtn.textContent = "‚è∫ Record"; ui.recInd.style.display = 'none';
        } else {
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(canvas.captureStream(60), { mimeType: 'video/webm' });
            mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
            mediaRecorder.onstop = () => {
                const b = new Blob(recordedChunks, { type: 'video/webm' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `optics-${getTimestamp()}.webm`; a.click();
            };
            recStartTime = performance.now(); mediaRecorder.start();
            ui.recBtn.textContent = "‚èπ Stop"; ui.recInd.style.display = 'flex';
        }
    };

    ui.pauseBtn.onclick = (e) => { isPaused = !isPaused; e.target.textContent = isPaused ? 'Resume' : 'Pause'; };
    document.getElementById('fire-btn').onclick = firePulse;
    document.getElementById('heatmap-btn').onclick = (e) => { showHeatmap = !showHeatmap; e.target.textContent = `Heatmap: ${showHeatmap ? 'ON' : 'OFF'}`; };
    ui.shape.onchange = (e) => { currentShape = e.target.value; firePulse(); };
    ui.a.oninput = (e) => { paramA = parseFloat(e.target.value); ui.aVal.textContent = paramA.toFixed(2); resize(); firePulse(); };
    ui.spd.oninput = (e) => { speed = Math.pow(2, parseInt(e.target.value)); ui.spdVal.textContent = speed.toLocaleString(); };
    ui.part.oninput = (e) => { numParticles = parseInt(e.target.value); ui.partVal.textContent = numParticles; firePulse(); };
    ui.prec.oninput = (e) => { precision = parseInt(e.target.value); ui.precVal.textContent = precision; };

    canvas.onmousemove = (e) => {
        const rect = canvas.getBoundingClientRect();
        const sim = fromScreen(e.clientX - rect.left, e.clientY - rect.top);
        mouse.x = sim.x; mouse.y = sim.y;
    };
    canvas.onmousedown = () => {
        const snapped = getSnap(mouse.x, mouse.y);
        if(checkBounds(snapped.x, snapped.y)) { source.x = snapped.x; source.y = snapped.y; firePulse(); }
    };

    window.onresize = resize;
    resize(); firePulse(); loop();
</script>
</body>
</html>