<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Closed mirror reflections</title>
    <style>
        :root { --accent: #00d2ff; --bg: #050505; --panel: #111; }
        body { 
            font-family: -apple-system, system-ui, sans-serif; 
            display: flex; flex-direction: column; 
            background: var(--bg); color: #fff; 
            margin: 0; height: 100vh; overflow: hidden; 
        }
        
        header { 
            background: var(--panel); padding: 8px; 
            border-bottom: 1px solid #333; 
            display: flex; flex-wrap: wrap; justify-content: center;
            gap: 8px; z-index: 10;
        }
        
        .control-group { 
            background: #1a1a1a; padding: 6px 10px; border-radius: 6px; 
            display: flex; flex-direction: column; gap: 4px; border: 1px solid #222;
            min-width: 90px;
        }

        .label-row { display: flex; justify-content: space-between; color: #888; font-size: 9px; font-weight: bold; text-transform: uppercase; }

        main { 
            flex-grow: 1; display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
            position: relative; padding: 10px; min-height: 0;
        }
        
        #canvas-container { position: relative; height: 100%; width: 100%; display: flex; justify-content: center; align-items: center; }
        canvas { 
            background: #000; border-radius: 4px; cursor: crosshair;
            box-shadow: 0 0 40px rgba(0,0,0,1);
            max-height: 100%; max-width: 100%; object-fit: contain;
        }

        #info-modal {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            background: rgba(17, 17, 17, 0.96); backdrop-filter: blur(12px);
            border: 1px solid #333; border-radius: 8px;
            width: 320px; display: none; padding: 20px; font-size: 13px; line-height: 1.6;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        #info-modal h2 { margin-top: 0; color: var(--accent); font-size: 16px; text-transform: uppercase; }
        .close-info { position: absolute; top: 10px; right: 10px; cursor: pointer; color: #666; font-size: 20px; }

        #rec-indicator {
            position: absolute; top: 20px; right: 20px; 
            background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 6px;
            display: none; align-items: center; gap: 10px; color: #fff;
            border: 1px solid #eb4d4b;
        }
        .dot { width: 10px; height: 10px; background: #eb4d4b; border-radius: 50%; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        button { 
            border: none; padding: 0 12px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; transition: 0.2s; 
            text-transform: uppercase; font-size: 10px; height: 34px; align-self: center;
        }
        .btn-fire { background: #005f73; color: #fff; }
        .btn-rec { background: #eb4d4b; color: #fff; }
        .btn-util { background: #444; color: #fff; }
        .btn-rand { background: #6c5ce7; color: #fff; }
        .btn-audio { background: #d63031; color: #fff; width: 34px; font-size: 14px; }
        .btn-audio.active { background: #00b894; }
        .btn-info { background: transparent; border: 1px solid #444; color: #888; width: 34px; padding: 0; font-size: 14px; }

        span.value { color: var(--accent); font-size: 11px; font-family: monospace; }
        input[type="range"] { width: 80px; accent-color: var(--accent); cursor: pointer; }
        select { background: #222; color: #fff; border: 1px solid #444; font-size: 11px; padding: 4px; border-radius: 4px; }
        .stats-badge { font-family: monospace; font-size: 10px; color: #00ffaa; border-left: 1px solid #333; padding-left: 10px; }
    </style>
</head>
<body>

    <header>
        <button id="info-btn" class="btn-info">?</button>

        <div class="control-group">
            <div class="label-row"><span>Shape</span></div>
            <select id="shape-select">
                <option value="ellipse">Ellipse</option>
                <option value="rectangle">Rectangle</option>
            </select>
        </div>

        <div class="control-group">
            <div class="label-row"><span>Width (a)</span> <span id="a-val" class="value">1.50</span></div>
            <input type="range" id="param-a" min="-1" max="1" step="0.01" value="0.176" list="a-markers">
            <datalist id="a-markers"><option value="0"></option></datalist>
        </div>

        <div class="control-group">
            <div class="label-row"><span>Speed (2^x)</span> <span id="spd-val" class="value">1</span></div>
            <input type="range" id="param-speed-log" min="0" max="14" step="1" value="0">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Particles</span> <span id="part-val" class="value">3000</span></div>
            <input type="range" id="param-particles" min="500" max="10000" step="500" value="3000">
        </div>

        <div class="control-group">
            <div class="label-row"><span>Precision</span> <span id="prec-val" class="value">20</span></div>
            <input type="range" id="param-precision" min="1" max="100" step="1" value="20">
        </div>

        <div class="stats-badge">REFL/S<br><span id="disp-cps">0</span></div>

        <button id="audio-btn" class="btn-audio">üîá</button>
        <div class="control-group">
            <div class="label-row"><span>Audio Scale</span></div>
            <select id="scale-select">
                <option value="minorPentatonic">D Minor Pentatonic</option>
                <option value="lydian">C Lydian (Cosmic)</option>
                <option value="phrygian">E Phrygian (Ancient)</option>
                <option value="wholeTone">Whole Tone (Dream)</option>
                <option value="justIntonation">Harmonic Pure</option>
            </select>
        </div>
        <button id="rand-btn" class="btn-rand">üé≤ Random</button>
        <button id="heatmap-btn" class="btn-util">Heatmap: ON</button>
        <button id="pause-btn" class="btn-util">Pause</button>
        <button id="fire-btn" class="btn-fire">Reset</button>
        <button id="save-btn" class="btn-util">üì∏ Save</button>
        <button id="rec-btn" class="btn-rec">‚è∫ Record</button>
        <button onclick="window.location.href='index.html'" class="btn-util" style="background:#222">üè†</button>
    </header>

    <main>
        <div id="info-modal">
            <span class="close-info" id="close-info">&times;</span>
            <h2>Optics Laboratory</h2>
            <p><strong>Billiard Dynamics:</strong> Observe how ray paths evolve within closed geometries.</p>
            <p><strong>Stereo Audio:</strong> Impact locations drive a harmonic bank of resonant filters. Left impacts pan left, right impacts pan right.</p>
            <p><strong>Tools:</strong> Use the üì∏ Save button for high-res screenshots and ‚è∫ Record to capture video with automatic timestamps.</p>
        </div>

        <div id="canvas-container">
            <canvas id="mainCanvas"></canvas>
            <div id="rec-indicator"><div class="dot"></div><span id="rec-timer">00:00</span></div>
        </div>
        <div id="status" style="font-size: 10px; color: #555; margin-top: 5px; font-family: monospace;">CLICK TO MOVE SOURCE | SNAPPING ENABLED</div>
    </main>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    let width, height, centerX, centerY, scale = 100;
    let paramA = 1.5, speed = 1, precision = 20, isPaused = false, showHeatmap = true;
    let currentShape = 'ellipse', numParticles = 3000;
    let source = { x: -0.5, y: 0 }, mouse = { x: 0, y: 0 };
    let particles = [], heatmapBins = new Float32Array(360);
    let collisionCount = 0, lastMetricTime = performance.now();
    let mediaRecorder, recordedChunks = [], recStartTime;

    // Audio Engine State
    let audioCtx, masterGain, panner, audioEnabled = false;
    let resonanceFilters = [];
    let collisionDensity = { left: 0, right: 0, top: 0, bottom: 0 };

    let audioStreamDest;

    const SNAP_DIST = 0.12, AXIS_SNAP = 0.06;

    const ui = {
        a: document.getElementById('param-a'), aVal: document.getElementById('a-val'),
        spd: document.getElementById('param-speed-log'), spdVal: document.getElementById('spd-val'),
        part: document.getElementById('param-particles'), partVal: document.getElementById('part-val'),
        prec: document.getElementById('param-precision'), precVal: document.getElementById('prec-val'),
        cps: document.getElementById('disp-cps'), shape: document.getElementById('shape-select'),
        info: document.getElementById('info-modal'), infoBtn: document.getElementById('info-btn'),
        recBtn: document.getElementById('rec-btn'), recInd: document.getElementById('rec-indicator'),
        recTimer: document.getElementById('rec-timer'), pauseBtn: document.getElementById('pause-btn'),
        audioBtn: document.getElementById('audio-btn')
    };

    // Define the frequency sets
    const scaleLibrary = {
        minorPentatonic: [146.83, 174.61, 220.00, 261.63, 293.66, 349.23],
        lydian: [130.81, 146.83, 164.81, 185.00, 196.00, 220.00],
        phrygian: [164.81, 174.61, 207.65, 220.00, 246.94, 261.63],
        wholeTone: [130.81, 146.83, 164.81, 185.00, 207.65, 233.08],
        justIntonation: [110.00, 123.75, 137.50, 165.00, 185.63, 220.00]
    };

    // Listener for the dropdown
    document.getElementById('scale-select').onchange = (e) => {
        const newScale = scaleLibrary[e.target.value];
        if (resonanceFilters.length > 0) {
            newScale.forEach((freq, i) => {
                // Smoothly glide to the new frequencies (Portamento)
                resonanceFilters[i].osc.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.2);
                resonanceFilters[i].filter.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.2);
            });
        }
    };

    /**
     * AUDIO SYSTEM INITIALIZATION
     */
    function initAudio() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Create a destination specifically for the recorder
        audioStreamDest = audioCtx.createMediaStreamDestination();

        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.4;

        panner = audioCtx.createStereoPanner();
        // Connect panner to BOTH the speakers and the recorder destination
        panner.connect(audioCtx.destination);
        panner.connect(audioStreamDest);

        masterGain.connect(panner);

        // Harmonic scale: D Minor Pentatonic (Glassy resonance)
        const freqs = [146.83, 174.61, 220.00, 261.63, 293.66, 349.23];
        
        freqs.forEach((f, i) => {
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            osc.type = i % 2 === 0 ? 'sine' : 'triangle';
            osc.frequency.value = f;
            
            filter.type = 'bandpass';
            filter.frequency.value = f;
            filter.Q.value = 25; 

            g.gain.value = 0;
            osc.connect(filter);
            filter.connect(g);
            g.connect(masterGain);
            osc.start();
            
            resonanceFilters.push({ osc: osc, gain: g, filter });
        });
    }

    function updateAudio() {
        // If audio is disabled OR the simulation is paused, silence the resonators
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const isSilenced = !audioEnabled || isPaused;

        if (isSilenced) {
            resonanceFilters.forEach(f => {
                f.gain.gain.setTargetAtTime(0, now, 0.05);
            });
            return; // Stop processing pan and energy calculations
        }

        // Standard spatial audio logic follows...
        const totalHits = collisionDensity.left + collisionDensity.right + 0.001;
        const panVal = (collisionDensity.right - collisionDensity.left) / totalHits;
        panner.pan.setTargetAtTime(Math.max(-1, Math.min(1, panVal)), now, 0.1);

        const energies = [
            collisionDensity.left,
            (collisionDensity.left + collisionDensity.top) / 2,
            collisionDensity.top,
            collisionDensity.bottom,
            (collisionDensity.right + collisionDensity.bottom) / 2,
            collisionDensity.right
        ];

        energies.forEach((energy, i) => {
            const vol = Math.min(energy / (numParticles * 0.1), 0.3);
            resonanceFilters[i].gain.gain.setTargetAtTime(vol, now, 0.05);
            resonanceFilters[i].filter.Q.setTargetAtTime(15 + vol * 80, now, 0.1);
        });

        collisionDensity.left *= 0.8; collisionDensity.right *= 0.8;
        collisionDensity.top *= 0.8; collisionDensity.bottom *= 0.8;
    }

    function resize() {
        width = canvas.width = canvas.parentElement.clientWidth;
        height = canvas.height = canvas.parentElement.clientHeight;
        centerX = width / 2; centerY = height / 2;
        scale = Math.min((width * 0.8) / (paramA * 2), (height * 0.8) / 2);
    }

    function toScreen(x, y) { return { x: centerX + x * scale, y: centerY - y * scale }; }
    function fromScreen(sx, sy) { return { x: (sx - centerX) / scale, y: -(sy - centerY) / scale }; }

    function getSnap(px, py) {
        let fx = px, fy = py, type = 'none';
        if (Math.hypot(px, py) < SNAP_DIST) { fx = 0; fy = 0; type = 'point'; } 
        else if (currentShape === 'ellipse') {
            // SNAP TO FOCI
            if (paramA > 1) { // Horizontal Ellipse
                const c = Math.sqrt(paramA*paramA - 1);
                if (Math.hypot(px - c, py) < SNAP_DIST) { fx = c; fy = 0; type = 'point'; }
                else if (Math.hypot(px + c, py) < SNAP_DIST) { fx = -c; fy = 0; type = 'point'; }
            } else if (paramA < 1) { // Vertical Ellipse
                const c = Math.sqrt(1 - paramA*paramA);
                if (Math.hypot(px, py - c) < SNAP_DIST) { fx = 0; fy = c; type = 'point'; }
                else if (Math.hypot(px, py + c) < SNAP_DIST) { fx = 0; fy = -c; type = 'point'; }
            }
        }
        if (type === 'none') {
            if (Math.abs(py) < AXIS_SNAP) { fy = 0; type = 'axis'; }
            if (Math.abs(px) < AXIS_SNAP) { fx = 0; type = 'axis'; }
        }
        return { x: fx, y: fy, type: type };
    }

    function checkBounds(x, y) {
        if (currentShape === 'ellipse') return (x / paramA) ** 2 + y ** 2 <= 1.001;
        return Math.abs(x) <= paramA + 0.001 && Math.abs(y) <= 1.001;
    }

    function firePulse() {
        particles = []; collisionCount = 0; heatmapBins.fill(0);
        for (let i = 0; i < numParticles; i++) {
            const angle = (Math.PI * 2 * i) / numParticles;
            particles.push({ x: source.x, y: source.y, vx: Math.cos(angle), vy: Math.sin(angle) });
        }
    }

    function updatePhysics() {
        if (isPaused) return;
        const dt = (speed * 0.001) / precision;
        for(let i=0; i<360; i++) heatmapBins[i] *= 0.985;

        for (let step = 0; step < precision; step++) {
            for (let i = 0; i < numParticles; i++) {
                let p = particles[i];
                let nx = p.x + p.vx * dt, ny = p.y + p.vy * dt;
                let collided = false;

                if (currentShape === 'ellipse') {
                    if ((nx / paramA) ** 2 + ny ** 2 >= 1.0) {
                        collided = true;
                        let normX = (2 * nx) / (paramA * paramA), normY = 2 * ny;
                        let len = Math.sqrt(normX*normX + normY*normY);
                        normX /= len; normY /= len;
                        const dot = p.vx * normX + p.vy * normY;
                        p.vx -= 2 * dot * normX; p.vy -= 2 * dot * normY;
                        const ang = Math.atan2(ny, nx / paramA);
                        p.x = paramA * Math.cos(ang) * 0.999; p.y = Math.sin(ang) * 0.999;
                    }
                } else {
                    if (Math.abs(nx) >= paramA) { collided = true; p.vx = -p.vx; p.x = (nx > 0 ? paramA : -paramA) * 0.999; p.y = ny; }
                    if (Math.abs(ny) >= 1.0) { collided = true; p.vy = -p.vy; p.y = (ny > 0 ? 1.0 : -1.0) * 0.999; if(Math.abs(p.x) < paramA) p.x = nx; }
                }

                if (collided) {
                    collisionCount++;

                    // Calculate velocity magnitude (hypotenuse of vx and vy)
                    const impactVelocity = Math.sqrt(p.vx * p.vx + p.vy * p.vy);

                    // Add the kinetic energy to the buffer instead of just '1'
                    if (p.x < 0) collisionDensity.left += impactVelocity; 
                    else collisionDensity.right += impactVelocity;
                    
                    if (p.y > 0) collisionDensity.top += impactVelocity; 
                    else collisionDensity.bottom += impactVelocity;

                    const hitAngle = Math.atan2(p.y, p.x);
                    heatmapBins[Math.floor(((hitAngle + Math.PI) / (Math.PI * 2)) * 360) % 360] += 1.0;
                } else { p.x = nx; p.y = ny; }
            }
        }
        const now = performance.now();
        if (now - lastMetricTime > 500) {
            ui.cps.textContent = Math.round((collisionCount / (now - lastMetricTime)) * 1000).toLocaleString();
            collisionCount = 0; lastMetricTime = now;
        }
    }

    function draw() {
        updateAudio();
        ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; ctx.fillRect(0, 0, width, height);
        ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(0, centerY); ctx.lineTo(width, centerY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(centerX, 0); ctx.lineTo(centerX, height); ctx.stroke();
        ctx.setLineDash([]);

        if (showHeatmap) {
            for (let i = 0; i < 360; i++) {
                const val = Math.min(heatmapBins[i] * 0.5, 255);
                if (val < 1) continue;
                const rad = (i / 360) * Math.PI * 2 - Math.PI;
                let bx, by;
                if (currentShape === 'ellipse') { bx = paramA * Math.cos(rad); by = Math.sin(rad); }
                else {
                    const tx = paramA / Math.abs(Math.cos(rad)), ty = 1.0 / Math.abs(Math.sin(rad));
                    const t = Math.min(tx, ty); bx = t * Math.cos(rad); by = t * Math.sin(rad);
                }
                const s = toScreen(bx, by);
                ctx.fillStyle = `hsla(${180 + val * 0.6}, 100%, 50%, ${Math.min(val/20, 0.8)})`;
                ctx.fillRect(s.x-2, s.y-2, 4, 4);
            }
        }

        const snapped = getSnap(mouse.x, mouse.y);
        if (snapped.type !== 'none' && checkBounds(snapped.x, snapped.y)) {
            const gui = toScreen(snapped.x, snapped.y);
            ctx.strokeStyle = 'rgba(0, 210, 255, 0.3)';
            ctx.beginPath(); ctx.arc(gui.x, gui.y, (snapped.type==='point'?12:6), 0, Math.PI*2); ctx.stroke();
        }

        ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.beginPath();
        if (currentShape === 'ellipse') ctx.ellipse(centerX, centerY, paramA * scale, 1 * scale, 0, 0, Math.PI * 2);
        else { const tl = toScreen(-paramA, 1), br = toScreen(paramA, -1); ctx.rect(tl.x, tl.y, br.x - tl.x, br.y - tl.y); }
        ctx.stroke();

        if (currentShape === 'ellipse') {
            // DRAW FOCI
            let foci = [];
            if (paramA > 1) {
                const c = Math.sqrt(paramA*paramA - 1);
                foci = [{x: -c, y: 0}, {x: c, y: 0}];
            } else if (paramA < 1) {
                const c = Math.sqrt(1 - paramA*paramA);
                foci = [{x: 0, y: -c}, {x: 0, y: c}];
            }
            
            foci.forEach(f => {
                const s = toScreen(f.x, f.y); 
                ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.arc(s.x, s.y, 4, 0, Math.PI*2); ctx.fill();
            });
        }

        ctx.fillStyle = '#00d2ff'; ctx.globalCompositeOperation = 'lighter'; 
        for (let i = 0; i < numParticles; i++) {
            const s = toScreen(particles[i].x, particles[i].y);
            ctx.fillRect(s.x, s.y, 1.2, 1.2);
        }
        ctx.globalCompositeOperation = 'source-over';
        const src = toScreen(source.x, source.y);
        ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(src.x, src.y, 6, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();

        if (mediaRecorder && mediaRecorder.state === "recording") {
            const elapsed = Math.floor((performance.now() - recStartTime) / 1000);
            ui.recTimer.textContent = `${Math.floor(elapsed/60).toString().padStart(2,'0')}:${(elapsed%60).toString().padStart(2,'0')}`;
        }
    }

    function loop() { updatePhysics(); draw(); requestAnimationFrame(loop); }

    const getTimestamp = () => new Date().toISOString().replace(/[:.]/g, '-').slice(0, 16);

    function randomize() {
        // 1. Randomize Shape
        currentShape = Math.random() > 0.5 ? 'ellipse' : 'rectangle';
        ui.shape.value = currentShape;

        // 2. Param Randomization (Speed <= 2^5, Part/Prec top 50%)
        const randLogSpeed = Math.floor(Math.random() * 6); 
        const randParticles = 5250 + Math.floor(Math.random() * 4751); 
        const randPrecision = 51 + Math.floor(Math.random() * 50); 
        
        // Randomize 'a' in the Logarithmic Domain (-1 to 1)
        const randLogA = (Math.random() * 2) - 1; 
        const randA = Math.pow(10, randLogA); // Converts -1..1 to 0.1..10

        ui.spd.value = randLogSpeed;
        ui.part.value = randParticles;
        ui.prec.value = randPrecision;
        
        // Update UI Slider (Log value) and Text (Actual value)
        ui.a.value = randLogA; 
        ui.aVal.textContent = randA.toFixed(2);
        paramA = randA;

        speed = Math.pow(2, randLogSpeed); ui.spdVal.textContent = speed;
        numParticles = randParticles; ui.partVal.textContent = numParticles;
        precision = randPrecision; ui.precVal.textContent = precision;
        
        resize();

        // 3. Position Randomization (Biased Regions)
        const region = Math.floor(Math.random() * 6);
        let rx = 0, ry = 0;

        switch(region) {
            case 0: if (currentShape === 'ellipse' && paramA > 1) { const c = Math.sqrt(paramA*paramA-1); rx = Math.random()>0.5?c:-c; ry=0; } else { rx=(Math.random()>0.5?0.4:-0.4)*paramA; ry=0; } break;
            case 1: rx = 0; ry = 0; break;
            case 2: if (Math.random() > 0.5) { rx = (Math.random()*2-1)*paramA; ry = 0; } else { rx = 0; ry = Math.random()*2-1; } break;
            case 3: const coin = Math.random(); if (coin < 0.25) { rx = paramA; ry = 0; } else if (coin < 0.5) { rx = -paramA; ry = 0; } else if (coin < 0.75) { rx = 0; ry = 1; } else { rx = 0; ry = -1; } break;
            case 4: const angle = Math.random() * Math.PI * 2; if (currentShape === 'ellipse') { rx = paramA * Math.cos(angle); ry = Math.sin(angle); } else { const side = Math.floor(Math.random() * 4); const t = Math.random() * 2 - 1; if (side === 0) { rx = paramA; ry = t; } else if (side === 1) { rx = -paramA; ry = t; } else if (side === 2) { rx = t * paramA; ry = 1; } else { rx = t * paramA; ry = -1; } } break;
            case 5: do { rx = (Math.random() * 2 - 1) * paramA; ry = Math.random() * 2 - 1; } while (!checkBounds(rx, ry)); break;
        }
        source.x = rx; source.y = ry; firePulse();
    }

    ui.infoBtn.onclick = () => { ui.info.style.display = (ui.info.style.display === 'block') ? 'none' : 'block'; };
    document.getElementById('close-info').onclick = () => ui.info.style.display = 'none';
    document.getElementById('rand-btn').onclick = randomize;
    
    document.getElementById('save-btn').onclick = () => {
        const preSavePaused = isPaused;
        isPaused = true;
        requestAnimationFrame(() => {
            const link = document.createElement('a');
            link.download = `mirror-sim-${getTimestamp()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            if (!preSavePaused) isPaused = false;
        });
    };

    document.getElementById('rec-btn').onclick = () => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.stop(); 
            ui.recBtn.textContent = "‚è∫ Record"; 
            ui.recInd.style.display = 'none';
        } else {
            recordedChunks = [];
            
            // 1. Capture the visual stream (60fps)
            const videoStream = canvas.captureStream(60);
            
            // 2. Combine with Audio (if initialized)
            let combinedStream;
            if (audioCtx && audioStreamDest) {
                combinedStream = new MediaStream([
                    ...videoStream.getVideoTracks(),
                    ...audioStreamDest.stream.getAudioTracks()
                ]);
            } else {
                combinedStream = videoStream;
            }
            
            // 3. Set High-Quality WebM options with Opus audio
            const options = {
                mimeType: 'video/webm;codecs=vp9,opus',
                videoBitsPerSecond: 15000000, // 15Mbps
                audioBitsPerSecond: 128000    // High quality audio bitrate
            };

            // Fallback for browsers that don't support VP9/Opus
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm';
            }

            mediaRecorder = new MediaRecorder(combinedStream, options);
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const b = new Blob(recordedChunks, { type: 'video/webm' });
                const a = document.createElement('a'); 
                a.href = URL.createObjectURL(b); 
                a.download = `mirror-sim-${getTimestamp()}.webm`; 
                a.click();
            };

            recStartTime = performance.now(); 
            mediaRecorder.start(100); 
            ui.recBtn.textContent = "‚èπ Stop"; 
            ui.recInd.style.display = 'flex';
        }
    };

    ui.audioBtn.onclick = () => {
        if (!audioCtx) initAudio();
        audioEnabled = !audioEnabled;
        
        // Smoothly ramp master volume to 0 or 0.4 to prevent "popping"
        const targetMaster = audioEnabled ? 0.4 : 0;
        masterGain.gain.setTargetAtTime(targetMaster, audioCtx.currentTime, 0.1);
        
        ui.audioBtn.textContent = audioEnabled ? 'üîä' : 'üîá';
        ui.audioBtn.classList.toggle('active', audioEnabled);
        if (audioCtx.state === 'suspended') audioCtx.resume();
    };

    ui.pauseBtn.onclick = (e) => { 
        isPaused = !isPaused; 
        e.target.textContent = isPaused ? 'Resume' : 'Pause'; 
    };
    document.getElementById('fire-btn').onclick = firePulse;
    document.getElementById('heatmap-btn').onclick = (e) => { showHeatmap = !showHeatmap; e.target.textContent = `Heatmap: ${showHeatmap ? 'ON' : 'OFF'}`; };
    ui.shape.onchange = (e) => { currentShape = e.target.value; firePulse(); };
    
    // Logarithmic Slider Logic
    ui.a.oninput = (e) => { 
        const logVal = parseFloat(e.target.value);
        paramA = Math.pow(10, logVal); 
        ui.aVal.textContent = paramA.toFixed(2); 
        resize(); firePulse(); 
    };

    ui.spd.oninput = (e) => { speed = Math.pow(2, parseInt(e.target.value)); ui.spdVal.textContent = speed.toLocaleString(); };
    ui.part.oninput = (e) => { numParticles = parseInt(e.target.value); ui.partVal.textContent = numParticles; firePulse(); };
    ui.prec.oninput = (e) => { precision = parseInt(e.target.value); ui.precVal.textContent = precision; };

    canvas.onmousemove = (e) => {
        const rect = canvas.getBoundingClientRect();
        const sim = fromScreen(e.clientX - rect.left, e.clientY - rect.top);
        mouse.x = sim.x; mouse.y = sim.y;
    };
    canvas.onmousedown = () => {
        const snapped = getSnap(mouse.x, mouse.y);
        if(checkBounds(snapped.x, snapped.y)) { source.x = snapped.x; source.y = snapped.y; firePulse(); }
    };

    window.onresize = resize;
    resize(); firePulse(); loop();
</script>
</body>
</html>