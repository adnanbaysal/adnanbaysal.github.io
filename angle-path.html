<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angle Path Generator</title>
    <style>
        :root { 
            --accent: #00d2ff; 
            --bg: #050505; 
            --panel: #111; 
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; 
            display: flex; 
            flex-direction: column; 
            background: var(--bg); 
            color: #fff; 
            margin: 0; 
            height: 100vh; 
            overflow: hidden; 
        }
        
        /* --- Header UI --- */
        header { 
            background: var(--panel); 
            padding: 10px; 
            border-bottom: 1px solid #333; 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center;
            align-items: stretch;
            gap: 10px; 
            z-index: 10;
        }

        /* --- Advanced Toggle Button --- */
        #adv-toggle-btn {
            display: none; /* Hidden on desktop */
            margin-top: 10px; 
            width: 100%;
        }
        
        .control-group { 
            background: #1a1a1a; 
            padding: 10px 12px; 
            border-radius: 6px; 
            display: flex; 
            flex-direction: column; 
            border: 1px solid #222;
            min-width: 160px; 
            flex-grow: 1; 
            max-width: 240px;
        }

        #advanced-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .collapsed {
            display: none !important;
        }

        /* --- Rigid 2-Row Toolbar --- */
        .toolbar-group {
            display: grid;
            grid-template-columns: repeat(4, 1fr); 
            grid-template-rows: repeat(2, 34px);    
            gap: 6px;
            background: #1a1a1a; 
            padding: 10px; 
            border-radius: 6px; 
            border: 1px solid #222;
            min-width: 240px; 
            align-content: center;
        }

        .group-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            color: #aaa; 
            font-size: 10px; 
            font-weight: bold; 
            text-transform: uppercase; 
            margin-bottom: 8px;
        }
        
        .group-header .num-input { 
            width: 75px; 
            text-align: right; 
            padding: 3px 6px; 
            height: auto; 
        }
        
        .slider-row { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            margin-bottom: 6px; 
        }

        .slider-row input[type="range"] { 
            flex-grow: 1; 
            width: 100%; 
            margin: 0; 
        }

        .toggles-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            font-size: 9px; 
            color: var(--accent); 
            font-weight: bold; 
            margin-top: auto;
            padding-top: 6px; 
            min-height: 14px;
        }

        .toggles-row label { 
            display: flex; 
            align-items: center; 
            gap: 4px; 
            cursor: pointer; 
            margin: 0; 
        }

        .toggles-row input[type="checkbox"] { 
            margin: 0; 
            cursor: pointer; 
        }

        /* --- Animation Settings UI --- */
        .anim-settings { 
            display: flex !important; 
            justify-content: space-between; 
            gap: 8px; 
            margin-top: 8px; 
            border-top: 1px dashed #333; 
            padding-top: 8px; 
            transition: opacity 0.2s ease;
        }

        .control-group:has(input[type="checkbox"][id$="-anim"]:not(:checked)) .anim-settings {
            opacity: 0.25; 
            pointer-events: none;
        }
        
        .control-group:has(input[type="checkbox"][id$="-anim"]:not(:checked)) .anim-settings input {
            background: #111; 
            border-color: #333; 
            color: #666;
        }

        .anim-settings label { 
            font-size: 9px; 
            color: #888; 
            display: flex; 
            flex-direction: column; 
            gap: 4px;
            font-weight: bold; 
            text-transform: uppercase; 
            flex-grow: 1;
        }

        .anim-settings input.num-input { 
            width: 100%; 
            font-size: 10px; 
            box-sizing: border-box; 
            text-align: left; 
        }
        
        .combined-select { 
            width: 100%; 
            height: 26px; 
            margin-bottom: 8px; 
        }

        .toolbar-group button { 
            width: 100%; 
            height: 100%; 
            margin: 0; 
            padding: 0 4px;
            display: flex; 
            align-items: center; 
            justify-content: center;
        }

        .label-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            color: #888; 
            font-size: 9px; 
            font-weight: bold; 
            text-transform: uppercase; 
        }

        .input-row { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
        }

        .anim-unit { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 2px; 
        }

        .anim-unit label { 
            font-size: 7px; 
            color: var(--accent); 
            font-weight: bold; 
            cursor: pointer; 
        }

        /* --- Main Layout --- */
        main { 
            flex-grow: 1; 
            display: flex; 
            flex-direction: row; 
            padding: 10px; 
            gap: 10px; 
            min-height: 0;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }

        .left-col { 
            display: flex; 
            flex-direction: column; 
            width: 320px; 
            gap: 10px; 
            flex-shrink: 0; 
        }

        .right-col { 
            flex-grow: 1; 
            display: flex; 
            flex-direction: column; 
            position: relative; 
            border-radius: 6px; 
            overflow: hidden; 
            touch-action: none;
        }

        #canvas-container { 
            position: relative; 
            height: 100%; 
            width: 100%; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
        }

        canvas { 
            background: transparent; 
            border-radius: 4px; 
            cursor: crosshair;
            max-height: 100%; 
            max-width: 100%; 
            object-fit: contain;
        }

        #selection-box {
            position: absolute; 
            border: 1px dashed var(--accent);
            background: rgba(0, 210, 255, 0.15); 
            pointer-events: none;
            display: none; 
            z-index: 10;
        }

        .editor-container {
            flex-grow: 1; 
            display: flex; 
            flex-direction: column;
            background: var(--panel); 
            border: 1px solid #333; 
            border-radius: 6px;
            padding: 10px; 
            min-height: 0;
        }

        .panel-header {
            font-size: 11px; 
            letter-spacing: 1px; 
            color: var(--accent);
            text-transform: uppercase; 
            font-weight: bold; 
            opacity: 0.8;
            margin-bottom: 8px; 
            display: flex; 
            justify-content: space-between;
        }

        select.preset-select {
            background: #222; 
            color: #fff; 
            border: 1px solid #444; 
            font-family: monospace; 
            font-size: 11px; 
            padding: 4px; 
            border-radius: 3px; 
            width: 100%; 
            cursor: pointer; 
            margin-bottom: 8px;
        }

        textarea {
            flex-grow: 1; 
            background: #0d0d0d; 
            color: #ccc;
            border: 1px solid #333; 
            border-radius: 4px;
            padding: 10px; 
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px; 
            line-height: 1.4; 
            resize: none;
            outline: none; 
            white-space: pre; 
            margin-bottom: 8px;
        }

        textarea:focus { 
            border-color: var(--accent); 
            color: #fff; 
        }

        .editor-actions { 
            display: flex; 
            gap: 8px; 
        }

        #pause-overlay {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7); 
            color: var(--accent); 
            padding: 15px 30px;
            border-radius: 8px; 
            font-weight: bold; 
            pointer-events: none;
            display: none; 
            border: 1px solid var(--accent); 
            text-transform: uppercase;
            z-index: 5; 
            letter-spacing: 2px; 
            text-align: center;
        }

        #rec-indicator {
            position: absolute; 
            top: 20px; 
            right: 20px; 
            background: rgba(0,0,0,0.8); 
            padding: 8px 15px; 
            border-radius: 6px;
            display: none; 
            align-items: center; 
            gap: 10px; 
            color: #fff;
            font-family: monospace; 
            font-size: 14px; 
            border: 1px solid #eb4d4b;
        }

        .dot { 
            width: 10px; 
            height: 10px; 
            background: #eb4d4b; 
            border-radius: 50%; 
            animation: blink 1s infinite; 
        }

        @keyframes blink { 
            0%, 100% { opacity: 1; } 
            50% { opacity: 0; } 
        }

        #info-modal {
            position: absolute; 
            top: 20px; 
            bottom: 20px; 
            left: 20px; 
            z-index: 20;
            background: rgba(17, 17, 17, 0.96); 
            backdrop-filter: blur(12px);
            border: 1px solid #333; 
            border-radius: 8px; 
            width: 350px; 
            display: none; 
            flex-direction: column; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            overflow: hidden;
        }

        .info-content { 
            padding: 25px; 
            overflow-y: auto; 
            height: 100%; 
            scrollbar-width: thin; 
            scrollbar-color: var(--accent) #222; 
        }

        #info-modal h2 { 
            margin-top: 0; 
            color: var(--accent); 
            font-size: 16px; 
            text-transform: uppercase; 
            border-bottom: 1px solid #333; 
            padding-bottom: 10px;
        }

        #info-modal h3 { 
            margin: 15px 0 5px 0; 
            font-size: 12px; 
            color: #fff; 
            text-transform: uppercase; 
        }

        #info-modal p { 
            color: #aaa; 
            margin: 0 0 10px 0; 
            font-size: 13px; 
            line-height: 1.4;
        }

        #info-modal code { 
            background: #222; 
            padding: 2px 4px; 
            border-radius: 3px; 
            color: var(--accent); 
            font-family: monospace;
        }
        
        .close-info { 
            position: absolute; 
            top: 15px; 
            right: 15px; 
            cursor: pointer; 
            color: #666; 
            font-size: 18px; 
            z-index: 21; 
            background: #111; 
            width: 24px; 
            height: 24px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            border-radius: 4px;
        }

        .close-info:hover { 
            color: #fff; 
            background: #222; 
        }

        @media (max-width: 900px) { 
            #info-modal { 
                width: calc(100% - 40px); 
                top: 60px; 
            } 
        }

        button { 
            border: none; 
            padding: 0 12px; 
            border-radius: 4px; 
            font-weight: bold; 
            cursor: pointer; 
            transition: 0.2s; 
            text-transform: uppercase; 
            font-size: 10px; 
            height: 34px; 
            align-self: center;
        }

        .btn-run { 
            background: var(--accent); 
            color: #000; 
            flex-grow: 1; 
        }

        .btn-run:hover { 
            filter: brightness(1.2); 
        }

        .btn-rand { 
            background: #a55eea; 
            color: #fff; 
        }

        .btn-rec { 
            background: #eb4d4b; 
            color: #fff; 
        }

        .btn-util { 
            background: #333; 
            color: #ccc; 
        }

        .btn-util:hover { 
            background: #444; 
            color: #fff; 
        }

        .btn-sec { 
            background: #333; 
            color: #ccc; 
        }

        .btn-sec:hover { 
            background: #444; 
            color: #fff; 
        }

        .btn-info { 
            background: transparent; 
            border: 1px solid #444; 
            color: #888; 
            width: 34px; 
            padding: 0; 
            font-size: 14px; 
            margin-top: 2px; 
        }

        .btn-info:hover { 
            color: #fff; 
            border-color: #fff; 
        }

        .btn-icon { 
            padding: 0 8px; 
            font-size: 14px; 
        }

        #reset-zoom-btn {
            display: inline-flex; 
            align-items: center; 
            justify-content: center;
            background: #333; 
            color: #ccc; 
            padding: 0 8px; 
            border: none;
            border-radius: 4px; 
            height: 28px; 
            cursor: pointer;
        }

        #reset-zoom-btn:disabled { 
            cursor: not-allowed; 
            opacity: 0.5; 
            background: #444; 
            color: #777; 
        }

        span.value { 
            color: #fff; 
            font-size: 12px; 
            font-family: monospace; 
        }

        input[type="range"] { 
            accent-color: var(--accent); 
            cursor: pointer; 
        }

        input:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
        }
        
        input[type="number"].num-input { 
            width: 75px; 
            background: #222; 
            color: #fff; 
            border: 1px solid #444; 
            font-size: 11px; 
            padding: 4px; 
            border-radius: 4px; 
            font-family: monospace; 
            outline: none;
        }

        input[type="number"].num-input:focus { 
            border-color: var(--accent); 
        }

        select { 
            background: #222; 
            color: #fff; 
            border: 1px solid #444; 
            font-size: 11px; 
            padding: 4px; 
            border-radius: 4px; 
            outline: none; 
            cursor: pointer;
        }

        select:hover { 
            border-color: #666; 
        }

        @media (max-width: 900px) {
            body { 
                height: auto; 
                overflow-y: auto; 
            }
            header { 
                height: auto; 
                padding: 10px; 
                justify-content: center; 
                gap: 15px; 
            }
            main { 
                flex-direction: column; 
                height: auto; 
                overflow: visible; 
            }
            .left-col { 
                width: 100%; 
                order: 2; 
            }
            .right-col { 
                width: 100%; 
                order: 1; 
                height: 55vh; 
                min-height: 350px; 
            }
            #adv-toggle-btn {
                display: block;
            }
        }
    </style>
</head>
<body>

    <header id="ui-panel">
        
        <div class="control-group">
            <div class="group-header">
                <span>R (œÄ Multiplier)</span>
                <div style="display: flex; gap: 3px; align-items: center;">
                    <button id="r-dec-btn" class="btn-sec" style="height: 22px; width: 22px; padding: 0; display: flex; align-items: center; justify-content: center;" title="Decrease R">-</button>
                    <input type="number" id="r-number" class="num-input" min="1" step="1" value="1" style="margin: 0;">
                    <button id="r-inc-btn" class="btn-sec" style="height: 22px; width: 22px; padding: 0; display: flex; align-items: center; justify-content: center;" title="Increase R">+</button>
                </div>
            </div>
            <div class="group-header" style="margin-top: 5px; margin-bottom: 2px;">
                <span>S (œÄ Divider)</span>
                <div style="display: flex; gap: 3px; align-items: center;">
                    <button id="s-dec-btn" class="btn-sec" style="height: 22px; width: 22px; padding: 0; display: flex; align-items: center; justify-content: center;" title="Decrease S">-</button>
                    <input type="number" id="s-number" class="num-input" min="1" step="1" value="7500" style="margin: 0;">
                    <button id="s-inc-btn" class="btn-sec" style="height: 22px; width: 22px; padding: 0; display: flex; align-items: center; justify-content: center;" title="Increase S">+</button>
                </div>
            </div>
            <div class="toggles-row" style="margin-top: auto;">
                <span>Simplified (r/s):</span>
                <span id="co-prime-display" style="color: var(--accent); font-family: monospace;">1 / 7500</span>
            </div>
            <button id="adv-toggle-btn" class="btn-sec">‚öôÔ∏è Advanced Options</button>
        </div>

        <div id="advanced-controls">
            
            <div class="control-group">
                <div class="group-header">
                    <span>Steps (N)</span>
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <button id="n-dec-btn" class="btn-sec" style="height: 22px; width: 22px; padding: 0; display: flex; align-items: center; justify-content: center;" title="Decrease N" disabled>-</button>
                        <input type="number" id="n-number" class="num-input" min="1" max="3600000" step="1000" value="90000" disabled style="margin: 0;">
                        <button id="n-inc-btn" class="btn-sec" style="height: 22px; width: 22px; padding: 0; display: flex; align-items: center; justify-content: center;" title="Increase N" disabled>+</button>
                    </div>
                </div>
                <div class="slider-row">
                    <input type="range" id="n-input" min="3" max="6.556303" step="0.0001" value="4.9542" disabled>
                </div>
                <div class="toggles-row">
                    <label for="n-anim"><input type="checkbox" id="n-anim"> ANIMATE</label>
                    <label for="n-auto-value" title="Lock Symmetry"><input type="checkbox" id="n-auto-value" checked> AUTO N</label>
                </div>
                <div id="n-anim-settings" class="anim-settings">
                    <label>Min <input type="number" id="n-anim-min" class="num-input" value="1000" min="1"></label>
                    <label>Max <input type="number" id="n-anim-max" class="num-input" value="3600000" max="3600000"></label>
                </div>
            </div>

            <div class="control-group">
                <div class="group-header">
                    <span>Line Width</span>
                    <input type="number" id="lw-number" class="num-input" min="0.01" max="50.0" step="0.01" value="1.0" style="width: 50px;">
                </div>
                <div class="slider-row" style="margin-bottom: 12px;">
                    <input type="range" id="lw-input" min="0.01" max="50.0" step="0.01" value="1.0">
                </div>
                
                <div class="group-header">
                    <span>Speed</span>
                    <span id="spd-val" style="color: var(--accent); font-family: monospace; font-size: 12px;">5</span>
                </div>
                <div class="slider-row" style="margin-bottom: 0;">
                    <input type="range" id="speed-input" min="1" max="10" value="5">
                </div>
            </div>

            <div class="control-group">
                <div class="group-header"><span>Appearance</span></div>
                <select id="style-select" class="combined-select">
                    <option value="neon">Neon Glow (Dark)</option>
                    <option value="rainbow">Spectrum (Dark)</option>
                    <option value="solid">Solid White (Dark)</option>
                    <option value="light">Solid Black (Light)</option>
                    <option value="light-glow">Neon Glow (Light)</option>
                </select>
                
                <div class="group-header" style="margin-top: 4px;"><span>Configuration</span></div>
                <div style="display: flex; gap: 4px; align-items: center;">
                    <select id="config-select" style="flex-grow: 1; width: 0; height: 26px;">
                        <option value="">Load...</option>
                        <optgroup label="Built-in" id="builtin-configs-group"></optgroup>
                        <optgroup label="Saved" id="saved-configs-group"></optgroup>
                    </select>
                    <button id="save-config-btn" class="btn-sec btn-icon" title="Save Config" style="height: 26px; padding: 0 6px;">üíæ</button>
                    <button id="export-config-btn" class="btn-sec btn-icon" title="Export to File" style="height: 26px; padding: 0 6px;">üì§</button>
                    <button id="import-config-btn" class="btn-sec btn-icon" title="Import from File" style="height: 26px; padding: 0 6px;">üì•</button>
                </div>
                <input type="file" id="import-file" style="display:none" accept=".json">
            </div>

            <div class="toolbar-group">
                <button id="info-btn" class="btn-info" title="Info" style="border-radius: 50%; width: 26px; height: 26px; padding: 0;">?</button>
                <button id="reset-zoom-btn">üîç Reset</button>
                <button id="random-btn" class="btn-rand">üé≤ Rand</button>
                <button id="fs-btn" class="btn-util">‚õ∂ Full</button>
                
                <button id="save-btn" class="btn-util">üì∏ PNG</button>
                <button id="save-svg-btn" class="btn-util">üìÑ SVG</button>
                <button id="rec-btn" class="btn-rec">‚è∫ Rec</button>
                <button onclick="window.location.href='index.html'" class="btn-util">üè†</button>
            </div>

        </div>
    </header>

    <main>
        <div class="left-col" id="advanced-editor">
            <div class="editor-container">
                <div class="panel-header">Function f(n)</div>
                <select id="preset-select" class="preset-select">
                    <optgroup label="Standard Math">
                        <option value="n2">Square (n¬≤)</option>
                        <option value="n">Linear (n)</option>
                        <option value="n3">Cube (n¬≥)</option>
                        <option value="nlog">n * log(n)</option>
                        <option value="nsin">n * sin(n)</option>
                        <option value="sinn2">sin(n¬≤)</option>
                    </optgroup>
                    <optgroup label="User Saved" id="user-presets-group">
                    </optgroup>
                </select>

                <textarea id="code-area" spellcheck="false">return n * n;</textarea>

                <div class="editor-actions">
                    <button id="save-preset-btn" class="btn-sec">üíæ Save Func</button>
                    <button id="run-btn" class="btn-run">‚ñ∂ Update Canvas</button>
                </div>
                <div id="code-error" style="color: #ff4757; font-size: 10px; margin-top: 5px; display: none;">Error</div>
            </div>
            
            <div style="padding: 10px; background: var(--panel); border: 1px solid #222; border-radius: 6px; font-size: 11px; color: #888;">
                <div class="panel-header" style="margin-bottom: 4px;">Context Variables</div>
                <p style="margin: 0;"><strong>n</strong>: The current iteration step (Integer)</p>
            </div>
        </div>

        <div class="right-col">
            <div id="info-modal" style="display: none;">
                <span class="close-info" onclick="document.getElementById('info-modal').style.display='none'">&times;</span>
                <div class="info-content">
                    <h2>Angle Path Generator</h2>
                    <p>This generator draws a sequence of lines based on a simple mathematical rule, commonly known in turtle graphics.</p>
                    
                    <h3>The Algorithm</h3>
                    <p>Starting at the origin, a line of unit length is drawn. At each step <code>n</code>, the angle of the line changes by a function <code>f(n)</code>. The new line is then appended to the previous one.</p>
                    <p><code>Angle<sub>n</sub> = Angle<sub>n-1</sub> + (r / s &times; f(n) &times; &pi;)</code></p>
                    
                    <h3>Rational Angles & Precision</h3>
                    <p>To eliminate chaotic floating-point drift, this model represents angles using two integers, <code>r</code> (multiplier) and <code>s</code> (divider). If your math formula produces exact integers (like n¬≤), the engine tracks the phase entirely using integer modular arithmetic ensuring 100% symmetric stability indefinitely.</p>

                    <h3>Symmetry Lock (Auto N)</h3>
                    <p>Checking <strong>Lock Symmetry</strong> calculates the precise step sequence <code>N</code> required to perfectly close a rotational rosette. This relies on the period of integer sequences modulo <code>2*s</code>, discovering shapes the eye can never manually find.</p>
                    
                    <p style="margin-top: 20px; font-size: 10px; opacity: 0.5;">End of Documentation</p>
                </div>
            </div>

            <div id="canvas-container">
                <canvas id="mainCanvas" width="1600" height="1600"></canvas>
                <div id="selection-box"></div>
                <div id="pause-overlay">Paused</div>
                <div id="rec-indicator"><div class="dot"></div><span id="rec-timer">00:00</span></div>
            </div>
            <div id="status" style="position: absolute; bottom: 5px; right: 10px; font-size: 10px; color: #555; font-family: monospace; z-index: 2; pointer-events: none; mix-blend-mode: difference;">CLICK/DRAG TO ZOOM | RIGHT-CLICK OUT | QUICK CLICK PAUSE</div>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const canvasContainer = document.getElementById('canvas-container');
        const selectionBox = document.getElementById('selection-box');
        
        const ui = {
            nSlider: document.getElementById('n-input'),
            nNumber: document.getElementById('n-number'), 
            nAnim: document.getElementById('n-anim'),
            nAnimSettings: document.getElementById('n-anim-settings'),
            nAnimMin: document.getElementById('n-anim-min'),
            nAnimMax: document.getElementById('n-anim-max'),
            nAutoValue: document.getElementById('n-auto-value'),
            nIncrBtn: document.getElementById('n-inc-btn'),
            nDecrBtn: document.getElementById('n-dec-btn'),

            rNumber: document.getElementById('r-number'), 
            rIncrBtn: document.getElementById('r-inc-btn'),
            rDecrBtn: document.getElementById('r-dec-btn'),

            sNumber: document.getElementById('s-number'), 
            sIncrBtn: document.getElementById('s-inc-btn'),
            sDecrBtn: document.getElementById('s-dec-btn'),
            
            coprimeDisplay: document.getElementById('co-prime-display'),

            speed: document.getElementById('speed-input'), 
            spdLabel: document.getElementById('spd-val'),

            lwSlider: document.getElementById('lw-input'),
            lwNumber: document.getElementById('lw-number'),

            style: document.getElementById('style-select'), 
            pauseOverlay: document.getElementById('pause-overlay'),
            recBtn: document.getElementById('rec-btn'), 
            recInd: document.getElementById('rec-indicator'), 
            recTimer: document.getElementById('rec-timer'),
            infoBtn: document.getElementById('info-btn'), 
            infoModal: document.getElementById('info-modal'),
            resetZoomBtn: document.getElementById('reset-zoom-btn'),
            
            editor: document.getElementById('code-area'), 
            presetSelect: document.getElementById('preset-select'),
            userGroup: document.getElementById('user-presets-group'), 
            runBtn: document.getElementById('run-btn'),
            savePresetBtn: document.getElementById('save-preset-btn'), 
            errorMsg: document.getElementById('code-error'),

            configSelect: document.getElementById('config-select'),
            builtinConfigGroup: document.getElementById('builtin-configs-group'),
            savedConfigGroup: document.getElementById('saved-configs-group'),
            saveConfigBtn: document.getElementById('save-config-btn'),
            exportConfigBtn: document.getElementById('export-config-btn'),
            importConfigBtn: document.getElementById('import-config-btn'),
            importFile: document.getElementById('import-file'),

            saveSvgBtn: document.getElementById('save-svg-btn'),
            
            advToggleBtn: document.getElementById('adv-toggle-btn'),
            advControls: document.getElementById('advanced-controls'),
            advEditor: document.getElementById('advanced-editor')
        };

        ui.resetZoomBtn.disabled = true;

        const builtinConfigs = {
            "Default Neon": { 
                n: 30000, r: 1, s: 7500, speed: 5, style: "neon", nAnim: false, code: "return n * n;" 
            },
            "Light Glow Core": { 
                n: 250000, r: 1, s: 1200, speed: 6, style: "light-glow", nAnim: false, code: "return n * Math.log(n);" 
            },
            "Rainbow Web": { 
                n: 120000, r: 179, s: 360, speed: 4, style: "rainbow", nAnim: false, code: "return n;" 
            },
            "Sine Petals (Light)": { 
                n: 50000, r: 1, s: 180, speed: 5, style: "light", nAnim: false, code: "return n * Math.sin(n);" 
            }
        };
        
        let savedConfigs = JSON.parse(localStorage.getItem('angle_path_configs') || '{}');
        let currentRenderState = { 
            N: 0, 
            r: 1, 
            s: 7500, 
            time: 0, 
            bounds: { minX: 0, maxX: 0, minY: 0, maxY: 0 } 
        };

        function updateConfigDropdown() {
            ui.builtinConfigGroup.innerHTML = '';
            Object.keys(builtinConfigs).forEach(name => {
                const opt = document.createElement('option');
                opt.value = `builtin:${name}`;
                opt.textContent = name;
                ui.builtinConfigGroup.appendChild(opt);
            });

            ui.savedConfigGroup.innerHTML = '';
            Object.keys(savedConfigs).forEach(name => {
                const opt = document.createElement('option');
                opt.value = `saved:${name}`;
                opt.textContent = name;
                ui.savedConfigGroup.appendChild(opt);
            });
        }

        function getCurrentConfig() {
            return {
                n: userBase.n,
                r: userBase.r,
                s: userBase.s,
                nAnim: ui.nAnim.checked,
                nAnimMin: parseInt(ui.nAnimMin.value),
                nAnimMax: parseInt(ui.nAnimMax.value),
                speed: parseInt(ui.speed.value),
                lineWidth: parseFloat(ui.lwSlider.value),
                style: ui.style.value,
                code: ui.editor.value
            };
        }

        function loadConfig(config) {
            if (!config) {
                return;
            }
            
            ui.nAnim.checked = false;

            if (config.code) {
                ui.editor.value = config.code;
            }

            if (config.c !== undefined && config.r === undefined) {
                config.r = Math.round(config.c * 1000);
                config.s = 180000;
            }

            updateRS(config.r || 1, config.s || 7500);
            updateN(config.n, false);

            if (config.nAnimMin !== undefined) {
                ui.nAnimMin.value = config.nAnimMin;
            }
            if (config.nAnimMax !== undefined) {
                ui.nAnimMax.value = config.nAnimMax;
            }

            ui.nAnim.checked = !!config.nAnim;
            if (ui.nAnim.checked) {
                ui.nAnimSettings.style.display = 'flex';
            } else {
                ui.nAnimSettings.style.display = 'none';
            }

            ui.speed.value = config.speed || 5;
            ui.spdLabel.textContent = ui.speed.value;

            if (config.lineWidth !== undefined) {
                updateLineWidth(config.lineWidth);
            } else {
                updateLineWidth(1.0); 
            }

            ui.style.value = config.style || 'neon';

            compileFunction();
            resetZoom(); 
        }

        ui.configSelect.addEventListener('change', (e) => {
            const val = e.target.value;
            if (!val) {
                return;
            }
            let cfg = null;
            if (val.startsWith('builtin:')) {
                cfg = builtinConfigs[val.split(':')[1]];
            } else if (val.startsWith('saved:')) {
                cfg = savedConfigs[val.split(':')[1]];
            }
            if (cfg) {
                loadConfig(cfg);
            }
        });

        ui.saveConfigBtn.addEventListener('click', () => {
            const name = prompt("Enter a name to save this full configuration:");
            if (name) {
                savedConfigs[name] = getCurrentConfig();
                localStorage.setItem('angle_path_configs', JSON.stringify(savedConfigs));
                updateConfigDropdown();
                ui.configSelect.value = `saved:${name}`;
            }
        });

        ui.exportConfigBtn.addEventListener('click', () => {
            const cfg = getCurrentConfig();
            const blob = new Blob([JSON.stringify(cfg, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `anglepath-config-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        ui.importConfigBtn.addEventListener('click', () => {
            ui.importFile.click();
        });

        ui.importFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const cfg = JSON.parse(ev.target.result);
                    loadConfig(cfg);
                    ui.configSelect.value = ""; 
                } catch (err) {
                    alert("Invalid JSON configuration file.");
                }
            };
            reader.readAsText(file);
            ui.importFile.value = ''; 
        });

        // --- UI Advanced Toggle Logic ---
        ui.advToggleBtn.addEventListener('click', () => {
            ui.advControls.classList.toggle('collapsed');
            ui.advEditor.classList.toggle('collapsed');
            window.dispatchEvent(new Event('resize'));
        });

        // Initialize collapsed state for mobile devices
        if (window.innerWidth <= 900) {
            ui.advControls.classList.add('collapsed');
            ui.advEditor.classList.add('collapsed');
        }

        // --- ZOOM STATE ---
        let isZoomed = false;
        let zoomBounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
        let activeTransform = { scale: 1, cx: 0, cy: 0 }; 

        const presets = {
            'n2': 'return n * n;',
            'n': 'return n;',
            'n3': 'return n * n * n;',
            'nlog': 'return n * Math.log(n);',
            'nsin': 'return n * Math.sin(n);',
            'sinn2': 'return Math.sin(n * n);'
        };

        let userPresets = JSON.parse(localStorage.getItem('angle_path_presets') || '{}');
        let activeFunc = (n) => n * n;
        let isFuncStrictlyInteger = true;

        let isPaused = false;
        let animationFrameId;
        let userBase = { n: 30000, r: 1, s: 7500 };

        let glowStartN = 0;
        let glowEndN = 0;
        let glowIntensity = 0;

        let eraseStartN = 0;
        let eraseEndN = 0;
        let eraseIntensity = 0;
        
        let virtualTime = 0;
        let lastRealTime = performance.now();
        let mediaRecorder;
        let recordedChunks = [];
        let recStartTime;

        const MAX_N = 3600000;
        let points = new Float32Array((MAX_N + 1) * 2);

        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                let t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        function getIdealLineWidth(n) {
            if (ui.editor.value.trim() !== presets['n2']) {
                return parseFloat(ui.lwSlider.value);
            }
            const table = [
                [1, 0.01], 
                [10, 0.01], 
                [100, 0.03], 
                [1000, 0.06],
                [10000, 0.6], 
                [100000, 1.5], 
                [180000, 2.6], 
                [250000, 3.0],
                [320000, 3.5], 
                [576000, 4.1], 
                [675000, 5.3], 
                [720000, 5.8],
                [1125000, 6.5]
            ];
            
            if (n <= table[0][0]) {
                return table[0][1];
            }
            if (n >= table[table.length - 1][0]) {
                const last = table[table.length - 1];
                const prev = table[table.length - 2];
                const slope = (last[1] - prev[1]) / (last[0] - prev[0]);
                return Math.min(last[1] + slope * (n - last[0]), 10.0);
            }
            for (let i = 0; i < table.length - 1; i++) {
                if (n >= table[i][0] && n <= table[i+1][0]) {
                    const ratio = (n - table[i][0]) / (table[i+1][0] - table[i][0]);
                    return table[i][1] + ratio * (table[i+1][1] - table[i][1]);
                }
            }
            return 1.0;
        }

        function updatePresetDropdown() {
            ui.userGroup.innerHTML = '';
            Object.keys(userPresets).forEach(name => {
                const opt = document.createElement('option');
                opt.value = `user:${name}`;
                opt.textContent = name;
                ui.userGroup.appendChild(opt);
            });
        }

        function compileFunction() {
            try {
                const code = ui.editor.value;
                const testFunc = new Function('n', code);
                
                isFuncStrictlyInteger = true;
                for (let i = 1; i <= 10; i++) {
                    if (!Number.isInteger(testFunc(i))) { 
                        isFuncStrictlyInteger = false; 
                        break; 
                    }
                }

                activeFunc = testFunc;
                ui.errorMsg.style.display = 'none';
                
                if (isPaused) { 
                    isPaused = false; 
                    ui.pauseOverlay.style.display = 'none'; 
                }
            } catch (err) {
                ui.errorMsg.textContent = "Error: " + err.message;
                ui.errorMsg.style.display = 'block';
            }
        }

        function calculatePath(N, r, s) {
            let x = 0;
            let y = 0;
            let minX = 0;
            let maxX = 0;
            let minY = 0;
            let maxY = 0;
            
            points[0] = 0; 
            points[1] = 0;

            if (isFuncStrictlyInteger && Number.isInteger(r) && Number.isInteger(s)) {
                let phaseNum = 0;
                const doubleS = 2 * s;
                const pi_div_s = Math.PI / s;

                for (let n = 1; n <= N; n++) {
                    let stepAngle = activeFunc(n);
                    
                    phaseNum = (phaseNum + (stepAngle * r) % doubleS) % doubleS;
                    if (phaseNum < 0) {
                        phaseNum += doubleS; 
                    }
                    
                    let angle = phaseNum * pi_div_s;
                    x += Math.cos(angle);
                    y += Math.sin(angle);

                    if (x < minX) {
                        minX = x;
                    } else if (x > maxX) {
                        maxX = x;
                    }

                    if (y < minY) {
                        minY = y;
                    } else if (y > maxY) {
                        maxY = y;
                    }

                    points[n * 2] = x;
                    points[n * 2 + 1] = y;
                }
            } else {
                let angle = 0;
                const C_rad = (r / s) * Math.PI;
                const twoPi = 2 * Math.PI;

                for (let n = 1; n <= N; n++) {
                    let stepAngle = activeFunc(n);
                    angle = (angle + stepAngle * C_rad) % twoPi;
                    if (angle < 0) {
                        angle += twoPi;
                    }
                    
                    x += Math.cos(angle);
                    y += Math.sin(angle);

                    if (x < minX) {
                        minX = x;
                    } else if (x > maxX) {
                        maxX = x;
                    }

                    if (y < minY) {
                        minY = y;
                    } else if (y > maxY) {
                        maxY = y;
                    }

                    points[n * 2] = x;
                    points[n * 2 + 1] = y;
                }
            }
            
            return { minX, maxX, minY, maxY };
        }

        function performRender(N, r, s, time) {
            const style = ui.style.value;
            const isLightTheme = style === 'light' || style === 'light-glow';
            
            const geoBounds = calculatePath(N, r, s);
            let renderBounds = isZoomed ? zoomBounds : geoBounds;
            
            currentRenderState = { N, r, s, time, bounds: renderBounds };
            
            ctx.fillStyle = isLightTheme ? '#ffffff' : '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const bbWidth = renderBounds.maxX - renderBounds.minX;
            const bbHeight = renderBounds.maxY - renderBounds.minY;
            
            const scale = Math.min(canvas.width / (bbWidth || 1), canvas.height / (bbHeight || 1)) * 0.90;
            const bbCenterX = (renderBounds.maxX + renderBounds.minX) / 2;
            const bbCenterY = (renderBounds.maxY + renderBounds.minY) / 2;

            activeTransform = { scale, cx: bbCenterX, cy: bbCenterY };

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(-bbCenterX, -bbCenterY);

            if (style === 'neon') {
                ctx.globalCompositeOperation = 'lighter';
            } else if (style === 'light-glow') {
                ctx.globalCompositeOperation = 'multiply';
            } else {
                ctx.globalCompositeOperation = 'source-over';
            }
            
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            let lwMultiplier = parseFloat(ui.lwSlider.value) || 1.0;
            let baseLineWidth = (Math.max(0.1, 80000 / N) / scale) * lwMultiplier;
            
            if (isZoomed) {
                baseLineWidth *= 1.5;
            }

            const MAX_PATH_SIZE = 500000; 
            const numChunks = Math.ceil(N / MAX_PATH_SIZE);

            for (let i = 0; i < numChunks; i++) {
                const start = i * MAX_PATH_SIZE;
                const end = Math.min((i + 1) * MAX_PATH_SIZE, N);

                ctx.beginPath();
                ctx.moveTo(points[start * 2], points[start * 2 + 1]);
                
                for (let j = start + 1; j <= end; j++) {
                    ctx.lineTo(points[j * 2], points[j * 2 + 1]);
                }

                if (style === 'rainbow') {
                    ctx.lineWidth = baseLineWidth * 1.5;
                    ctx.strokeStyle = `hsl(${(i / numChunks) * 360 + (time * 50)}, 90%, 60%)`;
                    ctx.stroke();
                } else if (style === 'neon') {
                    ctx.lineWidth = baseLineWidth;
                    ctx.strokeStyle = `rgba(0, 210, 255, 0.4)`;
                    ctx.stroke();
                    ctx.lineWidth = baseLineWidth * 0.3;
                    ctx.strokeStyle = `rgba(255, 255, 255, 0.8)`;
                    ctx.stroke();
                } else if (style === 'light-glow') {
                    ctx.lineWidth = baseLineWidth * 1.5;
                    ctx.strokeStyle = `rgba(255, 0, 128, 0.3)`;
                    ctx.stroke();
                    ctx.lineWidth = baseLineWidth * 0.4;
                    ctx.strokeStyle = `rgba(30, 30, 30, 0.9)`; 
                    ctx.stroke();
                } else if (style === 'light') {
                    ctx.lineWidth = baseLineWidth * 0.5;
                    ctx.strokeStyle = `rgba(10, 10, 10, 0.9)`;
                    ctx.stroke();
                } else {
                    ctx.lineWidth = baseLineWidth * 0.5;
                    ctx.strokeStyle = `#ffffff`;
                    ctx.stroke();
                }
            }

            if (glowIntensity > 0 && glowEndN > glowStartN && N >= glowStartN) {
                ctx.beginPath();
                const startIdx = Math.max(0, glowStartN - 1);
                const endIdx = Math.min(N, glowEndN);
                
                ctx.moveTo(points[startIdx * 2], points[startIdx * 2 + 1]);
                for (let j = startIdx + 1; j <= endIdx; j++) {
                    ctx.lineTo(points[j * 2], points[j * 2 + 1]);
                }

                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = baseLineWidth * 6;
                if (isLightTheme) {
                    ctx.strokeStyle = `rgba(255, 50, 80, ${glowIntensity * 0.6})`;
                } else {
                    ctx.strokeStyle = `rgba(255, 215, 0, ${glowIntensity * 0.6})`;
                }
                ctx.stroke();

                ctx.lineWidth = baseLineWidth * 2;
                ctx.strokeStyle = `rgba(255, 255, 255, ${glowIntensity})`;
                ctx.stroke();
            }

            if (eraseIntensity > 0 && eraseEndN > eraseStartN) {
                ctx.beginPath();
                const startIdx = Math.max(0, eraseStartN - 1);
                const endIdx = eraseEndN;
                
                ctx.moveTo(points[startIdx * 2], points[startIdx * 2 + 1]);
                for (let j = startIdx + 1; j <= endIdx; j++) {
                    ctx.lineTo(points[j * 2], points[j * 2 + 1]);
                }

                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = baseLineWidth * 4;
                ctx.strokeStyle = `rgba(255, 50, 50, ${eraseIntensity * 0.8})`;
                ctx.stroke();

                ctx.lineWidth = baseLineWidth;
                ctx.strokeStyle = `rgba(255, 200, 200, ${eraseIntensity})`;
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function screenToLogical(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (screenX - rect.left) * scaleX;
            const y = (screenY - rect.top) * scaleY;

            const logicalX = (x - canvas.width / 2) / activeTransform.scale + activeTransform.cx;
            const logicalY = (y - canvas.height / 2) / activeTransform.scale + activeTransform.cy;
            
            return { x: logicalX, y: logicalY };
        }

        let isDragging = false;
        let isPanning = false;
        let startX = 0;
        let startY = 0;
        let startZoomBounds = null;
        let lastPinchDist = null;

        canvasContainer.addEventListener('pointerdown', (e) => {
            if (e.pointerType === 'mouse' && e.button !== 0) {
                return; 
            }
            if (e.pointerType === 'touch' && lastPinchDist !== null) {
                return;
            }

            isDragging = true;
            isPanning = false;
            startX = e.clientX;
            startY = e.clientY;
            selectionBox.style.display = 'none';
        });

        canvasContainer.addEventListener('pointermove', (e) => {
            if (!isDragging) {
                return;
            }
            if (e.pointerType === 'touch' && lastPinchDist !== null) {
                return; 
            }

            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const dist = Math.hypot(dx, dy);

            if (!isPanning && dist > 10) {
                isPanning = true;
                if (!isZoomed) {
                    zoomBounds = calculatePath(userBase.n, userBase.r, userBase.s);
                    isZoomed = true;
                    ui.resetZoomBtn.disabled = false;
                }
                startZoomBounds = { ...zoomBounds };
            }

            if (isPanning) {
                const rect = canvas.getBoundingClientRect();
                const logicalDx = (dx * (canvas.width / rect.width)) / activeTransform.scale;
                const logicalDy = (dy * (canvas.height / rect.height)) / activeTransform.scale;

                zoomBounds.minX = startZoomBounds.minX - logicalDx;
                zoomBounds.maxX = startZoomBounds.maxX - logicalDx;
                zoomBounds.minY = startZoomBounds.minY - logicalDy;
                zoomBounds.maxY = startZoomBounds.maxY - logicalDy;
            }
        });

        canvasContainer.addEventListener('pointerup', (e) => {
            if (!isDragging) {
                return;
            }
            isDragging = false;

            if (!isPanning) {
                isPaused = !isPaused;
                ui.pauseOverlay.textContent = "PAUSED";
                if (isPaused) {
                    ui.pauseOverlay.style.display = 'block';
                } else {
                    ui.pauseOverlay.style.display = 'none';
                }
            }
            isPanning = false;
        });

        canvasContainer.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            resetZoom();
        });

        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (!isZoomed) {
                zoomBounds = calculatePath(userBase.n, userBase.r, userBase.s);
                isZoomed = true;
                ui.resetZoomBtn.disabled = false;
            }

            const pointerLogical = screenToLogical(e.clientX, e.clientY);
            const zoomFactor = e.deltaY > 0 ? 1.2 : 0.8; 

            zoomBounds.minX = pointerLogical.x - (pointerLogical.x - zoomBounds.minX) * zoomFactor;
            zoomBounds.maxX = pointerLogical.x + (zoomBounds.maxX - pointerLogical.x) * zoomFactor;
            zoomBounds.minY = pointerLogical.y - (pointerLogical.y - zoomBounds.minY) * zoomFactor;
            zoomBounds.maxY = pointerLogical.y + (zoomBounds.maxY - pointerLogical.y) * zoomFactor;
        }, { passive: false });

        canvasContainer.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                isDragging = false; 
                isPanning = false;
                lastPinchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const currentDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );

                if (lastPinchDist) {
                    if (!isZoomed) {
                        zoomBounds = calculatePath(userBase.n, userBase.r, userBase.s);
                        isZoomed = true;
                        ui.resetZoomBtn.disabled = false;
                    }

                    const zoomFactor = lastPinchDist / currentDist; 
                    const midLogical = screenToLogical(
                        (e.touches[0].clientX + e.touches[1].clientX) / 2,
                        (e.touches[0].clientY + e.touches[1].clientY) / 2
                    );

                    zoomBounds.minX = midLogical.x - (midLogical.x - zoomBounds.minX) * zoomFactor;
                    zoomBounds.maxX = midLogical.x + (zoomBounds.maxX - midLogical.x) * zoomFactor;
                    zoomBounds.minY = midLogical.y - (midLogical.y - zoomBounds.minY) * zoomFactor;
                    zoomBounds.maxY = midLogical.y + (zoomBounds.maxY - midLogical.y) * zoomFactor;
                }
                lastPinchDist = currentDist;
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchend', (e) => { 
            if (e.touches.length < 2) {
                lastPinchDist = null; 
            }
        });

        function resetZoom() {
            isZoomed = false;
            ui.resetZoomBtn.disabled = true;
        }

        ui.resetZoomBtn.addEventListener('click', resetZoom);

        function liveLoop() {
            const now = performance.now();
            const delta = (now - lastRealTime) / 1000;
            lastRealTime = now;

            if (glowIntensity > 0) {
                glowIntensity -= delta * 1.2; 
                if (glowIntensity < 0) {
                    glowIntensity = 0;
                }
            }

            if (eraseIntensity > 0) {
                eraseIntensity -= delta * 1.5; 
                if (eraseIntensity < 0) {
                    eraseIntensity = 0;
                }
            }

            if (!isPaused) {
                virtualTime += delta * Math.pow(2.0, parseInt(ui.speed.value) - 1) * 0.0025; 
                const cycle = (virtualTime % 4) / 4;
                const pingPong = 1 - Math.abs(2 * cycle - 1);

                let aN = userBase.n;
                
                if (ui.nAnim.checked) {
                    const easedProgress = Math.pow(pingPong, 2); 
                    const minN = parseInt(ui.nAnimMin.value) || 1;
                    const maxN = parseInt(ui.nAnimMax.value) || MAX_N;
                    aN = Math.floor(minN + (maxN - minN) * easedProgress);
                    
                    ui.nNumber.value = aN;
                    ui.nSlider.value = Math.log10(Math.max(1, aN));
                    
                    const autoLw = getIdealLineWidth(aN);
                    ui.lwSlider.value = autoLw.toFixed(2);
                    ui.lwNumber.value = autoLw.toFixed(2);
                } 
                
                performRender(aN, userBase.r, userBase.s, virtualTime);
            }
            
            updateRecTimer();
            animationFrameId = requestAnimationFrame(liveLoop);
        }

        // --- Exact Rational Symmetry Logic ---
        function calculateRosetteN(r, s) {
            if (r <= 0 || s <= 0) {
                return null;
            }
            
            let g = gcd(r, s);
            let r_co = r / g;
            let s_co = s / g;

            let P_raw = s_co;
            let remainder = (180 * r_co * s_co) % 360;
            let P_true = P_raw;
            
            if (Math.abs(remainder) === 180) {
                P_true = P_raw * 2;
            }

            let p = P_true;
            let p_div_s = p / s_co; 
            
            let sumAngle = 30 * r_co * p_div_s * (p + 1) * (2 * p + 1);
            let deltaTheta = sumAngle % 360;
            
            if (deltaTheta < 0) {
                deltaTheta += 360;
            }
            if (deltaTheta === 360) {
                deltaTheta = 0;
            }

            let m = 360 / gcd(360, deltaTheta);

            return p * m;
        }

        const updateN = (val, fromSlider = false) => {
            let v;
            if (fromSlider) {
                v = Math.round(Math.pow(10, parseFloat(val)));
            } else {
                v = parseInt(val);
            }

            if (isNaN(v)) {
                v = 1000;
            }
            if (v > MAX_N) {
                v = MAX_N;
            }

            if (v > userBase.n && !ui.nAnim.checked && !ui.nAutoValue.checked) {
                glowStartN = userBase.n; 
                glowEndN = v; 
                glowIntensity = 1.0; 
                eraseIntensity = 0;
            } else if (v < userBase.n && !ui.nAnim.checked && !ui.nAutoValue.checked) {
                eraseStartN = v; 
                eraseEndN = userBase.n; 
                eraseIntensity = 1.0; 
                glowIntensity = 0;
            }

            userBase.n = v;
            ui.nNumber.value = v;
            ui.nSlider.value = Math.log10(v).toFixed(5);
            updateLineWidth(getIdealLineWidth(v));

            if (isPaused) { 
                isPaused = false; 
                ui.pauseOverlay.style.display = 'none'; 
            }
        };

        function applySymmetryLock() {
            const perfectN = calculateRosetteN(userBase.r, userBase.s);
            if (perfectN) {
                const clampedN = Math.min(perfectN, MAX_N);
                updateN(clampedN, false); 
            }
        }

        ui.nSlider.addEventListener('input', (e) => {
            updateN(e.target.value, true);
        });

        ui.nNumber.addEventListener('change', (e) => {
            updateN(e.target.value, false);
        });

        const updateRS = (rVal, sVal) => {
            let r = parseInt(rVal) || 1;
            let s = parseInt(sVal) || 1;
            
            if (r < 1) {
                r = 1;
            }
            if (s < 1) {
                s = 1;
            }

            userBase.r = r;
            userBase.s = s;
            
            ui.rNumber.value = r;
            ui.sNumber.value = s;

            let g = gcd(r, s);
            ui.coprimeDisplay.textContent = `${r / g} / ${s / g}`;

            if (ui.nAutoValue.checked) {
                applySymmetryLock();
            }

            if (isPaused) { 
                isPaused = false; 
                ui.pauseOverlay.style.display = 'none'; 
            }
        };

        ui.rNumber.addEventListener('change', (e) => {
            updateRS(e.target.value, userBase.s);
        });

        ui.sNumber.addEventListener('change', (e) => {
            updateRS(userBase.r, e.target.value);
        });

        ui.rDecrBtn.addEventListener('click', () => {
            updateRS(userBase.r - 1, userBase.s);
        });

        ui.rIncrBtn.addEventListener('click', () => {
            updateRS(userBase.r + 1, userBase.s);
        });

        ui.sDecrBtn.addEventListener('click', () => {
            updateRS(userBase.r, userBase.s - 1);
        });

        ui.sIncrBtn.addEventListener('click', () => {
            updateRS(userBase.r, userBase.s + 1);
        });

        ui.nDecrBtn.addEventListener('click', () => {
            updateN(parseInt(userBase.n) - 1);
        });

        ui.nIncrBtn.addEventListener('click', () => {
            updateN(parseInt(userBase.n) + 1);
        });

        const updateLineWidth = (val) => {
            let v = parseFloat(val);
            if (v < 0.01) {
                v = 0.01;
            }
            ui.lwSlider.value = v.toFixed(2);
            ui.lwNumber.value = v.toFixed(2);
            if (isPaused) { 
                isPaused = false; 
                ui.pauseOverlay.style.display = 'none'; 
            }
        };

        ui.lwSlider.addEventListener('input', (e) => {
            updateLineWidth(e.target.value);
        });

        ui.lwNumber.addEventListener('change', (e) => {
            updateLineWidth(e.target.value);
        });

        ui.nAnim.addEventListener('change', () => {
            if (ui.nAnim.checked) {
                ui.nAnimSettings.style.display = 'flex';
                
                const minN = parseInt(ui.nAnimMin.value) || 1;
                const maxN = parseInt(ui.nAnimMax.value) || MAX_N;
                let currentN = Math.max(minN, Math.min(maxN, userBase.n));
                
                let pingPongSq = (maxN - minN) === 0 ? 0 : (currentN - minN) / (maxN - minN);
                let cycle = Math.sqrt(pingPongSq) / 2; 
                virtualTime = Math.floor(virtualTime / 4) * 4 + (cycle * 4);
            } else {
                ui.nAnimSettings.style.display = 'none';
                userBase.n = parseInt(ui.nNumber.value);
            }
        });

        ui.presetSelect.addEventListener('change', (e) => {
            const val = e.target.value;
            if (val.startsWith('user:')) {
                ui.editor.value = userPresets[val.split(':')[1]];
            } else if (presets[val]) {
                ui.editor.value = presets[val];
            }
            compileFunction(); 
        });

        ui.runBtn.addEventListener('click', () => {
            compileFunction();
        });

        ui.editor.addEventListener('keydown', (e) => { 
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                compileFunction(); 
            }
        });

        ui.savePresetBtn.addEventListener('click', () => {
            const name = prompt("Name your function:");
            if (name) {
                userPresets[name] = ui.editor.value;
                localStorage.setItem('angle_path_presets', JSON.stringify(userPresets));
                updatePresetDropdown();
                ui.presetSelect.value = `user:${name}`;
                compileFunction();
            }
        });

        ui.nAutoValue.addEventListener('change', () => {
            const isAuto = ui.nAutoValue.checked;
            ui.nSlider.disabled = isAuto;
            ui.nNumber.disabled = isAuto;
            ui.nDecrBtn.disabled = isAuto;
            ui.nIncrBtn.disabled = isAuto;
            
            if (isAuto) {
                applySymmetryLock(); 
            }
        });

        const generateRandom = () => {
            const funcs = Object.keys(presets);
            const randFunc = funcs[Math.floor(Math.random() * funcs.length)];
            
            ui.presetSelect.value = randFunc;
            ui.editor.value = presets[randFunc];
            
            let randR = Math.floor(Math.random() * 200) + 1;
            let randS = Math.floor(Math.random() * 10000) + 1;
            
            updateRS(randR, randS); 

            let logN = 3.0 + Math.random() * 3.6; 
            userBase.n = Math.floor(Math.pow(10.0, logN));

            ui.nSlider.value = Math.log10(userBase.n); 
            ui.nNumber.value = userBase.n;
            updateLineWidth(getIdealLineWidth(userBase.n));

            ui.nAnim.checked = (Math.random() > 0.8);
            if (ui.nAnim.checked) {
                ui.nAnimSettings.style.display = 'flex';
            } else {
                ui.nAnimSettings.style.display = 'none';
            }
            
            const styles = ['neon', 'rainbow', 'solid', 'light', 'light-glow'];
            ui.style.value = styles[Math.floor(Math.random() * styles.length)];
            
            compileFunction();
        };

        const toggleRec = () => {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
                ui.recBtn.textContent = "‚è∫ Record"; 
                ui.recInd.style.display = 'none';
            } else {
                recordedChunks = [];
                const stream = canvas.captureStream(60); 

                const options = { 
                    mimeType: 'video/webm;codecs=vp9', 
                    videoBitsPerSecond: 8000000 
                };
                
                try { 
                    mediaRecorder = new MediaRecorder(stream, options); 
                } catch (e) { 
                    mediaRecorder = new MediaRecorder(stream, { 
                        mimeType: 'video/webm', 
                        videoBitsPerSecond: 8000000 
                    }); 
                }

                mediaRecorder.ondataavailable = e => { 
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data); 
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const b = new Blob(recordedChunks, { type: 'video/webm' });
                    const a = document.createElement('a'); 
                    a.href = URL.createObjectURL(b); 
                    a.download = `anglepath-${Date.now()}.webm`; 
                    a.click();
                };

                recStartTime = performance.now();
                mediaRecorder.start();
                ui.recBtn.textContent = "‚èπ Stop"; 
                ui.recInd.style.display = 'flex';
            }
        };

        function updateRecTimer() {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                const elapsed = Math.floor((performance.now() - recStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                ui.recTimer.textContent = `${minutes}:${seconds}`;
            }
        }

        const saveImage = () => {
            const link = document.createElement('a');
            link.download = `anglepath-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        };

        const saveSVG = () => {
            const wasPaused = isPaused;
            isPaused = true;
            ui.pauseOverlay.innerHTML = "Building SVG<br><span style='font-size: 10px; color: #fff;'>Please wait...</span>";
            ui.pauseOverlay.style.display = 'block';

            setTimeout(() => {
                try {
                    const { N, time, bounds } = currentRenderState;
                    const style = ui.style.value;
                    const isLightTheme = style === 'light' || style === 'light-glow';
                    const bg = isLightTheme ? '#ffffff' : '#050505';
                    
                    const pad = Math.max(0.1, 80000 / N) * 5;
                    const minX = bounds.minX - pad;
                    const minY = bounds.minY - pad;
                    const bbWidth = (bounds.maxX - bounds.minX) + pad * 2;
                    const bbHeight = (bounds.maxY - bounds.minY) + pad * 2;
                    
                    let lwMultiplier = parseFloat(ui.lwSlider.value) || 1.0;
                    const scale = Math.min(1600 / (bbWidth || 1), 1600 / (bbHeight || 1)) * 0.90;
                    let baseLineWidth = (Math.max(0.1, 80000 / N) / scale) * lwMultiplier;

                    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${bbWidth} ${bbHeight}" style="background-color: ${bg};">\n`;

                    const MAX_PATH_SIZE = 500000; 
                    const numChunks = Math.ceil(N / MAX_PATH_SIZE);
                    let pathStrings = [];

                    for (let i = 0; i < numChunks; i++) {
                        const start = i * MAX_PATH_SIZE;
                        const end = Math.min((i + 1) * MAX_PATH_SIZE, N);

                        let dArray = [`M ${points[start * 2]} ${points[start * 2 + 1]}`];
                        for (let j = start + 1; j <= end; j++) {
                            dArray.push(`L ${points[j * 2]} ${points[j * 2 + 1]}`);
                        }
                        const dStr = dArray.join(' ');

                        if (style === 'rainbow') {
                            const color = `hsl(${(i / numChunks) * 360 + (time * 50)}, 90%, 60%)`;
                            pathStrings.push(`<path d="${dStr}" stroke="${color}" stroke-width="${baseLineWidth * 1.5}" fill="none" stroke-linejoin="round" stroke-linecap="round" />`);
                        } else if (style === 'neon') {
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(0, 210, 255, 0.4)" stroke-width="${baseLineWidth}" fill="none" style="mix-blend-mode: screen;" stroke-linejoin="round" stroke-linecap="round" />`);
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(255, 255, 255, 0.8)" stroke-width="${baseLineWidth * 0.3}" fill="none" style="mix-blend-mode: screen;" stroke-linejoin="round" stroke-linecap="round" />`);
                        } else if (style === 'light-glow') {
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(255, 0, 128, 0.3)" stroke-width="${baseLineWidth * 1.5}" fill="none" style="mix-blend-mode: multiply;" stroke-linejoin="round" stroke-linecap="round" />`);
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(30, 30, 30, 0.9)" stroke-width="${baseLineWidth * 0.4}" fill="none" style="mix-blend-mode: multiply;" stroke-linejoin="round" stroke-linecap="round" />`);
                        } else if (style === 'light') {
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(10, 10, 10, 0.9)" stroke-width="${baseLineWidth * 0.5}" fill="none" stroke-linejoin="round" stroke-linecap="round" />`);
                        } else {
                            pathStrings.push(`<path d="${dStr}" stroke="#ffffff" stroke-width="${baseLineWidth * 0.5}" fill="none" stroke-linejoin="round" stroke-linecap="round" />`);
                        }
                    }

                    svg += pathStrings.join('\n') + '\n</svg>';

                    const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `anglepath-${Date.now()}.svg`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);

                } catch (e) {
                    console.error("Failed to build SVG:", e);
                    alert("Could not export SVG. The current step count may be too large to generate a vector path string.");
                }

                isPaused = wasPaused;
                if (!isPaused) {
                    ui.pauseOverlay.style.display = 'none';
                } else {
                    ui.pauseOverlay.textContent = "PAUSED";
                }
            }, 100); 
        };

        ui.infoBtn.addEventListener('click', () => {
            const isHidden = ui.infoModal.style.display === 'none' || ui.infoModal.style.display === '';
            if (isHidden) {
                ui.infoModal.style.display = 'flex';
            } else {
                ui.infoModal.style.display = 'none';
            }
        });

        document.getElementById('fs-btn').addEventListener('click', () => {
            canvasContainer.requestFullscreen();
        });

        document.getElementById('save-btn').addEventListener('click', () => {
            saveImage();
        });

        ui.saveSvgBtn.addEventListener('click', () => {
            saveSVG();
        });

        document.getElementById('rec-btn').addEventListener('click', () => {
            toggleRec();
        });

        document.getElementById('random-btn').addEventListener('click', () => {
            generateRandom();
        });

        ui.speed.addEventListener('input', () => {
            ui.spdLabel.textContent = ui.speed.value;
        });

        updateConfigDropdown(); 
        updatePresetDropdown();
        compileFunction();
        
        if (ui.nAutoValue.checked) {
            applySymmetryLock();
        }

        liveLoop();

    </script>
</body>
</html>