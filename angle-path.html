<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angle Path Generator</title>
    <style>
        :root { --accent: #00d2ff; --bg: #050505; --panel: #111; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; 
            display: flex; flex-direction: column; 
            background: var(--bg); color: #fff; 
            margin: 0; height: 100vh; overflow: hidden; 
        }
        
        /* --- Header UI --- */
        header { 
            background: var(--panel); padding: 10px; 
            border-bottom: 1px solid #333; 
            display: flex; flex-wrap: wrap; justify-content: center; align-items: stretch;
            gap: 10px; z-index: 10;
        }
        
        .control-group { 
            background: #1a1a1a; padding: 10px 12px; border-radius: 6px; 
            display: flex; flex-direction: column; border: 1px solid #222;
            min-width: 160px; flex-grow: 1; max-width: 240px;
        }

        .toolbar-group {
            display: flex; flex-wrap: wrap; gap: 6px; align-items: center; justify-content: center;
            background: #1a1a1a; padding: 10px 12px; border-radius: 6px; border: 1px solid #222;
            flex-grow: 1; max-width: 100%; align-content: center;
        }

        .group-header { 
            display: flex; justify-content: space-between; align-items: center; 
            color: #aaa; font-size: 10px; font-weight: bold; text-transform: uppercase; 
            margin-bottom: 8px;
        }
        
        .group-header .num-input { width: 75px; text-align: right; padding: 3px 6px; height: auto; }
        
        .slider-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
        .slider-row input[type="range"] { flex-grow: 1; width: 100%; margin: 0; }

        .toggles-row { 
            display: flex; justify-content: space-between; align-items: center; 
            font-size: 9px; color: var(--accent); font-weight: bold; margin-top: auto;
            padding-top: 6px; min-height: 14px;
        }
        .toggles-row label { display: flex; align-items: center; gap: 4px; cursor: pointer; margin: 0; }
        .toggles-row input[type="checkbox"] { margin: 0; cursor: pointer; }

        /* --- Animation Settings UI --- */
        .anim-settings { 
            /* Override JS inline style to keep container height completely static */
            display: flex !important; 
            justify-content: space-between; gap: 8px; 
            margin-top: 8px; border-top: 1px dashed #333; padding-top: 8px; 
            transition: opacity 0.2s ease;
        }

        /* Visually disable Min/Max fields when ANIMATE is unchecked */
        .control-group:has(input[type="checkbox"][id$="-anim"]:not(:checked)) .anim-settings {
            opacity: 0.25;
            pointer-events: none; /* Prevents interaction when disabled */
        }
        
        .control-group:has(input[type="checkbox"][id$="-anim"]:not(:checked)) .anim-settings input {
            background: #111; border-color: #333; color: #666;
        }

        .anim-settings label { 
            font-size: 9px; color: #888; display: flex; flex-direction: column; gap: 4px;
            font-weight: bold; text-transform: uppercase; flex-grow: 1;
        }
        .anim-settings input.num-input { width: 100%; font-size: 10px; box-sizing: border-box; text-align: left; }
        
        /* Tweaks for combined groups */
        .combined-select { width: 100%; height: 26px; margin-bottom: 8px; }
        .toolbar-group button { margin: 0; height: 32px; }

        .label-row { display: flex; justify-content: space-between; align-items: center; color: #888; font-size: 9px; font-weight: bold; text-transform: uppercase; }
        .input-row { display: flex; align-items: center; gap: 8px; }
        .anim-unit { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .anim-unit label { font-size: 7px; color: var(--accent); font-weight: bold; cursor: pointer; }

        /* --- Main Layout --- */
        main { 
            flex-grow: 1; display: flex; flex-direction: row; 
            padding: 10px; gap: 10px; min-height: 0;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }

        .left-col { display: flex; flex-direction: column; width: 320px; gap: 10px; flex-shrink: 0; }
        .right-col { flex-grow: 1; display: flex; flex-direction: column; position: relative; border-radius: 6px; overflow: hidden; touch-action: none;}

        /* --- Canvas Area --- */
        #canvas-container { position: relative; height: 100%; width: 100%; display: flex; justify-content: center; align-items: center; }
        canvas { 
            background: transparent; border-radius: 4px; cursor: crosshair;
            max-height: 100%; max-width: 100%; object-fit: contain;
        }

        /* --- Selection Box Overlay --- */
        #selection-box {
            position: absolute; border: 1px dashed var(--accent);
            background: rgba(0, 210, 255, 0.15); pointer-events: none;
            display: none; z-index: 10;
        }

        /* --- Code Editor --- */
        .editor-container {
            flex-grow: 1; display: flex; flex-direction: column;
            background: var(--panel); border: 1px solid #333; border-radius: 6px;
            padding: 10px; min-height: 0;
        }
        .panel-header {
            font-size: 11px; letter-spacing: 1px; color: var(--accent);
            text-transform: uppercase; font-weight: bold; opacity: 0.8;
            margin-bottom: 8px; display: flex; justify-content: space-between;
        }
        select.preset-select {
            background: #222; color: #fff; border: 1px solid #444; 
            font-family: monospace; font-size: 11px; padding: 4px; 
            border-radius: 3px; width: 100%; cursor: pointer; margin-bottom: 8px;
        }
        textarea {
            flex-grow: 1; background: #0d0d0d; color: #ccc;
            border: 1px solid #333; border-radius: 4px;
            padding: 10px; font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px; line-height: 1.4; resize: none;
            outline: none; white-space: pre; margin-bottom: 8px;
        }
        textarea:focus { border-color: var(--accent); color: #fff; }
        .editor-actions { display: flex; gap: 8px; }

        /* --- Overlays --- */
        #pause-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7); color: var(--accent); padding: 15px 30px;
            border-radius: 8px; font-weight: bold; pointer-events: none;
            display: none; border: 1px solid var(--accent); text-transform: uppercase;
            z-index: 5; letter-spacing: 2px; text-align: center;
        }

        #rec-indicator {
            position: absolute; top: 20px; right: 20px; 
            background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 6px;
            display: none; align-items: center; gap: 10px; color: #fff;
            font-family: monospace; font-size: 14px; border: 1px solid #eb4d4b;
        }
        .dot { width: 10px; height: 10px; background: #eb4d4b; border-radius: 50%; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        * --- Info Modal --- */
        #info-modal {
            position: absolute; 
            top: 20px;            /* Consistent margin from top */
            bottom: 20px;         /* Consistent margin from bottom */
            left: 20px; 
            z-index: 20;
            background: rgba(17, 17, 17, 0.96); 
            backdrop-filter: blur(12px);
            border: 1px solid #333; 
            border-radius: 8px;
            width: 350px; 
            display: none;        /* Controlled by JS */
            flex-direction: column; /* Allows header to stay fixed if desired, or simple scrolling */
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            overflow: hidden;    /* Clips the inner scrollable area */
        }

        /* Create a scrollable container inside the modal */
        .info-content {
            padding: 25px;
            overflow-y: auto;    /* This ensures the scrollbar is internal */
            height: 100%;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) #222;
        }

        #info-modal h2 { margin-top: 0; color: var(--accent); font-size: 16px; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 10px;}
        #info-modal h3 { margin: 15px 0 5px 0; font-size: 12px; color: #fff; text-transform: uppercase; }
        #info-modal p { color: #aaa; margin: 0 0 10px 0; }
        #info-modal code { background: #222; padding: 2px 4px; border-radius: 3px; color: var(--accent); font-family: monospace;}
        
        .close-info { 
            position: absolute; top: 15px; right: 15px; cursor: pointer; 
            color: #666; font-size: 18px; z-index: 21; background: #111; 
            width: 24px; height: 24px; display: flex; align-items: center; 
            justify-content: center; border-radius: 4px;
        }
        .close-info:hover { color: #fff; background: #222; }

        /* Mobile adjustment for the info box */
        @media (max-width: 900px) {
            #info-modal {
                width: calc(100% - 40px);
                top: 60px; /* Leave space for mobile toggle button */
            }
        }

        /* --- Buttons & Inputs --- */
        button { 
            border: none; padding: 0 12px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; transition: 0.2s; 
            text-transform: uppercase; font-size: 10px; height: 34px; align-self: center;
        }
        .btn-run { background: var(--accent); color: #000; flex-grow: 1; }
        .btn-run:hover { filter: brightness(1.2); }
        .btn-rand { background: #a55eea; color: #fff; }
        .btn-rec { background: #eb4d4b; color: #fff; }
        .btn-util { background: #333; color: #ccc; }
        .btn-util:hover { background: #444; color: #fff; }
        .btn-sec { background: #333; color: #ccc; }
        .btn-sec:hover { background: #444; color: #fff; }
        .btn-info { background: transparent; border: 1px solid #444; color: #888; width: 34px; padding: 0; font-size: 14px; margin-top: 2px; }
        .btn-info:hover { color: #fff; border-color: #fff; }
        .btn-icon { padding: 0 8px; font-size: 14px; }
        #reset-zoom-btn { background: #f39c12; color: #fff; display: none; margin-top: 2px; }

        span.value { color: #fff; font-size: 12px; font-family: monospace; }
        input[type="range"] { accent-color: var(--accent); cursor: pointer; }
        input[type="number"].num-input { 
            width: 75px; background: #222; color: #fff; border: 1px solid #444; 
            font-size: 11px; padding: 4px; border-radius: 4px; font-family: monospace; outline: none;
        }
        input[type="number"].num-input:focus { border-color: var(--accent); }
        select { background: #222; color: #fff; border: 1px solid #444; font-size: 11px; padding: 4px; border-radius: 4px; outline: none; cursor: pointer;}
        select:hover { border-color: #666; }

        /* --- MOBILE RESPONSIVE --- */
        @media (max-width: 900px) {
            body { height: auto; overflow-y: auto; }
            header { height: auto; padding: 10px; justify-content: center; gap: 15px; }
            main { flex-direction: column; height: auto; overflow: visible; }
            .left-col { width: 100%; order: 2; }
            .right-col { width: 100%; order: 1; height: 55vh; min-height: 350px; }
            #matrix-wrapper { margin: 0 auto; max-width: 300px; }
            .editor-container { min-height: 300px; }
        }

        /* --- Mobile UI Toggle --- */
        #ui-toggle-btn { display: none; }

        @media (max-width: 900px) {
            #ui-toggle-btn { 
                display: block; position: fixed; top: 10px; left: 10px; 
                z-index: 1000; background: rgba(17, 17, 17, 0.8); 
                color: var(--accent); border: 1px solid var(--accent); 
                border-radius: 4px; padding: 0 12px; height: 32px;
                font-size: 10px; font-weight: bold; cursor: pointer;
                text-transform: uppercase; backdrop-filter: blur(5px);
            }
            /* Collapse logic for mobile */
            body.ui-collapsed header, body.ui-collapsed .left-col { display: none; }
            body.ui-collapsed .right-col { height: 100vh; min-height: 100vh; border-radius: 0; }
            body.ui-collapsed main { padding: 0; }
            body.ui-collapsed { height: 100vh; overflow: hidden; }
        }
    </style>
</head>
<body>

    <header id="ui-panel">
        <div class="control-group">
            <div class="group-header">
                <span>Steps (N)</span>
                <input type="number" id="n-number" class="num-input" min="1" max="5000000" step="1000" value="90000">
            </div>
            <div class="slider-row">
                <input type="range" id="n-input" min="3" max="6.69897" step="0.0001" value="4.9542">
            </div>
            <div class="toggles-row">
                <label for="n-anim"><input type="checkbox" id="n-anim"> ANIMATE</label>
                <label for="n-auto-value" title="Lock Symmetry"><input type="checkbox" id="n-auto-value"> AUTO N</label>
            </div>
            <div id="n-anim-settings" class="anim-settings">
                <label>Min <input type="number" id="n-anim-min" class="num-input" value="1000" min="1"></label>
                <label>Max <input type="number" id="n-anim-max" class="num-input" value="5000000" max="5000000"></label>
            </div>
        </div>

        <div class="control-group">
            <div class="group-header">
                <span>C Multiplier</span>
                <input type="number" id="c-number" class="num-input" min="0.001" max="2.000" step="0.001" value="0.024">
            </div>
            <div class="slider-row">
                <input type="range" id="c-input" min="0.001" max="2.000" step="0.001" value="0.024">
            </div>
            <div class="toggles-row">
                <label for="c-anim"><input type="checkbox" id="c-anim"> ANIMATE</label>
            </div>
            <div id="c-anim-settings" class="anim-settings">
                <label>Min <input type="number" id="c-anim-min" class="num-input" value="0.000" step="0.001"></label>
                <label>Max <input type="number" id="c-anim-max" class="num-input" value="2.000" step="0.001"></label>
            </div>
        </div>

        <div class="control-group">
            <div class="group-header">
                <span>Line Width</span>
                <input type="number" id="lw-number" class="num-input" min="0.01" max="10.0" step="0.05" value="1.0" style="width: 50px;">
            </div>
            <div class="slider-row" style="margin-bottom: 12px;">
                <input type="range" id="lw-input" min="0.01" max="10.0" step="0.05" value="1.0">
            </div>
            
            <div class="group-header">
                <span>Speed</span>
                <span id="spd-val" style="color: var(--accent); font-family: monospace; font-size: 12px;">5</span>
            </div>
            <div class="slider-row" style="margin-bottom: 0;">
                <input type="range" id="speed-input" min="1" max="10" value="5">
            </div>
        </div>

        <div class="control-group">
            <div class="group-header"><span>Appearance</span></div>
            <select id="style-select" class="combined-select">
                <option value="neon">Neon Glow (Dark)</option>
                <option value="rainbow">Spectrum (Dark)</option>
                <option value="solid">Solid White (Dark)</option>
                <option value="light">Solid Black (Light)</option>
                <option value="light-glow">Neon Glow (Light)</option>
            </select>
            
            <div class="group-header" style="margin-top: 4px;"><span>Configuration</span></div>
            <div style="display: flex; gap: 4px; align-items: center;">
                <select id="config-select" style="flex-grow: 1; width: 0; height: 26px;">
                    <option value="">Load...</option>
                    <optgroup label="Built-in" id="builtin-configs-group"></optgroup>
                    <optgroup label="Saved" id="saved-configs-group"></optgroup>
                </select>
                <button id="save-config-btn" class="btn-sec btn-icon" title="Save Config" style="height: 26px; padding: 0 6px;">üíæ</button>
                <button id="export-config-btn" class="btn-sec btn-icon" title="Export to File" style="height: 26px; padding: 0 6px;">üì§</button>
                <button id="import-config-btn" class="btn-sec btn-icon" title="Import from File" style="height: 26px; padding: 0 6px;">üì•</button>
            </div>
            <input type="file" id="import-file" style="display:none" accept=".json">
        </div>

        <div class="toolbar-group">
            <button id="info-btn" class="btn-info" title="Information" style="border-radius: 50%; width: 26px; height: 26px; padding: 0;">?</button>
            <button id="reset-zoom-btn">üîç Reset</button>
            <button id="random-btn" class="btn-rand">üé≤ Rand</button>
            <button id="save-btn" class="btn-util">üì∏ Canvas</button>
            <button id="save-svg-btn" class="btn-util">üìÑ SVG</button>
            <button id="rec-btn" class="btn-rec">‚è∫ Rec</button>
            <button id="fs-btn" class="btn-util">‚õ∂ Full</button>
            <button onclick="window.location.href='index.html'" class="btn-util">üè†</button>
        </div>
    </header>

    <main>
        <div class="left-col">
            <div class="editor-container">
                <div class="panel-header">Function f(n)</div>
                <select id="preset-select" class="preset-select">
                    <optgroup label="Standard Math">
                        <option value="n2">Square (n¬≤)</option>
                        <option value="n">Linear (n)</option>
                        <option value="n3">Cube (n¬≥)</option>
                        <option value="nlog">n * log(n)</option>
                        <option value="nsin">n * sin(n)</option>
                        <option value="sqrt">Square Root (‚àön)</option>
                    </optgroup>
                    <optgroup label="User Saved" id="user-presets-group">
                    </optgroup>
                </select>

                <textarea id="code-area" spellcheck="false">return n * n;</textarea>

                <div class="editor-actions">
                    <button id="save-preset-btn" class="btn-sec">üíæ Save Func</button>
                    <button id="run-btn" class="btn-run">‚ñ∂ Update Canvas</button>
                </div>
                <div id="code-error" style="color: #ff4757; font-size: 10px; margin-top: 5px; display: none;">Error</div>
            </div>
            
            <div style="padding: 10px; background: var(--panel); border: 1px solid #222; border-radius: 6px; font-size: 11px; color: #888;">
                <div class="panel-header" style="margin-bottom: 4px;">Context Variables</div>
                <p style="margin: 0;"><strong>n</strong>: The current iteration step (Integer)</p>
            </div>
        </div>

        <div class="right-col">
            <div id="info-modal">
                <span class="close-info" onclick="document.getElementById('info-modal').style.display='none'">&times;</span>
                <div class="info-content">
                    <h2>Angle Path Generator</h2>
                    <p>This generator draws a sequence of lines based on a simple mathematical rule, commonly known in turtle graphics.</p>
                    
                    <h3>The Algorithm</h3>
                    <p>Starting at the origin, a line of unit length is drawn. At each step <code>n</code>, the angle of the line changes by a function <code>f(n)</code>. The new line is then appended to the previous one.</p>
                    <p><code>Angle<sub>n</sub> = Angle<sub>n-1</sub> + (c &times; f(n) &times; &pi;/180)</code></p>
                    
                    <h3>Custom Function Engine</h3>
                    <p>You can write custom JavaScript to dictate the curve behavior. The compiler parses the code and executes it natively up to 15 million times per frame.</p>
                    
                    <h3>Centering & Scaling</h3>
                    <p>To ensure the pattern remains perfectly visible regardless of the parameters, the code calculates the exact bounding box of the geometry on every frame and dynamically scales it to fit the screen.</p>
                    
                    <h3>Symmetry Lock (Auto N)</h3>
                    <p>Checking <strong>Lock Symmetry</strong> automates the calculation of N based on the constant C. It uses the mathematical relation $c \cdot N / m = 180$ to find the smallest number of steps required to complete a rotationally symmetric rosette. This allows you to explore different C values while the shape stays perfectly "closed."</p>
                    
                    <p style="margin-top: 20px; font-size: 10px; opacity: 0.5;">End of Documentation</p>
                </div>
            </div>

            <div id="canvas-container">
                <canvas id="mainCanvas" width="1600" height="1600"></canvas>
                <div id="selection-box"></div>
                <div id="pause-overlay">Paused</div>
                <div id="rec-indicator"><div class="dot"></div><span id="rec-timer">00:00</span></div>
            </div>
            <div id="status" style="position: absolute; bottom: 5px; right: 10px; font-size: 10px; color: #555; font-family: monospace; z-index: 2; pointer-events: none; mix-blend-mode: difference;">CLICK/DRAG TO ZOOM | RIGHT-CLICK OUT | QUICK CLICK PAUSE</div>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const canvasContainer = document.getElementById('canvas-container');
        const selectionBox = document.getElementById('selection-box');
        
        const ui = {
            nSlider: document.getElementById('n-input'),
            nNumber: document.getElementById('n-number'), 
            nAnim: document.getElementById('n-anim'),
            nAnimSettings: document.getElementById('n-anim-settings'),
            nAnimMin: document.getElementById('n-anim-min'),
            nAnimMax: document.getElementById('n-anim-max'),
            nAutoValue: document.getElementById('n-auto-value'),

            cSlider: document.getElementById('c-input'),
            cNumber: document.getElementById('c-number'), 
            cAnim: document.getElementById('c-anim'),
            cAnimSettings: document.getElementById('c-anim-settings'),
            cAnimMin: document.getElementById('c-anim-min'),
            cAnimMax: document.getElementById('c-anim-max'),

            speed: document.getElementById('speed-input'), 
            spdLabel: document.getElementById('spd-val'),

            lwSlider: document.getElementById('lw-input'),
            lwNumber: document.getElementById('lw-number'),

            style: document.getElementById('style-select'), 
            pauseOverlay: document.getElementById('pause-overlay'),
            recBtn: document.getElementById('rec-btn'), 
            recInd: document.getElementById('rec-indicator'), 
            recTimer: document.getElementById('rec-timer'),
            infoBtn: document.getElementById('info-btn'), 
            infoModal: document.getElementById('info-modal'),
            resetZoomBtn: document.getElementById('reset-zoom-btn'),
            
            editor: document.getElementById('code-area'), 
            presetSelect: document.getElementById('preset-select'),
            userGroup: document.getElementById('user-presets-group'), 
            runBtn: document.getElementById('run-btn'),
            savePresetBtn: document.getElementById('save-preset-btn'), 
            errorMsg: document.getElementById('code-error'),

            configSelect: document.getElementById('config-select'),
            builtinConfigGroup: document.getElementById('builtin-configs-group'),
            savedConfigGroup: document.getElementById('saved-configs-group'),
            saveConfigBtn: document.getElementById('save-config-btn'),
            exportConfigBtn: document.getElementById('export-config-btn'),
            importConfigBtn: document.getElementById('import-config-btn'),
            importFile: document.getElementById('import-file'),

            saveSvgBtn: document.getElementById('save-svg-btn')
        };

        const builtinConfigs = {
            "Default Neon": { n: 90000, c: 0.024, speed: 5, style: "neon", nAnim: false, cAnim: false, code: "return n * n;" },
            "Light Glow Core": { n: 250000, c: 0.150000, speed: 6, style: "light-glow", nAnim: false, cAnim: false, code: "return n * Math.log(n);" },
            "Rainbow Web": { n: 120000, c: 89.500000, speed: 4, style: "rainbow", nAnim: false, cAnim: false, code: "return n;" },
            "Sine Petals (Light)": { n: 50000, c: 1.000000, speed: 5, style: "light", nAnim: false, cAnim: false, code: "return n * Math.sin(n);" }
        };
        
        let savedConfigs = JSON.parse(localStorage.getItem('angle_path_configs') || '{}');
        let currentRenderState = { N: 0, c: 0, time: 0, bounds: { minX: 0, maxX: 0, minY: 0, maxY: 0 } };

        function updateConfigDropdown() {
            ui.builtinConfigGroup.innerHTML = '';
            Object.keys(builtinConfigs).forEach(name => {
                const opt = document.createElement('option');
                opt.value = `builtin:${name}`;
                opt.textContent = name;
                ui.builtinConfigGroup.appendChild(opt);
            });

            ui.savedConfigGroup.innerHTML = '';
            Object.keys(savedConfigs).forEach(name => {
                const opt = document.createElement('option');
                opt.value = `saved:${name}`;
                opt.textContent = name;
                ui.savedConfigGroup.appendChild(opt);
            });
        }

        function getCurrentConfig() {
            return {
                n: userBase.n,
                c: userBase.c,
                nAnim: ui.nAnim.checked,
                cAnim: ui.cAnim.checked,
                nAnimMin: parseInt(ui.nAnimMin.value),
                nAnimMax: parseInt(ui.nAnimMax.value),
                cAnimMin: parseFloat(ui.cAnimMin.value),
                cAnimMax: parseFloat(ui.cAnimMax.value),
                speed: parseInt(ui.speed.value),
                lineWidth: parseFloat(ui.lwSlider.value),
                style: ui.style.value,
                code: ui.editor.value
            };
        }

        function loadConfig(config) {
            if (!config) return;
            
            // Uncheck animations to safely set values
            ui.nAnim.checked = false;
            ui.cAnim.checked = false;

            if (config.code) {
                ui.editor.value = config.code;
            }
            
            // Determine and enforce precision for loaded code before updating C values
            updateCPrecision();

            updateN(config.n, false);
            updateC(config.c);

            // Set Min/Max limits if they exist in config
            if (config.nAnimMin !== undefined) ui.nAnimMin.value = config.nAnimMin;
            if (config.nAnimMax !== undefined) ui.nAnimMax.value = config.nAnimMax;
            if (config.cAnimMin !== undefined) ui.cAnimMin.value = parseFloat(config.cAnimMin).toFixed(cPrecision);
            if (config.cAnimMax !== undefined) ui.cAnimMax.value = parseFloat(config.cAnimMax).toFixed(cPrecision);

            // Re-apply animations if specified and trigger UI expand
            ui.nAnim.checked = !!config.nAnim;
            ui.cAnim.checked = !!config.cAnim;
            ui.nAnimSettings.style.display = ui.nAnim.checked ? 'flex' : 'none';
            ui.cAnimSettings.style.display = ui.cAnim.checked ? 'flex' : 'none';

            ui.speed.value = config.speed || 5;
            ui.spdLabel.textContent = ui.speed.value;

            if (config.lineWidth !== undefined) {
                updateLineWidth(config.lineWidth);
            } else {
                updateLineWidth(1.0); // Default for older configs
            }

            ui.style.value = config.style || 'neon';

            compileFunction();
            resetZoom(); 
        }

        // Config Event Listeners
        ui.configSelect.addEventListener('change', (e) => {
            const val = e.target.value;
            if (!val) return;
            let cfg = null;
            if (val.startsWith('builtin:')) {
                cfg = builtinConfigs[val.split(':')[1]];
            } else if (val.startsWith('saved:')) {
                cfg = savedConfigs[val.split(':')[1]];
            }
            if (cfg) loadConfig(cfg);
        });

        ui.saveConfigBtn.addEventListener('click', () => {
            const name = prompt("Enter a name to save this full configuration:");
            if (name) {
                savedConfigs[name] = getCurrentConfig();
                localStorage.setItem('angle_path_configs', JSON.stringify(savedConfigs));
                updateConfigDropdown();
                ui.configSelect.value = `saved:${name}`;
            }
        });

        ui.exportConfigBtn.addEventListener('click', () => {
            const cfg = getCurrentConfig();
            const blob = new Blob([JSON.stringify(cfg, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `anglepath-config-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        ui.importConfigBtn.addEventListener('click', () => ui.importFile.click());

        ui.importFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const cfg = JSON.parse(ev.target.result);
                    loadConfig(cfg);
                    ui.configSelect.value = ""; 
                } catch (err) {
                    alert("Invalid JSON configuration file.");
                }
            };
            reader.readAsText(file);
            ui.importFile.value = ''; 
        });

        // --- ZOOM STATE ---
        let isZoomed = false;
        let zoomBounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
        let activeTransform = { scale: 1, cx: 0, cy: 0 }; 

        const presets = {
            'n2': 'return n * n;',
            'n': 'return n;',
            'n3': 'return n * n * n;',
            'nlog': 'return n * Math.log(n);',
            'nsin': 'return n * Math.sin(n);',
            'sqrt': 'return Math.sqrt(n);'
        };

        let userPresets = JSON.parse(localStorage.getItem('angle_path_presets') || '{}');
        let activeFunc = (n) => n * n;

        let isPaused = false;
        let animationFrameId;
        let userBase = { n: 90000, c: 0.024 };
        let cPrecision = 3; // Core dynamic precision state tracking

        let glowStartN = 0;
        let glowEndN = 0;
        let glowIntensity = 0;

        let eraseStartN = 0;
        let eraseEndN = 0;
        let eraseIntensity = 0;
        
        let virtualTime = 0, lastRealTime = performance.now();
        let mediaRecorder, recordedChunks = [], recStartTime;

        let points = new Float32Array((5000000 + 1) * 2);

        function updatePresetDropdown() {
            ui.userGroup.innerHTML = '';
            Object.keys(userPresets).forEach(name => {
                const opt = document.createElement('option');
                opt.value = `user:${name}`;
                opt.textContent = name;
                ui.userGroup.appendChild(opt);
            });
        }

        function updateCPrecision() {
            const code = ui.editor.value.trim();
            // Check exactly matching 3-digit functions
            const isStandard3Digit = (
                code === presets['n2'] || 
                code === presets['n'] || 
                code === presets['n3'] || 
                code === presets['nlog'] || 
                code === presets['sqrt']
            );
            
            cPrecision = isStandard3Digit ? 3 : 6;

            const step = cPrecision === 6 ? "0.000001" : "0.001";
            const minVal = cPrecision === 6 ? "0.000001" : "0.001";

            ui.cSlider.step = step;
            ui.cSlider.min = minVal;
            ui.cNumber.step = step;
            ui.cNumber.min = minVal;
            ui.cAnimMin.step = step;
            ui.cAnimMax.step = step;

            // Enforce limits with new precision layout
            let currentC = parseFloat(userBase.c);
            if (currentC < parseFloat(minVal)) currentC = parseFloat(minVal);
            
            userBase.c = currentC;
            ui.cSlider.value = currentC.toFixed(cPrecision);
            ui.cNumber.value = currentC.toFixed(cPrecision);
            
            ui.cAnimMin.value = parseFloat(ui.cAnimMin.value || 0).toFixed(cPrecision);
            ui.cAnimMax.value = parseFloat(ui.cAnimMax.value || 2).toFixed(cPrecision);
        }

        function compileFunction() {
            try {
                const code = ui.editor.value;
                const testFunc = new Function('n', code);
                testFunc(1); 
                activeFunc = testFunc;
                
                ui.errorMsg.style.display = 'none';
                
                updateCPrecision();
                
                if (isPaused) { isPaused = false; ui.pauseOverlay.style.display = 'none'; }
            } catch (err) {
                ui.errorMsg.textContent = "Error: " + err.message;
                ui.errorMsg.style.display = 'block';
            }
        }

        function calculatePath(N, c_val) {
            let x = 0, y = 0, angle = 0;
            const c = c_val * (Math.PI / 180); 
            let minX = 0, maxX = 0, minY = 0, maxY = 0;
            
            points[0] = 0; 
            points[1] = 0;

            for (let n = 1; n <= N; n++) {
                let stepAngle = activeFunc(n);
                angle += stepAngle * c;
                x += Math.cos(angle);
                y += Math.sin(angle);

                if (x < minX) minX = x; else if (x > maxX) maxX = x;
                if (y < minY) minY = y; else if (y > maxY) maxY = y;

                points[n * 2] = x;
                points[n * 2 + 1] = y;
            }
            
            return { minX, maxX, minY, maxY };
        }

        function performRender(N, c_val, time) {
            const style = ui.style.value;
            const isLightTheme = style === 'light' || style === 'light-glow';
            
            const geoBounds = calculatePath(N, c_val);
            let renderBounds = isZoomed ? zoomBounds : geoBounds;
            
            // Store the currently rendered properties for SVG export
            currentRenderState = { N, c: c_val, time, bounds: renderBounds };
            
            ctx.fillStyle = isLightTheme ? '#ffffff' : '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const bbWidth = renderBounds.maxX - renderBounds.minX;
            const bbHeight = renderBounds.maxY - renderBounds.minY;
            
            const scale = Math.min(canvas.width / (bbWidth || 1), canvas.height / (bbHeight || 1)) * 0.90;
            const bbCenterX = (renderBounds.maxX + renderBounds.minX) / 2;
            const bbCenterY = (renderBounds.maxY + renderBounds.minY) / 2;

            activeTransform = { scale, cx: bbCenterX, cy: bbCenterY };

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(-bbCenterX, -bbCenterY);

            if (style === 'neon') ctx.globalCompositeOperation = 'lighter';
            else if (style === 'light-glow') ctx.globalCompositeOperation = 'multiply';
            else ctx.globalCompositeOperation = 'source-over';
            
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            let lwMultiplier = parseFloat(ui.lwSlider.value) || 1.0;
            let baseLineWidth = (Math.max(0.1, 80000 / N) / scale) * lwMultiplier;
            
            if (isZoomed) baseLineWidth *= 1.5;

            const MAX_PATH_SIZE = 500000; 
            const numChunks = Math.ceil(N / MAX_PATH_SIZE);

            for (let i = 0; i < numChunks; i++) {
                const start = i * MAX_PATH_SIZE;
                const end = Math.min((i + 1) * MAX_PATH_SIZE, N);

                ctx.beginPath();
                ctx.moveTo(points[start * 2], points[start * 2 + 1]);
                
                for (let j = start + 1; j <= end; j++) {
                    ctx.lineTo(points[j * 2], points[j * 2 + 1]);
                }

                if (style === 'rainbow') {
                    ctx.lineWidth = baseLineWidth * 1.5;
                    ctx.strokeStyle = `hsl(${(i / numChunks) * 360 + (time * 50)}, 90%, 60%)`;
                    ctx.stroke();
                } else if (style === 'neon') {
                    ctx.lineWidth = baseLineWidth;
                    ctx.strokeStyle = `rgba(0, 210, 255, 0.4)`;
                    ctx.stroke();
                    ctx.lineWidth = baseLineWidth * 0.3;
                    ctx.strokeStyle = `rgba(255, 255, 255, 0.8)`;
                    ctx.stroke();
                } else if (style === 'light-glow') {
                    ctx.lineWidth = baseLineWidth * 1.5;
                    ctx.strokeStyle = `rgba(255, 0, 128, 0.3)`;
                    ctx.stroke();
                    ctx.lineWidth = baseLineWidth * 0.4;
                    ctx.strokeStyle = `rgba(30, 30, 30, 0.9)`; 
                    ctx.stroke();
                } else if (style === 'light') {
                    ctx.lineWidth = baseLineWidth * 0.5;
                    ctx.strokeStyle = `rgba(10, 10, 10, 0.9)`;
                    ctx.stroke();
                } else {
                    ctx.lineWidth = baseLineWidth * 0.5;
                    ctx.strokeStyle = `#ffffff`;
                    ctx.stroke();
                }
            }

            if (glowIntensity > 0 && glowEndN > glowStartN && N >= glowStartN) {
                ctx.beginPath();
                
                // Start 1 step early so it connects seamlessly to the old line
                const startIdx = Math.max(0, glowStartN - 1);
                const endIdx = Math.min(N, glowEndN);
                
                ctx.moveTo(points[startIdx * 2], points[startIdx * 2 + 1]);
                for (let j = startIdx + 1; j <= endIdx; j++) {
                    ctx.lineTo(points[j * 2], points[j * 2 + 1]);
                }

                // Force composite over everything else so the glow pops
                ctx.globalCompositeOperation = 'source-over';
                
                // 1. Thick colored outer glow
                ctx.lineWidth = baseLineWidth * 6;
                ctx.strokeStyle = isLightTheme 
                    ? `rgba(255, 50, 80, ${glowIntensity * 0.6})`  // Red/Pink for light themes
                    : `rgba(255, 215, 0, ${glowIntensity * 0.6})`; // Gold/Yellow for dark themes
                ctx.stroke();

                // 2. Bright inner core
                ctx.lineWidth = baseLineWidth * 2;
                ctx.strokeStyle = `rgba(255, 255, 255, ${glowIntensity})`;
                ctx.stroke();
            }

            if (eraseIntensity > 0 && eraseEndN > eraseStartN) {
                ctx.beginPath();
                
                const startIdx = Math.max(0, eraseStartN - 1);
                const endIdx = eraseEndN;
                
                // The points array still holds the old math!
                ctx.moveTo(points[startIdx * 2], points[startIdx * 2 + 1]);
                for (let j = startIdx + 1; j <= endIdx; j++) {
                    ctx.lineTo(points[j * 2], points[j * 2 + 1]);
                }

                ctx.globalCompositeOperation = 'source-over';
                
                // 1. Red outer "burn"
                ctx.lineWidth = baseLineWidth * 4;
                ctx.strokeStyle = `rgba(255, 50, 50, ${eraseIntensity * 0.8})`;
                ctx.stroke();

                // 2. Fading core
                ctx.lineWidth = baseLineWidth;
                ctx.strokeStyle = `rgba(255, 200, 200, ${eraseIntensity})`;
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // --- ZOOM & INPUT HANDLERS ---
        function screenToLogical(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = (screenX - rect.left) * scaleX;
            const y = (screenY - rect.top) * scaleY;

            const logicalX = (x - canvas.width / 2) / activeTransform.scale + activeTransform.cx;
            const logicalY = (y - canvas.height / 2) / activeTransform.scale + activeTransform.cy;
            return { x: logicalX, y: logicalY };
        }

        let isDragging = false;
        let isPanning = false;
        let startX = 0, startY = 0;
        let startZoomBounds = null;
        let lastPinchDist = null;

        canvasContainer.addEventListener('pointerdown', (e) => {
            if (e.pointerType === 'mouse' && e.button !== 0) return; 
            if (e.pointerType === 'touch' && lastPinchDist !== null) return; // Prevent pan if pinching

            isDragging = true;
            isPanning = false;
            startX = e.clientX;
            startY = e.clientY;
            
            // Ensure selection box is hidden (legacy logic cleanup)
            selectionBox.style.display = 'none';
        });

        canvasContainer.addEventListener('pointermove', (e) => {
            if (!isDragging) return;
            if (e.pointerType === 'touch' && lastPinchDist !== null) return; // Don't pan during a pinch

            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const dist = Math.hypot(dx, dy);

            // Initialize panning threshold
            if (!isPanning && dist > 10) {
                isPanning = true;
                if (!isZoomed) {
                    zoomBounds = calculatePath(userBase.n, userBase.c);
                    isZoomed = true;
                    ui.resetZoomBtn.style.display = 'inline-block';
                }
                startZoomBounds = { ...zoomBounds };
            }

            if (isPanning) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                // Convert screen pixel movement to logical coordinate movement
                const logicalDx = (dx * scaleX) / activeTransform.scale;
                const logicalDy = (dy * scaleY) / activeTransform.scale;

                // Shift bounds opposite to drag direction to move the "camera"
                zoomBounds.minX = startZoomBounds.minX - logicalDx;
                zoomBounds.maxX = startZoomBounds.maxX - logicalDx;
                zoomBounds.minY = startZoomBounds.minY - logicalDy;
                zoomBounds.maxY = startZoomBounds.maxY - logicalDy;
            }
        });

        canvasContainer.addEventListener('pointerup', (e) => {
            if (!isDragging) return;
            isDragging = false;

            if (!isPanning) {
                // Quick click/touch to pause
                isPaused = !isPaused;
                ui.pauseOverlay.textContent = "PAUSED";
                ui.pauseOverlay.style.display = isPaused ? 'block' : 'none';
            }
            isPanning = false;
        });

        canvasContainer.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            resetZoom();
        });

        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (!isZoomed) {
                zoomBounds = calculatePath(userBase.n, userBase.c);
                isZoomed = true;
                ui.resetZoomBtn.style.display = 'inline-block';
            }

            const pointerLogical = screenToLogical(e.clientX, e.clientY);
            const zoomFactor = e.deltaY > 0 ? 1.2 : 0.8; 

            zoomBounds.minX = pointerLogical.x - (pointerLogical.x - zoomBounds.minX) * zoomFactor;
            zoomBounds.maxX = pointerLogical.x + (zoomBounds.maxX - pointerLogical.x) * zoomFactor;
            zoomBounds.minY = pointerLogical.y - (pointerLogical.y - zoomBounds.minY) * zoomFactor;
            zoomBounds.maxY = pointerLogical.y + (zoomBounds.maxY - pointerLogical.y) * zoomFactor;
        }, { passive: false });

        canvasContainer.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                isDragging = false; 
                isPanning = false;
                lastPinchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const currentDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );

                if (lastPinchDist) {
                    if (!isZoomed) {
                        zoomBounds = calculatePath(userBase.n, userBase.c);
                        isZoomed = true;
                        ui.resetZoomBtn.style.display = 'inline-block';
                    }

                    const zoomFactor = lastPinchDist / currentDist; 
                    const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    const midLogical = screenToLogical(midX, midY);

                    // Zoom naturally towards the exact midpoint of the pinch
                    zoomBounds.minX = midLogical.x - (midLogical.x - zoomBounds.minX) * zoomFactor;
                    zoomBounds.maxX = midLogical.x + (zoomBounds.maxX - midLogical.x) * zoomFactor;
                    zoomBounds.minY = midLogical.y - (midLogical.y - zoomBounds.minY) * zoomFactor;
                    zoomBounds.maxY = midLogical.y + (zoomBounds.maxY - midLogical.y) * zoomFactor;
                }
                lastPinchDist = currentDist;
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                lastPinchDist = null;
            }
        });

        function resetZoom() {
            isZoomed = false;
            ui.resetZoomBtn.style.display = 'none';
        }
        ui.resetZoomBtn.addEventListener('click', resetZoom);

        // --- END ZOOM HANDLERS ---

        function liveLoop() {
            const now = performance.now();
            const delta = (now - lastRealTime) / 1000;
            lastRealTime = now;

            if (glowIntensity > 0) {
                glowIntensity -= delta * 1.2; // Fades out in ~0.8 seconds
                if (glowIntensity < 0) glowIntensity = 0;
            }

            if (eraseIntensity > 0) {
                eraseIntensity -= delta * 1.5; // Fades a bit faster (~0.66 seconds)
                if (eraseIntensity < 0) eraseIntensity = 0;
            }

            if (!isPaused) {
                virtualTime += delta * Math.pow(2.0, parseInt(ui.speed.value) - 1) * 0.0025; 
                const cycle = (virtualTime % 4) / 4;
                const pingPong = 1 - Math.abs(2 * cycle - 1);

                let aN = userBase.n;
                let aC = userBase.c;
                
                if (ui.nAnim.checked) {
                    const easedProgress = Math.pow(pingPong, 2); 
                    const minN = parseInt(ui.nAnimMin.value) || 1;
                    const maxN = parseInt(ui.nAnimMax.value) || 5000000;
                    aN = Math.floor(minN + (maxN - minN) * easedProgress);
                    
                    ui.nNumber.value = aN;
                    ui.nSlider.value = Math.log10(Math.max(1, aN)); // Keep it above 0 to prevent log issues
                } 
                else if (ui.cAnim.checked) {
                    const minC = parseFloat(ui.cAnimMin.value) || 0;
                    const maxC = parseFloat(ui.cAnimMax.value) || 2.0;
                    aC = minC + ((maxC - minC) * pingPong);

                    ui.cSlider.value = aC.toFixed(cPrecision);
                    ui.cNumber.value = aC.toFixed(cPrecision);
                }
                
                performRender(aN, aC, virtualTime);
            }
            
            updateRecTimer();
            animationFrameId = requestAnimationFrame(liveLoop);
        }

        // --- ROSETTE ALGORITHM ---
        function calculateRosetteN(C) {
            if (C <= 0) return null;
            
            // 1. Find Raw Period
            let P_raw = 0;
            for (let u = 1; u <= 10000; u++) {
                let val = (180 * u) / C;
                if (Math.abs(val - Math.round(val)) < 1e-6) {
                    P_raw = Math.round(val);
                    break;
                }
            }
            if (P_raw === 0) return null; // Fallback if no clean period is found

            // 2. The Inversion Check
            let remainder = (C * P_raw * P_raw) % 360;
            let P_true = P_raw;
            // Account for float precision
            if (Math.abs(remainder - 180) < 1e-4 || Math.abs(remainder + 180) < 1e-4) {
                P_true = P_raw * 2;
            }

            // 3. Find Sector Angle
            let p = P_true;
            let sumAngle = C * p * (p + 1) * (2 * p + 1) / 6;
            let deltaTheta = Math.round(sumAngle % 360);
            if (deltaTheta < 0) deltaTheta += 360;
            if (deltaTheta === 360) deltaTheta = 0;

            // 4. Calculate Petals
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            let m = 360 / gcd(360, deltaTheta);

            // 5. Compute Total N
            return p * m;
        }
        // -------------------------

        const updateN = (val, fromSlider = false) => {
            let v;
            if (fromSlider) {
                v = Math.round(Math.pow(10, parseFloat(val)));
            } else {
                v = parseInt(val);
            }

            if (isNaN(v)) v = 1000;
            if (v > 5000000) v = 5000000;

            if (v > userBase.n && !ui.nAnim.checked) {
                glowStartN = userBase.n;
                glowEndN = v;
                glowIntensity = 1.0; 
                eraseIntensity = 0; // Cancel any active erase to prevent overlap
            } else if (v < userBase.n && !ui.nAnim.checked) {
                eraseStartN = v;
                eraseEndN = userBase.n;
                eraseIntensity = 1.0;
                glowIntensity = 0; // Cancel any active glow
            }

            userBase.n = v;
            ui.nNumber.value = v;
            ui.nSlider.value = Math.log10(v).toFixed(5);

            if (isPaused) { isPaused = false; ui.pauseOverlay.style.display = 'none'; }
        };

        function applySymmetryLock() {
            const perfectN = calculateRosetteN(userBase.c);
            if (perfectN) {
                const clampedN = Math.min(perfectN, 5000000);
                updateN(clampedN, false); // false prevents double-render
            }
        }

        ui.nSlider.oninput = (e) => updateN(e.target.value, true);
        ui.nNumber.onchange = (e) => updateN(e.target.value, false);

        const updateC = (val) => {
            let v = parseFloat(val);
            const minVal = cPrecision === 6 ? 0.000001 : 0.001;
            if (v < minVal) v = minVal; 
            
            userBase.c = v;
            ui.cSlider.value = v.toFixed(cPrecision);
            ui.cNumber.value = v.toFixed(cPrecision);

            if (ui.nAutoValue.checked) {
                applySymmetryLock();
            }
            
            if (isPaused) 
            { 
                isPaused = false; 
                ui.pauseOverlay.style.display = 'none'; 
            }
        };

        ui.cSlider.oninput = (e) => updateC(e.target.value);
        ui.cNumber.onchange = (e) => updateC(e.target.value);

        const updateLineWidth = (val) => {
            let v = parseFloat(val);
            if (v < 0.01) v = 0.01;
            ui.lwSlider.value = v.toFixed(2);
            ui.lwNumber.value = v.toFixed(2);
            
            // Unpause the canvas to show the updated line thickness immediately
            if (isPaused) { 
                isPaused = false; 
                ui.pauseOverlay.style.display = 'none'; 
            }
        };

        ui.lwSlider.oninput = (e) => updateLineWidth(e.target.value);
        ui.lwNumber.onchange = (e) => updateLineWidth(e.target.value);

        // Mutual Exclusivity and Dynamic Min/Max Logic
        ui.nAnim.addEventListener('change', () => {
            ui.nAnimSettings.style.display = ui.nAnim.checked ? 'flex' : 'none';
            if (ui.nAnim.checked) {
                ui.cAnim.checked = false;
                ui.cAnimSettings.style.display = 'none';
                
                // --- Sync virtualTime to the current N value ---
                const minN = parseInt(ui.nAnimMin.value) || 1;
                const maxN = parseInt(ui.nAnimMax.value) || 5000000;
                // Clamp current N to ensure it falls within the anim bounds
                let currentN = Math.max(minN, Math.min(maxN, userBase.n));
                
                // Reverse the easedProgress math: Math.pow(pingPong, 2)
                let pingPongSq = (maxN - minN) === 0 ? 0 : (currentN - minN) / (maxN - minN);
                let pingPong = Math.sqrt(pingPongSq);
                
                // Set the cycle to the upward slope phase
                let cycle = pingPong / 2; 
                virtualTime = Math.floor(virtualTime / 4) * 4 + (cycle * 4);
                
            } else {
                userBase.n = parseInt(ui.nNumber.value);
            }
        });

        ui.cAnim.addEventListener('change', () => {
            ui.cAnimSettings.style.display = ui.cAnim.checked ? 'flex' : 'none';
            if (ui.cAnim.checked) {
                ui.nAnim.checked = false;
                ui.nAnimSettings.style.display = 'none';
                
                // --- Sync virtualTime to the current C value ---
                const minC = parseFloat(ui.cAnimMin.value) || 0;
                const maxC = parseFloat(ui.cAnimMax.value) || 2.0;
                // Clamp current C to ensure it falls within the anim bounds
                let currentC = Math.max(minC, Math.min(maxC, userBase.c));
                
                // Reverse the linear pingPong math
                let pingPong = (maxC - minC) === 0 ? 0 : (currentC - minC) / (maxC - minC);
                
                // Set the cycle to the upward slope phase
                let cycle = pingPong / 2; 
                virtualTime = Math.floor(virtualTime / 4) * 4 + (cycle * 4);
                
            } else {
                userBase.c = parseFloat(ui.cSlider.value);
            }
        });

        ui.presetSelect.addEventListener('change', (e) => {
            const val = e.target.value;
            if (val.startsWith('user:')) {
                ui.editor.value = userPresets[val.split(':')[1]];
            } else if (presets[val]) {
                ui.editor.value = presets[val];
            }
            compileFunction(); 
        });

        ui.runBtn.addEventListener('click', compileFunction);
        ui.editor.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') compileFunction(); });

        ui.savePresetBtn.addEventListener('click', () => {
            const name = prompt("Name your function:");
            if (name) {
                userPresets[name] = ui.editor.value;
                localStorage.setItem('angle_path_presets', JSON.stringify(userPresets));
                updatePresetDropdown();
                ui.presetSelect.value = `user:${name}`;
                compileFunction();
            }
        });

        ui.nAutoValue.addEventListener('click', () => {
            if (ui.nAutoValue.checked) {
                applySymmetryLock();
            }
        });

        const generateRandom = () => {
            const funcs = Object.keys(presets);
            const randFunc = funcs[Math.floor(Math.random() * funcs.length)];
            ui.presetSelect.value = randFunc;
            ui.editor.value = presets[randFunc];
            
            updateCPrecision(); 
            
            let logN = 3.0000 + Math.random() * 3.69897; 
            userBase.n = Math.floor(Math.pow(10.0000, logN));
            
            const minC = cPrecision === 6 ? 0.000001 : 0.001;
            let randC = Number((Math.random() * 2.0).toFixed(cPrecision));
            if(randC < minC) randC = minC;
            
            updateC(randC); 

            ui.nSlider.value = Math.log10(userBase.n); 
            ui.nNumber.value = userBase.n;

            const animChoice = Math.floor(Math.random() * 3);
            ui.nAnim.checked = (animChoice === 1);
            ui.cAnim.checked = (animChoice === 2);

            // Trigger the UI displays for the animated panels
            ui.nAnimSettings.style.display = ui.nAnim.checked ? 'flex' : 'none';
            ui.cAnimSettings.style.display = ui.cAnim.checked ? 'flex' : 'none';
            
            const styles = ['neon', 'rainbow', 'solid', 'light', 'light-glow'];
            ui.style.value = styles[Math.floor(Math.random() * styles.length)];
            
            compileFunction();
        };

        const toggleRec = () => {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
                ui.recBtn.textContent = "‚è∫ Record"; ui.recInd.style.display = 'none';
            } else {
                recordedChunks = [];
                const stream = canvas.captureStream(60);
                try { mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' }); } 
                catch (e) { mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); }
                mediaRecorder.ondataavailable = e => { if(e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    const b = new Blob(recordedChunks, { type: 'video/webm' });
                    const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `anglepath-${Date.now()}.webm`; a.click();
                };
                recStartTime = performance.now();
                mediaRecorder.start();
                ui.recBtn.textContent = "‚èπ Stop"; ui.recInd.style.display = 'flex';
            }
        };

        function updateRecTimer() {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                const elapsed = Math.floor((performance.now() - recStartTime) / 1000);
                ui.recTimer.textContent = `${Math.floor(elapsed/60).toString().padStart(2,'0')}:${(elapsed%60).toString().padStart(2,'0')}`;
            }
        }

        const saveImage = () => {
            const link = document.createElement('a');
            link.download = `anglepath-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        };

        const saveSVG = () => {
            const wasPaused = isPaused;
            isPaused = true;
            ui.pauseOverlay.innerHTML = "Building SVG<br><span style='font-size: 10px; color: #fff;'>Please wait...</span>";
            ui.pauseOverlay.style.display = 'block';

            // Use a short timeout to let the browser paint the "Paused/Building" UI 
            // before the synchronous SVG creation locks up the main thread momentarily
            setTimeout(() => {
                try {
                    const { N, time, bounds } = currentRenderState;
                    const style = ui.style.value;
                    const isLightTheme = style === 'light' || style === 'light-glow';
                    const bg = isLightTheme ? '#ffffff' : '#050505';
                    
                    // Add padding to bounds so lines aren't cut off on the edges
                    const pad = Math.max(0.1, 80000 / N) * 5;
                    const minX = bounds.minX - pad;
                    const minY = bounds.minY - pad;
                    const bbWidth = (bounds.maxX - bounds.minX) + pad * 2;
                    const bbHeight = (bounds.maxY - bounds.minY) + pad * 2;
                    
                    // Base stroke width relative to the raw viewport mapping
                    let lwMultiplier = parseFloat(ui.lwSlider.value) || 1.0;
                    let baseLineWidth = Math.max(0.1, 80000 / N) * lwMultiplier;

                    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${bbWidth} ${bbHeight}" style="background-color: ${bg};">\n`;

                    const MAX_PATH_SIZE = 500000; 
                    const numChunks = Math.ceil(N / MAX_PATH_SIZE);
                    let pathStrings = [];

                    for (let i = 0; i < numChunks; i++) {
                        const start = i * MAX_PATH_SIZE;
                        const end = Math.min((i + 1) * MAX_PATH_SIZE, N);

                        let dArray = [`M ${points[start * 2]} ${points[start * 2 + 1]}`];
                        for (let j = start + 1; j <= end; j++) {
                            dArray.push(`L ${points[j * 2]} ${points[j * 2 + 1]}`);
                        }
                        const dStr = dArray.join(' ');

                        if (style === 'rainbow') {
                            const color = `hsl(${(i / numChunks) * 360 + (time * 50)}, 90%, 60%)`;
                            pathStrings.push(`<path d="${dStr}" stroke="${color}" stroke-width="${baseLineWidth * 1.5}" fill="none" stroke-linejoin="round" stroke-linecap="round" />`);
                        } else if (style === 'neon') {
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(0, 210, 255, 0.4)" stroke-width="${baseLineWidth}" fill="none" style="mix-blend-mode: screen;" stroke-linejoin="round" stroke-linecap="round" />`);
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(255, 255, 255, 0.8)" stroke-width="${baseLineWidth * 0.3}" fill="none" style="mix-blend-mode: screen;" stroke-linejoin="round" stroke-linecap="round" />`);
                        } else if (style === 'light-glow') {
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(255, 0, 128, 0.3)" stroke-width="${baseLineWidth * 1.5}" fill="none" style="mix-blend-mode: multiply;" stroke-linejoin="round" stroke-linecap="round" />`);
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(30, 30, 30, 0.9)" stroke-width="${baseLineWidth * 0.4}" fill="none" style="mix-blend-mode: multiply;" stroke-linejoin="round" stroke-linecap="round" />`);
                        } else if (style === 'light') {
                            pathStrings.push(`<path d="${dStr}" stroke="rgba(10, 10, 10, 0.9)" stroke-width="${baseLineWidth * 0.5}" fill="none" stroke-linejoin="round" stroke-linecap="round" />`);
                        } else {
                            pathStrings.push(`<path d="${dStr}" stroke="#ffffff" stroke-width="${baseLineWidth * 0.5}" fill="none" stroke-linejoin="round" stroke-linecap="round" />`);
                        }
                    }

                    svg += pathStrings.join('\n') + '\n</svg>';

                    const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `anglepath-${Date.now()}.svg`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);

                } catch (e) {
                    console.error("Failed to build SVG:", e);
                    alert("Could not export SVG. The current step count may be too large to generate a vector path string.");
                }

                // Restore previous state
                isPaused = wasPaused;
                if (!isPaused) {
                    ui.pauseOverlay.style.display = 'none';
                } else {
                    ui.pauseOverlay.textContent = "PAUSED";
                }
            }, 100); 
        };

        ui.infoBtn.onclick = () => {
            const isVisible = ui.infoModal.style.display === 'flex';
            ui.infoModal.style.display = isVisible ? 'none' : 'flex';
        };
        document.getElementById('fs-btn').onclick = () => canvasContainer.requestFullscreen();
        document.getElementById('save-btn').onclick = saveImage;
        ui.saveSvgBtn.onclick = saveSVG;
        document.getElementById('rec-btn').onclick = toggleRec;
        document.getElementById('random-btn').onclick = generateRandom;
        ui.speed.oninput = () => ui.spdLabel.textContent = ui.speed.value;

        // Init
        updateConfigDropdown(); 
        updatePresetDropdown();
        compileFunction();
        liveLoop();

        // --- MOBILE UI MINIMIZE LOGIC ---
        (function() {
            const toggleBtn = document.createElement('button');
            toggleBtn.id = 'ui-toggle-btn';
            toggleBtn.textContent = 'Hide UI';
            document.body.appendChild(toggleBtn);

            toggleBtn.onclick = () => {
                const isCollapsed = document.body.classList.toggle('ui-collapsed');
                toggleBtn.textContent = isCollapsed ? 'Show UI' : 'Hide UI';
                
                // Trigger a resize event to ensure canvas centering logic updates
                window.dispatchEvent(new Event('resize'));
            };
        })();
    </script>
</body>
</html>